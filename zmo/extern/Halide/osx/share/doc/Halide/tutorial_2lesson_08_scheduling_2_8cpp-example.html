<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: tutorial/lesson_08_scheduling_2.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial_2lesson_08_scheduling_2_8cpp-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_08_scheduling_2.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Halide tutorial lesson 8: Scheduling multi-stage pipelines</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On linux, you can compile and run it like so:</span></div>
<div class="line"><span class="comment">// g++ lesson_08*.cpp -g -std=c++11 -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -lpthread -ldl -o lesson_08</span></div>
<div class="line"><span class="comment">// LD_LIBRARY_PATH=&lt;path/to/libHalide.so&gt; ./lesson_08</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On os x:</span></div>
<div class="line"><span class="comment">// g++ lesson_08*.cpp -g -std=c++11 -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -o lesson_08</span></div>
<div class="line"><span class="comment">// DYLD_LIBRARY_PATH=&lt;path/to/libHalide.dylib&gt; ./lesson_08</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you have the entire Halide source tree, you can also build it by</span></div>
<div class="line"><span class="comment">// running:</span></div>
<div class="line"><span class="comment">//    make tutorial_lesson_08_scheduling_2</span></div>
<div class="line"><span class="comment">// in a shell with the current directory at the top of the halide</span></div>
<div class="line"><span class="comment">// source tree.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Halide.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_halide.html">Halide</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="comment">// First we&#39;ll declare some Vars to use below.</span></div>
<div class="line">    Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s examine various scheduling options for a simple two stage</span></div>
<div class="line">    <span class="comment">// pipeline. We&#39;ll start with the default schedule:</span></div>
<div class="line">    {</div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_default&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_default&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The first stage will be some simple pointwise math similar</span></div>
<div class="line">        <span class="comment">// to our familiar gradient function. The value at position x,</span></div>
<div class="line">        <span class="comment">// y is the sin of product of x and y.</span></div>
<div class="line">        producer(x, y) = <a name="a0"></a><a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now we&#39;ll add a second stage which averages together multiple</span></div>
<div class="line">        <span class="comment">// points in the first stage.</span></div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll turn on tracing for both functions.</span></div>
<div class="line">        consumer.trace_stores();</div>
<div class="line">        producer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// And evaluate it over a 4x4 box.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer-consumer pipeline with default schedule\n&quot;</span>);</div>
<div class="line">        consumer.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// There were no messages about computing values of the</span></div>
<div class="line">        <span class="comment">// producer. This is because the default schedule fully</span></div>
<div class="line">        <span class="comment">// inlines &#39;producer&#39; into &#39;consumer&#39;. It is as if we had</span></div>
<div class="line">        <span class="comment">// written the following code instead:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// consumer(x, y) = (sin(x * y) +</span></div>
<div class="line">        <span class="comment">//                   sin(x * (y + 1)) +</span></div>
<div class="line">        <span class="comment">//                   sin((x + 1) * y) +</span></div>
<div class="line">        <span class="comment">//                   sin((x + 1) * (y + 1))/4);</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// All calls to &#39;producer&#39; have been replaced with the body of</span></div>
<div class="line">        <span class="comment">// &#39;producer&#39;, with the arguments substituted in for the</span></div>
<div class="line">        <span class="comment">// variables.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C code is:</span></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (<a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * (y + 1)) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>((x + 1) * y) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>((x + 1) * (y + 1))) / 4;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we look at the loop nest, the producer doesn&#39;t appear</span></div>
<div class="line">        <span class="comment">// at all. It has been inlined into the consumer.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Next we&#39;ll examine the next simplest option - computing all</span></div>
<div class="line">    <span class="comment">// values required in the producer before computing any of the</span></div>
<div class="line">    <span class="comment">// consumer. We call this schedule &quot;root&quot;.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Start with the same function definitions:</span></div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_root&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_root&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tell Halide to evaluate all of producer before any of consumer.</span></div>
<div class="line">        producer.compute_root();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        consumer.trace_stores();</div>
<div class="line">        producer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compile and run.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_root()\n&quot;</span>);</div>
<div class="line">        consumer.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reading the output we can see that:</span></div>
<div class="line">        <span class="comment">// A) There were stores to producer.</span></div>
<div class="line">        <span class="comment">// B) They all happened before any stores to consumer.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_compute_root.gif for a visualization.</span></div>
<div class="line">        <span class="comment">// The producer is on the left and the consumer is on the</span></div>
<div class="line">        <span class="comment">// right. Stores are marked in orange and loads are marked in</span></div>
<div class="line">        <span class="comment">// blue.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Allocate some temporary storage for the producer.</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[5][5];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the producer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 5; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 5; x++) {</div>
<div class="line">                producer_storage[y][x] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the consumer. Skip the prints this time.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[y][x] +</div>
<div class="line">                                producer_storage[y + 1][x] +</div>
<div class="line">                                producer_storage[y][x + 1] +</div>
<div class="line">                                producer_storage[y + 1][x + 1]) / 4;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that consumer was evaluated over a 4x4 box, so Halide</span></div>
<div class="line">        <span class="comment">// automatically inferred that producer was needed over a 5x5</span></div>
<div class="line">        <span class="comment">// box. This is the same &#39;bounds inference&#39; logic we saw in</span></div>
<div class="line">        <span class="comment">// the previous lesson, where it was used to detect and avoid</span></div>
<div class="line">        <span class="comment">// out-of-bounds reads from an input image.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we print the loop nest, we&#39;ll see something very</span></div>
<div class="line">        <span class="comment">// similar to the C above.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s compare the two approaches above from a performance</span></div>
<div class="line">    <span class="comment">// perspective.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Full inlining (the default schedule):</span></div>
<div class="line">    <span class="comment">// - Temporary memory allocated: 0</span></div>
<div class="line">    <span class="comment">// - Loads: 0</span></div>
<div class="line">    <span class="comment">// - Stores: 16</span></div>
<div class="line">    <span class="comment">// - Calls to sin: 64</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// producer.compute_root():</span></div>
<div class="line">    <span class="comment">// - Temporary memory allocated: 25 floats</span></div>
<div class="line">    <span class="comment">// - Loads: 64</span></div>
<div class="line">    <span class="comment">// - Stores: 41</span></div>
<div class="line">    <span class="comment">// - Calls to sin: 25</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// There&#39;s a trade-off here. Full inlining used minimal temporary</span></div>
<div class="line">    <span class="comment">// memory and memory bandwidth, but did a whole bunch of redundant</span></div>
<div class="line">    <span class="comment">// expensive math (calling sin). It evaluated most points in</span></div>
<div class="line">    <span class="comment">// &#39;producer&#39; four times. The second schedule,</span></div>
<div class="line">    <span class="comment">// producer.compute_root(), did the mimimum number of calls to</span></div>
<div class="line">    <span class="comment">// sin, but used more temporary memory and more memory bandwidth.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// In any given situation the correct choice can be difficult to</span></div>
<div class="line">    <span class="comment">// make. If you&#39;re memory-bandwidth limited, or don&#39;t have much</span></div>
<div class="line">    <span class="comment">// memory (e.g. because you&#39;re running on an old cell-phone), then</span></div>
<div class="line">    <span class="comment">// it can make sense to do redundant math. On the other hand, sin</span></div>
<div class="line">    <span class="comment">// is expensive, so if you&#39;re compute-limited then fewer calls to</span></div>
<div class="line">    <span class="comment">// sin will make your program faster. Adding vectorization or</span></div>
<div class="line">    <span class="comment">// multi-core parallelism tilts the scales in favor of doing</span></div>
<div class="line">    <span class="comment">// redundant work, because firing up multiple cpu cores increases</span></div>
<div class="line">    <span class="comment">// the amount of math you can do per second, but doesn&#39;t increase</span></div>
<div class="line">    <span class="comment">// your system memory bandwidth or capacity.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We can make choices in between full inlining and</span></div>
<div class="line">    <span class="comment">// compute_root. Next we&#39;ll alternate between computing the</span></div>
<div class="line">    <span class="comment">// producer and consumer on a per-scanline basis:</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Start with the same function definitions:</span></div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tell Halide to evaluate producer as needed per y coordinate</span></div>
<div class="line">        <span class="comment">// of the consumer:</span></div>
<div class="line">        producer.compute_at(consumer, y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This places the code that computes the producer just</span></div>
<div class="line">        <span class="comment">// *inside* the consumer&#39;s for loop over y, as in the</span></div>
<div class="line">        <span class="comment">// equivalent C below.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        producer.trace_stores();</div>
<div class="line">        consumer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compile and run.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_at(consumer, y)\n&quot;</span>);</div>
<div class="line">        consumer.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_compute_y.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reading the log or looking at the figure you should see</span></div>
<div class="line">        <span class="comment">// that producer and consumer alternate on a per-scanline</span></div>
<div class="line">        <span class="comment">// basis. Let&#39;s look at the equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Allocate space and compute enough of the producer to</span></div>
<div class="line">            <span class="comment">// satisfy this single scanline of the consumer. This</span></div>
<div class="line">            <span class="comment">// means a 5x2 box of the producer.</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                    producer_storage[py - y][px] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(px * py);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[0][x] +</div>
<div class="line">                                producer_storage[1][x] +</div>
<div class="line">                                producer_storage[0][x + 1] +</div>
<div class="line">                                producer_storage[1][x + 1]) / 4;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Again, if we print the loop nest, we&#39;ll see something very</span></div>
<div class="line">        <span class="comment">// similar to the C above.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are in</span></div>
<div class="line">        <span class="comment">// between inlining and compute root. We still allocate some</span></div>
<div class="line">        <span class="comment">// temporary memory, but less than compute_root, and with</span></div>
<div class="line">        <span class="comment">// better locality (we load from it soon after writing to it,</span></div>
<div class="line">        <span class="comment">// so for larger images, values should still be in cache). We</span></div>
<div class="line">        <span class="comment">// still do some redundant work, but less than full inlining:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// producer.compute_at(consumer, y):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 64</span></div>
<div class="line">        <span class="comment">// - Stores: 56</span></div>
<div class="line">        <span class="comment">// - Calls to sin: 40</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We could also say producer.compute_at(consumer, x), but this</span></div>
<div class="line">    <span class="comment">// would be very similar to full inlining (the default</span></div>
<div class="line">    <span class="comment">// schedule). Instead let&#39;s distinguish between the loop level at</span></div>
<div class="line">    <span class="comment">// which we allocate storage for producer, and the loop level at</span></div>
<div class="line">    <span class="comment">// which we actually compute it. This unlocks a few optimizations.</span></div>
<div class="line">    {</div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_root_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_root_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tell Halide to make a buffer to store all of producer at</span></div>
<div class="line">        <span class="comment">// the outermost level:</span></div>
<div class="line">        producer.store_root();</div>
<div class="line">        <span class="comment">// ... but compute it as needed per y coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer.</span></div>
<div class="line">        producer.compute_at(consumer, y);</div>
<div class="line"> </div>
<div class="line">        producer.trace_stores();</div>
<div class="line">        consumer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, y)\n&quot;</span>);</div>
<div class="line">        consumer.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_store_root_compute_y.gif for a</span></div>
<div class="line">        <span class="comment">// visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reading the log or looking at the figure you should see</span></div>
<div class="line">        <span class="comment">// that producer and consumer again alternate on a</span></div>
<div class="line">        <span class="comment">// per-scanline basis. It computes a 5x2 box of the producer</span></div>
<div class="line">        <span class="comment">// to satisfy the first scanline of the consumer, but after</span></div>
<div class="line">        <span class="comment">// that it only computes a 5x1 box of the output for each new</span></div>
<div class="line">        <span class="comment">// scanline of the consumer!</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Halide has detected that for all scanlines except for the</span></div>
<div class="line">        <span class="comment">// first, it can reuse the values already sitting in the</span></div>
<div class="line">        <span class="comment">// buffer we&#39;ve allocated for producer. Let&#39;s look at the</span></div>
<div class="line">        <span class="comment">// equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// producer.store_root() implies that storage goes here:</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[5][5];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Compute enough of the producer to satisfy this scanline</span></div>
<div class="line">            <span class="comment">// of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Skip over rows of producer that we&#39;ve already</span></div>
<div class="line">                <span class="comment">// computed in a previous iteration.</span></div>
<div class="line">                <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                    producer_storage[py][px] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(px * py);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[y][x] +</div>
<div class="line">                                producer_storage[y + 1][x] +</div>
<div class="line">                                producer_storage[y][x + 1] +</div>
<div class="line">                                producer_storage[y + 1][x + 1]) / 4;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are pretty</span></div>
<div class="line">        <span class="comment">// good! The numbers are similar to compute_root, except locality</span></div>
<div class="line">        <span class="comment">// is better. We&#39;re doing the minimum number of sin calls,</span></div>
<div class="line">        <span class="comment">// and we load values soon after they are stored, so we&#39;re</span></div>
<div class="line">        <span class="comment">// probably making good use of the cache:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// producer.store_root().compute_at(consumer, y):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 64</span></div>
<div class="line">        <span class="comment">// - Stores: 39</span></div>
<div class="line">        <span class="comment">// - Calls to sin: 25</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that my claimed amount of memory allocated doesn&#39;t</span></div>
<div class="line">        <span class="comment">// match the reference C code. Halide is performing one more</span></div>
<div class="line">        <span class="comment">// optimization under the hood. It folds the storage for the</span></div>
<div class="line">        <span class="comment">// producer down into a circular buffer of two</span></div>
<div class="line">        <span class="comment">// scanlines. Equivalent C would actually look like this:</span></div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Actually store 2 scanlines instead of 5</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line">                    <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                        <span class="comment">// Stores to producer_storage have their y coordinate bit-masked.</span></div>
<div class="line">                        producer_storage[py &amp; 1][px] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(px * py);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                    <span class="comment">// Loads from producer_storage have their y coordinate bit-masked.</span></div>
<div class="line">                    result[y][x] = (producer_storage[y &amp; 1][x] +</div>
<div class="line">                                    producer_storage[(y + 1) &amp; 1][x] +</div>
<div class="line">                                    producer_storage[y &amp; 1][x + 1] +</div>
<div class="line">                                    producer_storage[(y + 1) &amp; 1][x + 1]) / 4;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We can do even better, by leaving the storage in the outermost</span></div>
<div class="line">    <span class="comment">// loop, but moving the computation into the innermost loop:</span></div>
<div class="line">    {</div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_root_x&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_root_x&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Store outermost, compute innermost.</span></div>
<div class="line">        producer.store_root().compute_at(consumer, x);</div>
<div class="line"> </div>
<div class="line">        producer.trace_stores();</div>
<div class="line">        consumer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, x)\n&quot;</span>);</div>
<div class="line">        consumer.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_store_root_compute_x.gif for a</span></div>
<div class="line">        <span class="comment">// visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// You should see that producer and consumer now alternate on</span></div>
<div class="line">        <span class="comment">// a per-pixel basis. Here&#39;s the equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// producer.store_root() implies that storage goes here, but</span></div>
<div class="line">        <span class="comment">// we can fold it down into a circular buffer of two</span></div>
<div class="line">        <span class="comment">// scanlines:</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For every pixel of the consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute enough of the producer to satisfy this</span></div>
<div class="line">                <span class="comment">// pixel of the consumer, but skip values that we&#39;ve</span></div>
<div class="line">                <span class="comment">// already computed:</span></div>
<div class="line">                <span class="keywordflow">if</span> (y == 0 &amp;&amp; x == 0) {</div>
<div class="line">                    producer_storage[y &amp; 1][x] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (y == 0) {</div>
<div class="line">                    producer_storage[y &amp; 1][x + 1] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>((x + 1) * y);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (x == 0) {</div>
<div class="line">                    producer_storage[(y + 1) &amp; 1][x] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * (y + 1));</div>
<div class="line">                }</div>
<div class="line">                producer_storage[(y + 1) &amp; 1][x + 1] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>((x + 1) * (y + 1));</div>
<div class="line"> </div>
<div class="line">                result[y][x] = (producer_storage[y &amp; 1][x] +</div>
<div class="line">                                producer_storage[(y + 1) &amp; 1][x] +</div>
<div class="line">                                producer_storage[y &amp; 1][x + 1] +</div>
<div class="line">                                producer_storage[(y + 1) &amp; 1][x + 1]) / 4;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are the</span></div>
<div class="line">        <span class="comment">// best so far. One of the four values of the producer we need</span></div>
<div class="line">        <span class="comment">// is probably still sitting in a register, so I won&#39;t count</span></div>
<div class="line">        <span class="comment">// it as a load:</span></div>
<div class="line">        <span class="comment">// producer.store_root().compute_at(consumer, x):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 48</span></div>
<div class="line">        <span class="comment">// - Stores: 56</span></div>
<div class="line">        <span class="comment">// - Calls to sin: 25</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// So what&#39;s the catch? Why not always do</span></div>
<div class="line">    <span class="comment">// producer.store_root().compute_at(consumer, x) for this type of</span></div>
<div class="line">    <span class="comment">// code?</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// The answer is parallelism. In both of the previous two</span></div>
<div class="line">    <span class="comment">// strategies we&#39;ve assumed that values computed in previous</span></div>
<div class="line">    <span class="comment">// iterations are lying around for us to reuse. This assumes that</span></div>
<div class="line">    <span class="comment">// previous values of x or y happened earlier in time and have</span></div>
<div class="line">    <span class="comment">// finished. This is not true if you parallelize or vectorize</span></div>
<div class="line">    <span class="comment">// either loop. Darn. If you parallelize, Halide won&#39;t inject the</span></div>
<div class="line">    <span class="comment">// optimizations that skip work already done if there&#39;s a parallel</span></div>
<div class="line">    <span class="comment">// loop in between the store_at level and the compute_at level,</span></div>
<div class="line">    <span class="comment">// and won&#39;t fold the storage down into a circular buffer either,</span></div>
<div class="line">    <span class="comment">// which makes our store_root pointless.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We&#39;re running out of options. We can make new ones by</span></div>
<div class="line">    <span class="comment">// splitting. We can store_at or compute_at at the natural</span></div>
<div class="line">    <span class="comment">// variables of the consumer (x and y), or we can split x or y</span></div>
<div class="line">    <span class="comment">// into new inner and outer sub-variables and then schedule with</span></div>
<div class="line">    <span class="comment">// respect to those. We&#39;ll use this to express fusion in tiles:</span></div>
<div class="line">    {</div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_tile&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_tile&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll compute 8x8 of the consumer, in 4x4 tiles.</span></div>
<div class="line">        Var x_outer, y_outer, x_inner, y_inner;</div>
<div class="line">        consumer.tile(x, y, x_outer, y_outer, x_inner, y_inner, 4, 4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the producer per tile of the consumer</span></div>
<div class="line">        producer.compute_at(consumer, x_outer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notice that I wrote my schedule starting from the end of</span></div>
<div class="line">        <span class="comment">// the pipeline (the consumer). This is because the schedule</span></div>
<div class="line">        <span class="comment">// for the producer refers to x_outer, which we introduced</span></div>
<div class="line">        <span class="comment">// when we tiled the consumer. You can write it in the other</span></div>
<div class="line">        <span class="comment">// order, but it tends to be harder to read.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        producer.trace_stores();</div>
<div class="line">        consumer.trace_stores();</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating:\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;consumer.tile(x, y, x_outer, y_outer, x_inner, y_inner, 4, 4);\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;producer.compute_at(consumer, x_outer);\n&quot;</span>);</div>
<div class="line">        consumer.realize({8, 8});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_tile.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The producer and consumer now alternate on a per-tile</span></div>
<div class="line">        <span class="comment">// basis. Here&#39;s the equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> result[8][8];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For every tile of the consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_outer = 0; y_outer &lt; 2; y_outer++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="comment">// Compute the x and y coords of the start of this tile.</span></div>
<div class="line">                <span class="keywordtype">int</span> x_base = x_outer * 4;</div>
<div class="line">                <span class="keywordtype">int</span> y_base = y_outer * 4;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute enough of producer to satisfy this tile. A</span></div>
<div class="line">                <span class="comment">// 4x4 tile of the consumer requires a 5x5 tile of the</span></div>
<div class="line">                <span class="comment">// producer.</span></div>
<div class="line">                <span class="keywordtype">float</span> producer_storage[5][5];</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y_base; py &lt; y_base + 5; py++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = x_base; px &lt; x_base + 5; px++) {</div>
<div class="line">                        producer_storage[py - y_base][px - x_base] = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(px * py);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute this tile of the consumer</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 4; y_inner++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 4; x_inner++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x = x_base + x_inner;</div>
<div class="line">                        <span class="keywordtype">int</span> y = y_base + y_inner;</div>
<div class="line">                        result[y][x] =</div>
<div class="line">                            (producer_storage[y - y_base][x - x_base] +</div>
<div class="line">                             producer_storage[y - y_base + 1][x - x_base] +</div>
<div class="line">                             producer_storage[y - y_base][x - x_base + 1] +</div>
<div class="line">                             producer_storage[y - y_base + 1][x - x_base + 1]) / 4;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tiling can make sense for problems like this one with</span></div>
<div class="line">        <span class="comment">// stencils that reach outwards in x and y. Each tile can be</span></div>
<div class="line">        <span class="comment">// computed independently in parallel, and the redundant work</span></div>
<div class="line">        <span class="comment">// done by each tile isn&#39;t so bad once the tiles get large</span></div>
<div class="line">        <span class="comment">// enough.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s try a mixed strategy that combines what we have done with</span></div>
<div class="line">    <span class="comment">// splitting, parallelizing, and vectorizing. This is one that</span></div>
<div class="line">    <span class="comment">// often works well in practice for large images. If you</span></div>
<div class="line">    <span class="comment">// understand this schedule, then you understand 95% of scheduling</span></div>
<div class="line">    <span class="comment">// in Halide.</span></div>
<div class="line">    {</div>
<div class="line">        Func producer(<span class="stringliteral">&quot;producer_mixed&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_mixed&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y + 1) +</div>
<div class="line">                          producer(x + 1, y) +</div>
<div class="line">                          producer(x + 1, y + 1)) / 4;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Split the y coordinate of the consumer into strips of 16 scanlines:</span></div>
<div class="line">        Var yo, yi;</div>
<div class="line">        consumer.split(y, yo, yi, 16);</div>
<div class="line">        <span class="comment">// Compute the strips using a thread pool and a task queue.</span></div>
<div class="line">        consumer.parallel(yo);</div>
<div class="line">        <span class="comment">// Vectorize across x by a factor of four.</span></div>
<div class="line">        consumer.vectorize(x, 4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now store the producer per-strip. This will be 17 scanlines</span></div>
<div class="line">        <span class="comment">// of the producer (16+1), but hopefully it will fold down</span></div>
<div class="line">        <span class="comment">// into a circular buffer of two scanlines:</span></div>
<div class="line">        producer.store_at(consumer, yo);</div>
<div class="line">        <span class="comment">// Within each strip, compute the producer per scanline of the</span></div>
<div class="line">        <span class="comment">// consumer, skipping work done on previous scanlines.</span></div>
<div class="line">        producer.compute_at(consumer, yi);</div>
<div class="line">        <span class="comment">// Also vectorize the producer (because sin is vectorizable on x86 using SSE).</span></div>
<div class="line">        producer.vectorize(x, 4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Let&#39;s leave tracing off this time, because we&#39;re going to</span></div>
<div class="line">        <span class="comment">// evaluate over a larger image.</span></div>
<div class="line">        <span class="comment">// consumer.trace_stores();</span></div>
<div class="line">        <span class="comment">// producer.trace_stores();</span></div>
<div class="line"> </div>
<div class="line">        Buffer&lt;float&gt; halide_result = consumer.realize({160, 160});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_08_mixed.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Here&#39;s the equivalent (serial) C:</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> c_result[160][160];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For every strip of 16 scanlines (this loop is parallel in</span></div>
<div class="line">        <span class="comment">// the Halide version)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 160 / 16 + 1; yo++) {</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// 16 doesn&#39;t divide 160, so push the last slice upwards</span></div>
<div class="line">            <span class="comment">// to fit within [0, 159] (see lesson 05).</span></div>
<div class="line">            <span class="keywordtype">int</span> y_base = yo * 16;</div>
<div class="line">            <span class="keywordflow">if</span> (y_base &gt; 160 - 16) y_base = 160 - 16;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Allocate a two-scanline circular buffer for the producer</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][161];</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// For every scanline in the strip of 16:</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 16; yi++) {</div>
<div class="line">                <span class="keywordtype">int</span> y = y_base + yi;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line">                    <span class="comment">// Skip scanlines already computed *within this task*</span></div>
<div class="line">                    <span class="keywordflow">if</span> (yi &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Compute this scanline of the producer in 4-wide vectors</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 160 / 4 + 1; x_vec++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x_base = x_vec * 4;</div>
<div class="line">                        <span class="comment">// 4 doesn&#39;t divide 161, so push the last vector left</span></div>
<div class="line">                        <span class="comment">// (see lesson 05).</span></div>
<div class="line">                        <span class="keywordflow">if</span> (x_base &gt; 161 - 4) x_base = 161 - 4;</div>
<div class="line">                        <span class="comment">// If you&#39;re on x86, Halide generates SSE code for this part:</span></div>
<div class="line">                        <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};</div>
<div class="line">                        <span class="keywordtype">float</span> vec[4] = {sinf(x[0] * py), sinf(x[1] * py),</div>
<div class="line">                                        sinf(x[2] * py), sinf(x[3] * py)};</div>
<div class="line">                        producer_storage[py &amp; 1][x[0]] = vec[0];</div>
<div class="line">                        producer_storage[py &amp; 1][x[1]] = vec[1];</div>
<div class="line">                        producer_storage[py &amp; 1][x[2]] = vec[2];</div>
<div class="line">                        producer_storage[py &amp; 1][x[3]] = vec[3];</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Now compute consumer for this scanline:</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 160 / 4; x_vec++) {</div>
<div class="line">                    <span class="keywordtype">int</span> x_base = x_vec * 4;</div>
<div class="line">                    <span class="comment">// Again, Halide&#39;s equivalent here uses SSE.</span></div>
<div class="line">                    <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};</div>
<div class="line">                    <span class="keywordtype">float</span> vec[] = {</div>
<div class="line">                        (producer_storage[y &amp; 1][x[0]] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[0]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[0] + 1] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[0] + 1]) /</div>
<div class="line">                            4,</div>
<div class="line">                        (producer_storage[y &amp; 1][x[1]] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[1]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[1] + 1] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[1] + 1]) /</div>
<div class="line">                            4,</div>
<div class="line">                        (producer_storage[y &amp; 1][x[2]] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[2]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[2] + 1] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[2] + 1]) /</div>
<div class="line">                            4,</div>
<div class="line">                        (producer_storage[y &amp; 1][x[3]] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[3]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[3] + 1] +</div>
<div class="line">                         producer_storage[(y + 1) &amp; 1][x[3] + 1]) /</div>
<div class="line">                            4};</div>
<div class="line"> </div>
<div class="line">                    c_result[y][x[0]] = vec[0];</div>
<div class="line">                    c_result[y][x[1]] = vec[1];</div>
<div class="line">                    c_result[y][x[2]] = vec[2];</div>
<div class="line">                    c_result[y][x[3]] = vec[3];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        consumer.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Look on my code, ye mighty, and despair!</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Let&#39;s check the C result against the Halide result. Doing</span></div>
<div class="line">        <span class="comment">// this I found several bugs in my C implementation, which</span></div>
<div class="line">        <span class="comment">// should tell you something.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 160; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 160; x++) {</div>
<div class="line">                <span class="keywordtype">float</span> error = halide_result(x, y) - c_result[y][x];</div>
<div class="line">                <span class="comment">// It&#39;s floating-point math, so we&#39;ll allow some slop:</span></div>
<div class="line">                <span class="keywordflow">if</span> (error &lt; -0.001f || error &gt; 0.001f) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %f instead of %f\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This stuff is hard. We ended up in a three-way trade-off</span></div>
<div class="line">    <span class="comment">// between memory bandwidth, redundant work, and</span></div>
<div class="line">    <span class="comment">// parallelism. Halide can&#39;t make the correct choice for you</span></div>
<div class="line">    <span class="comment">// automatically (sorry). Instead it tries to make it easier for</span></div>
<div class="line">    <span class="comment">// you to explore various options, without messing up your</span></div>
<div class="line">    <span class="comment">// program. In fact, Halide promises that scheduling calls like</span></div>
<div class="line">    <span class="comment">// compute_root won&#39;t change the meaning of your algorithm -- you</span></div>
<div class="line">    <span class="comment">// should get the same bits back no matter how you schedule</span></div>
<div class="line">    <span class="comment">// things.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// So be empirical! Experiment with various schedules and keep a</span></div>
<div class="line">    <span class="comment">// log of performance. Form hypotheses and then try to prove</span></div>
<div class="line">    <span class="comment">// yourself wrong. Don&#39;t assume that you just need to vectorize</span></div>
<div class="line">    <span class="comment">// your code by a factor of four and run it on eight cores and</span></div>
<div class="line">    <span class="comment">// you&#39;ll get 32x faster. This almost never works. Modern systems</span></div>
<div class="line">    <span class="comment">// are complex enough that you can&#39;t predict performance reliably</span></div>
<div class="line">    <span class="comment">// without running your code.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We suggest you start by scheduling all of your non-trivial</span></div>
<div class="line">    <span class="comment">// stages compute_root, and then work from the end of the pipeline</span></div>
<div class="line">    <span class="comment">// upwards, inlining, parallelizing, and vectorizing each stage in</span></div>
<div class="line">    <span class="comment">// turn until you reach the top.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Halide is not just about vectorizing and parallelizing your</span></div>
<div class="line">    <span class="comment">// code. That&#39;s not enough to get you very far. Halide is about</span></div>
<div class="line">    <span class="comment">// giving you tools that help you quickly explore different</span></div>
<div class="line">    <span class="comment">// trade-offs between locality, redundant work, and parallelism,</span></div>
<div class="line">    <span class="comment">// without messing up the actual result you&#39;re trying to compute.</span></div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_halide_html"><div class="ttname"><a href="namespace_halide.html">Halide</a></div><div class="ttdoc">This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...</div><div class="ttdef"><b>Definition:</b> <a href="_add_atomic_mutex_8h_source.html#l00021">AddAtomicMutex.h:21</a></div></div>
<div class="ttc" id="anamespace_halide_html_a5e1fca22f79625765096133e39caee5e"><div class="ttname"><a href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">Halide::sin</a></div><div class="ttdeci">Expr sin(Expr x)</div><div class="ttdoc">Return the sine of a floating-point expression.</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
