<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: /Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_util_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Various utility functions used internally <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_halide_runtime_8h_source.html">runtime/HalideRuntime.h</a>&quot;</code><br />
</div>
<p><a href="_util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">Halide::Internal::meta_and&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_01_4.html">Halide::Internal::meta_and&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or.html">Halide::Internal::meta_or&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or_3_01_t1_00_01_args_8_8_8_01_4.html">Halide::Internal::meta_or&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Halide::Internal::all_are_convertible&lt; To, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">Halide::Internal::FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">Halide::Internal::TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_value.html">Halide::Internal::ScopedValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for saving/restoring variable values on the stack, to allow for early-exit that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">Halide::Internal::integer_sequence&lt; T, Ints &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1next__integer__sequence_3_01integer__sequence_3_01_t_00_01_ints_8_8_8_01_4_01_4.html">Halide::Internal::next_integer_sequence&lt; integer_sequence&lt; T, Ints... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">Halide::Internal::make_integer_sequence_helper&lt; T, I, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper_3_01_t_00_01_n_00_01_n_01_4.html">Halide::Internal::make_integer_sequence_helper&lt; T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_static_cast.html">Halide::Internal::StaticCast&lt; TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_roundtrippable.html">Halide::Internal::IsRoundtrippable&lt; TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aac993690e0d967c2392f24ce0d3ebf24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#aac993690e0d967c2392f24ce0d3ebf24">HALIDE_EXPORT</a>&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td></tr>
<tr class="separator:aac993690e0d967c2392f24ce0d3ebf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53da0047a6b6ce91b46f76c018d63931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a>&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a></td></tr>
<tr class="separator:a53da0047a6b6ce91b46f76c018d63931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682b56d8790910625ab95dda91d682de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#a682b56d8790910625ab95dda91d682de">HALIDE_TIC</a>&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a>(__FILE__, __LINE__)</td></tr>
<tr class="separator:a682b56d8790910625ab95dda91d682de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22c5f724721f543aaec81962555b6fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#ad22c5f724721f543aaec81962555b6fd">HALIDE_TOC</a>&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a>(__FILE__, __LINE__)</td></tr>
<tr class="separator:ad22c5f724721f543aaec81962555b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplParams" colspan="2">template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">Halide::Internal::make_integer_sequence</a> = typename make_integer_sequence_helper&lt; T, 0, N &gt;::type</td></tr>
<tr class="separator:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplParams" colspan="2">template&lt;size_t... Ints&gt; </td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5d7a7bcb6b4a7de95e27c3234a36c68">Halide::Internal::index_sequence</a> = integer_sequence&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, Ints... &gt;</td></tr>
<tr class="separator:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a77432e592449f569978b6aabd58831f0">Halide::Internal::make_index_sequence</a> = make_integer_sequence&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, N &gt;</td></tr>
<tr class="separator:a77432e592449f569978b6aabd58831f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abdb3bac86d5020a2fc5c0fad5eba8592">Halide::load_plugin</a> (const std::string &amp;lib_name)</td></tr>
<tr class="memdesc:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin in the form of a dynamic library (e.g.  <a href="namespace_halide.html#abdb3bac86d5020a2fc5c0fad5eba8592">More...</a><br /></td></tr>
<tr class="separator:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplParams" colspan="2">template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplItemLeft" align="right" valign="top">DST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">Halide::Internal::safe_numeric_cast</a> (SRC s)</td></tr>
<tr class="memdesc:ab7501900efa7660edf445ed1b14c020c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible.  <a href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">More...</a><br /></td></tr>
<tr class="separator:ab7501900efa7660edf445ed1b14c020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">Halide::Internal::reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">More...</a><br /></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d7dfc983d7a320ea1510c24bc55625"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">Halide::Internal::make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr class="memdesc:a18d7dfc983d7a320ea1510c24bc55625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">More...</a><br /></td></tr>
<tr class="separator:a18d7dfc983d7a320ea1510c24bc55625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">Halide::Internal::get_env_variable</a> (char const *env_var_name)</td></tr>
<tr class="memdesc:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <a href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">More...</a><br /></td></tr>
<tr class="separator:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">Halide::Internal::running_program_name</a> ()</td></tr>
<tr class="memdesc:ab4b793745b048fa1fd344907ec4ec9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <a href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">More...</a><br /></td></tr>
<tr class="separator:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd490221160a7206bb151d6eae65624"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">Halide::Internal::unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:aabd490221160a7206bb151d6eae65624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">More...</a><br /></td></tr>
<tr class="separator:aabd490221160a7206bb151d6eae65624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0bd73d997ddc50f3523a21448471f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7ec0bd73d997ddc50f3523a21448471f">Halide::Internal::unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a7ec0bd73d997ddc50f3523a21448471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ca52c958b993ebd766f4b83de2cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">Halide::Internal::starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af26ca52c958b993ebd766f4b83de2cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string.  <a href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">More...</a><br /></td></tr>
<tr class="separator:af26ca52c958b993ebd766f4b83de2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">Halide::Internal::ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a290fb244405de2c014ebdc3cd1fc8f08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string.  <a href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">More...</a><br /></td></tr>
<tr class="separator:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">Halide::Internal::replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9c06bf852ad18eb3e9014495f5816c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <a href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">More...</a><br /></td></tr>
<tr class="separator:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403191721c99e2a88864db3bafbf7b0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">Halide::Internal::split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a403191721c99e2a88864db3bafbf7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <a href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">More...</a><br /></td></tr>
<tr class="separator:a403191721c99e2a88864db3bafbf7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">Halide::Internal::fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <a href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">More...</a><br /></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">Halide::Internal::fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <a href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">More...</a><br /></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">Halide::Internal::extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <a href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">More...</a><br /></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">Halide::Internal::file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a4f8aad349dd3bfc69483b792fcab0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <a href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">More...</a><br /></td></tr>
<tr class="separator:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">Halide::Internal::dir_make_temp</a> ()</td></tr>
<tr class="memdesc:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <a href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">More...</a><br /></td></tr>
<tr class="separator:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a323363444e3d16237848f6f8715b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">Halide::Internal::file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aff2a323363444e3d16237848f6f8715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <a href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">More...</a><br /></td></tr>
<tr class="separator:aff2a323363444e3d16237848f6f8715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034796c3683c3301a09c0102c6adb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">Halide::Internal::assert_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a034796c3683c3301a09c0102c6adb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file doesn't exist.  <a href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">More...</a><br /></td></tr>
<tr class="separator:a034796c3683c3301a09c0102c6adb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">Halide::Internal::assert_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file DOES exist.  <a href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">More...</a><br /></td></tr>
<tr class="separator:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">Halide::Internal::file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <a href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">More...</a><br /></td></tr>
<tr class="separator:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c611b7403f5613f08fb701ea6eed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">Halide::Internal::ensure_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a947c611b7403f5613f08fb701ea6eed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that no file with this path exists.  <a href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">More...</a><br /></td></tr>
<tr class="separator:a947c611b7403f5613f08fb701ea6eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710588d377ce398aa366fc00f6d436aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">Halide::Internal::dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a710588d377ce398aa366fc00f6d436aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <a href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">More...</a><br /></td></tr>
<tr class="separator:a710588d377ce398aa366fc00f6d436aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f41b4199ab2236fb4056661f20cc11"><td class="memItemLeft" align="right" valign="top">FileStat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">Halide::Internal::file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa0f41b4199ab2236fb4056661f20cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <a href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">More...</a><br /></td></tr>
<tr class="separator:aa0f41b4199ab2236fb4056661f20cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad702fdea527abbf0f987c72aaacf9b69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad702fdea527abbf0f987c72aaacf9b69">Halide::Internal::read_entire_file</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:ad702fdea527abbf0f987c72aaacf9b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire contents of a file into a vector&lt;char&gt;.  <a href="namespace_halide_1_1_internal.html#ad702fdea527abbf0f987c72aaacf9b69">More...</a><br /></td></tr>
<tr class="separator:ad702fdea527abbf0f987c72aaacf9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a74e2116e6583961430bb9f96dc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">Halide::Internal::write_entire_file</a> (const std::string &amp;pathname, const void *source, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> source_len)</td></tr>
<tr class="memdesc:a4a0a74e2116e6583961430bb9f96dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or replace the contents of a file with a given pointer-and-length of memory.  <a href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">More...</a><br /></td></tr>
<tr class="separator:a4a0a74e2116e6583961430bb9f96dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a41c09f705e2859eea67df0e04501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a687a41c09f705e2859eea67df0e04501">Halide::Internal::write_entire_file</a> (const std::string &amp;pathname, const std::vector&lt; char &gt; &amp;source)</td></tr>
<tr class="separator:a687a41c09f705e2859eea67df0e04501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">Halide::Internal::add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">More...</a><br /></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">Halide::Internal::sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">Halide::Internal::mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342a753f8441a0b29418b0d22cbda86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:ae342a753f8441a0b29418b0d22cbda86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad2a455f3f5fbe779f6de0acbec1bfa44">Halide::Internal::c_print_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a version of a string that is a valid identifier in C (.  <a href="namespace_halide_1_1_internal.html#ad2a455f3f5fbe779f6de0acbec1bfa44">More...</a><br /></td></tr>
<tr class="separator:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a591746c6ae0cd3e8d24c2c2420772d8a">Halide::Internal::get_llvm_version</a> ()</td></tr>
<tr class="memdesc:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVM_VERSION against which this libHalide is compiled.  <a href="namespace_halide_1_1_internal.html#a591746c6ae0cd3e8d24c2c2420772d8a">More...</a><br /></td></tr>
<tr class="separator:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various utility functions used internally <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>

<p class="definition">Definition in file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aac993690e0d967c2392f24ce0d3ebf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993690e0d967c2392f24ce0d3ebf24">&#9670;&nbsp;</a></span>HALIDE_EXPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_EXPORT&#160;&#160;&#160;__attribute__((visibility(&quot;default&quot;)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00036">36</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a53da0047a6b6ce91b46f76c018d63931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53da0047a6b6ce91b46f76c018d63931">&#9670;&nbsp;</a></span>HALIDE_NO_USER_CODE_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_NO_USER_CODE_INLINE&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00044">44</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a682b56d8790910625ab95dda91d682de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682b56d8790910625ab95dda91d682de">&#9670;&nbsp;</a></span>HALIDE_TIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_TIC&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">Halide::Internal::halide_tic_impl</a>(__FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00417">417</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ad22c5f724721f543aaec81962555b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22c5f724721f543aaec81962555b6fd">&#9670;&nbsp;</a></span>HALIDE_TOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_TOC&#160;&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">Halide::Internal::halide_toc_impl</a>(__FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00418">418</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_util_8h.html">Util.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
