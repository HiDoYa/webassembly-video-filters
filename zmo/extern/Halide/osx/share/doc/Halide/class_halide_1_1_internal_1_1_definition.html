<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::Definition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_halide_1_1_internal_1_1_definition.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_internal_1_1_definition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal::Definition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition which can either represent a init or an update definition.  
 <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_definition_8h_source.html">Definition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4cc10787ebd2b308b4c4f1aabb049707"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a4cc10787ebd2b308b4c4f1aabb049707">Definition</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;)</td></tr>
<tr class="memdesc:a4cc10787ebd2b308b4c4f1aabb049707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> from an existing DefinitionContents pointer.  <a href="class_halide_1_1_internal_1_1_definition.html#a4cc10787ebd2b308b4c4f1aabb049707">More...</a><br /></td></tr>
<tr class="separator:a4cc10787ebd2b308b4c4f1aabb049707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff003cd3ef0e580de1192d06d9d799ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aff003cd3ef0e580de1192d06d9d799ec">Definition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#abc3ce26269a8eb1c0b68be8a56e7feab">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa98c0d7e5f87cc556ed7af758130e3af">values</a>, const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;rdom, bool <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a8378e598454bc28bcf1556e9e6683257">is_init</a>)</td></tr>
<tr class="memdesc:aff003cd3ef0e580de1192d06d9d799ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> with the supplied args, values, and reduction domain.  <a href="class_halide_1_1_internal_1_1_definition.html#aff003cd3ef0e580de1192d06d9d799ec">More...</a><br /></td></tr>
<tr class="separator:aff003cd3ef0e580de1192d06d9d799ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b9c93da2ed9e569a3d91aa4ee5ccf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a619b9c93da2ed9e569a3d91aa4ee5ccf">Definition</a> ()</td></tr>
<tr class="memdesc:a619b9c93da2ed9e569a3d91aa4ee5ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an undefined <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> object.  <a href="class_halide_1_1_internal_1_1_definition.html#a619b9c93da2ed9e569a3d91aa4ee5ccf">More...</a><br /></td></tr>
<tr class="separator:a619b9c93da2ed9e569a3d91aa4ee5ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabab013e38edce5a0c1ce6d01eea5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aeabab013e38edce5a0c1ce6d01eea5a5">get_copy</a> () const</td></tr>
<tr class="memdesc:aeabab013e38edce5a0c1ce6d01eea5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a>.  <a href="class_halide_1_1_internal_1_1_definition.html#aeabab013e38edce5a0c1ce6d01eea5a5">More...</a><br /></td></tr>
<tr class="separator:aeabab013e38edce5a0c1ce6d01eea5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240ca6e22ff4a6796240659f1cd58196"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a240ca6e22ff4a6796240659f1cd58196">same_as</a> (const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;other) const</td></tr>
<tr class="memdesc:a240ca6e22ff4a6796240659f1cd58196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of identity.  <a href="class_halide_1_1_internal_1_1_definition.html#a240ca6e22ff4a6796240659f1cd58196">More...</a><br /></td></tr>
<tr class="separator:a240ca6e22ff4a6796240659f1cd58196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2ca6ed247cf025facda56bd82da44c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#add2ca6ed247cf025facda56bd82da44c">defined</a> () const</td></tr>
<tr class="memdesc:add2ca6ed247cf025facda56bd82da44c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> objects are nullable.  <a href="class_halide_1_1_internal_1_1_definition.html#add2ca6ed247cf025facda56bd82da44c">More...</a><br /></td></tr>
<tr class="separator:add2ca6ed247cf025facda56bd82da44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8378e598454bc28bcf1556e9e6683257"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a8378e598454bc28bcf1556e9e6683257">is_init</a> () const</td></tr>
<tr class="memdesc:a8378e598454bc28bcf1556e9e6683257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an init definition; otherwise it's an update definition.  <a href="class_halide_1_1_internal_1_1_definition.html#a8378e598454bc28bcf1556e9e6683257">More...</a><br /></td></tr>
<tr class="separator:a8378e598454bc28bcf1556e9e6683257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a52d75df0dd2ec49ccb596bdfae7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ae0a52d75df0dd2ec49ccb596bdfae7fe">accept</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *) const</td></tr>
<tr class="memdesc:ae0a52d75df0dd2ec49ccb596bdfae7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> through to all Exprs referenced in the definition.  <a href="class_halide_1_1_internal_1_1_definition.html#ae0a52d75df0dd2ec49ccb596bdfae7fe">More...</a><br /></td></tr>
<tr class="separator:ae0a52d75df0dd2ec49ccb596bdfae7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a6de7f4d76339d93b4338c1ed48fb75f3">mutate</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *)</td></tr>
<tr class="memdesc:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g.">IRMutator</a> through to all Exprs referenced in the definition.  <a href="class_halide_1_1_internal_1_1_definition.html#a6de7f4d76339d93b4338c1ed48fb75f3">More...</a><br /></td></tr>
<tr class="separator:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3ce26269a8eb1c0b68be8a56e7feab"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#abc3ce26269a8eb1c0b68be8a56e7feab">args</a> () const</td></tr>
<tr class="memdesc:abc3ce26269a8eb1c0b68be8a56e7feab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) arguments (left-hand-side) of the definition.  <a href="class_halide_1_1_internal_1_1_definition.html#abc3ce26269a8eb1c0b68be8a56e7feab">More...</a><br /></td></tr>
<tr class="separator:abc3ce26269a8eb1c0b68be8a56e7feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4875343613fadef83aeae524512fe5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ad4875343613fadef83aeae524512fe5e">args</a> ()</td></tr>
<tr class="separator:ad4875343613fadef83aeae524512fe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98c0d7e5f87cc556ed7af758130e3af"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa98c0d7e5f87cc556ed7af758130e3af">values</a> () const</td></tr>
<tr class="memdesc:aa98c0d7e5f87cc556ed7af758130e3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) right-hand-side of the definition.  <a href="class_halide_1_1_internal_1_1_definition.html#aa98c0d7e5f87cc556ed7af758130e3af">More...</a><br /></td></tr>
<tr class="separator:aa98c0d7e5f87cc556ed7af758130e3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dafa96f3f679c0cb44d9448d83d5e06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a9dafa96f3f679c0cb44d9448d83d5e06">values</a> ()</td></tr>
<tr class="separator:a9dafa96f3f679c0cb44d9448d83d5e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a5a74d142344538c52ab2dbcb3cab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a309a5a74d142344538c52ab2dbcb3cab">predicate</a> () const</td></tr>
<tr class="memdesc:a309a5a74d142344538c52ab2dbcb3cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the predicate on the definition.  <a href="class_halide_1_1_internal_1_1_definition.html#a309a5a74d142344538c52ab2dbcb3cab">More...</a><br /></td></tr>
<tr class="separator:a309a5a74d142344538c52ab2dbcb3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364f6c2b3aa0f2fd031b48b52566168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa364f6c2b3aa0f2fd031b48b52566168">predicate</a> ()</td></tr>
<tr class="separator:aa364f6c2b3aa0f2fd031b48b52566168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14904472152e47025b48eaebf0c7335"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ad14904472152e47025b48eaebf0c7335">split_predicate</a> () const</td></tr>
<tr class="memdesc:ad14904472152e47025b48eaebf0c7335"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs.  <a href="class_halide_1_1_internal_1_1_definition.html#ad14904472152e47025b48eaebf0c7335">More...</a><br /></td></tr>
<tr class="separator:ad14904472152e47025b48eaebf0c7335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c3c6738aef3d711adb4debdcf759bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a24c3c6738aef3d711adb4debdcf759bc">schedule</a> () const</td></tr>
<tr class="memdesc:a24c3c6738aef3d711adb4debdcf759bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) stage-specific schedule associated with this definition.  <a href="class_halide_1_1_internal_1_1_definition.html#a24c3c6738aef3d711adb4debdcf759bc">More...</a><br /></td></tr>
<tr class="separator:a24c3c6738aef3d711adb4debdcf759bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b2b1f162aa1245f79e5f5eb6e589d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa1b2b1f162aa1245f79e5f5eb6e589d0">schedule</a> ()</td></tr>
<tr class="separator:aa1b2b1f162aa1245f79e5f5eb6e589d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894f484113bd48249045c13b92c75bc5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a894f484113bd48249045c13b92c75bc5">specializations</a> () const</td></tr>
<tr class="memdesc:a894f484113bd48249045c13b92c75bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different stage-specific schedules.  <a href="class_halide_1_1_internal_1_1_definition.html#a894f484113bd48249045c13b92c75bc5">More...</a><br /></td></tr>
<tr class="separator:a894f484113bd48249045c13b92c75bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48069f34b6ce2c3e8c9cc7b23bbf1af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa48069f34b6ce2c3e8c9cc7b23bbf1af">specializations</a> ()</td></tr>
<tr class="separator:aa48069f34b6ce2c3e8c9cc7b23bbf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceee5e0023aaa27c790d07d2fbe9543"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aeceee5e0023aaa27c790d07d2fbe9543">add_specialization</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition)</td></tr>
<tr class="separator:aeceee5e0023aaa27c790d07d2fbe9543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189eeb42a6547c30b3387cf7c1906a07"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a189eeb42a6547c30b3387cf7c1906a07">source_location</a> () const</td></tr>
<tr class="memdesc:a189eeb42a6547c30b3387cf7c1906a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the source file and line where this definition was made using DWARF introspection.  <a href="class_halide_1_1_internal_1_1_definition.html#a189eeb42a6547c30b3387cf7c1906a07">More...</a><br /></td></tr>
<tr class="separator:a189eeb42a6547c30b3387cf7c1906a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition which can either represent a init or an update definition. </p>
<p>A function may have different definitions due to specialization, which are stored in 'specializations' (<a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false.">Not</a> possible from the front-end, but some scheduling directives may potentially cause this divergence to occur). Although init definition may have multiple values (RHS) per specialization, it must have the same LHS (i.e. same pure dimension variables). The update definition, on the other hand, may have different LHS/RHS per specialization. Note that, while the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> in LHS/RHS may be different across specializations, they must have the same number of dimensions and the same pure dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_definition_8h_source.html#l00038">38</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4cc10787ebd2b308b4c4f1aabb049707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc10787ebd2b308b4c4f1aabb049707">&#9670;&nbsp;</a></span>Definition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> from an existing DefinitionContents pointer. </p>
<p>Must be non-null </p>

</div>
</div>
<a id="aff003cd3ef0e580de1192d06d9d799ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff003cd3ef0e580de1192d06d9d799ec">&#9670;&nbsp;</a></span>Definition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;&#160;</td>
          <td class="paramname"><em>rdom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> with the supplied args, values, and reduction domain. </p>

</div>
</div>
<a id="a619b9c93da2ed9e569a3d91aa4ee5ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619b9c93da2ed9e569a3d91aa4ee5ccf">&#9670;&nbsp;</a></span>Definition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an undefined <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeabab013e38edce5a0c1ce6d01eea5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabab013e38edce5a0c1ce6d01eea5a5">&#9670;&nbsp;</a></span>get_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::Definition::get_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a>. </p>

</div>
</div>
<a id="a240ca6e22ff4a6796240659f1cd58196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240ca6e22ff4a6796240659f1cd58196">&#9670;&nbsp;</a></span>same_as()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::same_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality of identity. </p>

<p class="definition">Definition at line <a class="el" href="_definition_8h_source.html#l00057">57</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00168">Halide::Internal::IntrusivePtr&lt; T &gt;::same_as()</a>.</p>

</div>
</div>
<a id="add2ca6ed247cf025facda56bd82da44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2ca6ed247cf025facda56bd82da44c">&#9670;&nbsp;</a></span>defined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::defined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> objects are nullable. </p>
<p>Does this definition exist? </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00094">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="a8378e598454bc28bcf1556e9e6683257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8378e598454bc28bcf1556e9e6683257">&#9670;&nbsp;</a></span>is_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::is_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this an init definition; otherwise it's an update definition. </p>

</div>
</div>
<a id="ae0a52d75df0dd2ec49ccb596bdfae7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a52d75df0dd2ec49ccb596bdfae7fe">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Definition::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a id="a6de7f4d76339d93b4338c1ed48fb75f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de7f4d76339d93b4338c1ed48fb75f3">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Definition::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g.">IRMutator</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a id="abc3ce26269a8eb1c0b68be8a56e7feab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3ce26269a8eb1c0b68be8a56e7feab">&#9670;&nbsp;</a></span>args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) arguments (left-hand-side) of the definition. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00094">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="ad4875343613fadef83aeae524512fe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4875343613fadef83aeae524512fe5e">&#9670;&nbsp;</a></span>args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa98c0d7e5f87cc556ed7af758130e3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98c0d7e5f87cc556ed7af758130e3af">&#9670;&nbsp;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) right-hand-side of the definition. </p>

</div>
</div>
<a id="a9dafa96f3f679c0cb44d9448d83d5e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dafa96f3f679c0cb44d9448d83d5e06">&#9670;&nbsp;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a309a5a74d142344538c52ab2dbcb3cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309a5a74d142344538c52ab2dbcb3cab">&#9670;&nbsp;</a></span>predicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the predicate on the definition. </p>

</div>
</div>
<a id="aa364f6c2b3aa0f2fd031b48b52566168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa364f6c2b3aa0f2fd031b48b52566168">&#9670;&nbsp;</a></span>predicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad14904472152e47025b48eaebf0c7335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14904472152e47025b48eaebf0c7335">&#9670;&nbsp;</a></span>split_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::Definition::split_predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs. </p>
<p>If there is no predicate (i.e. this definition is always valid), this returns an empty vector. </p>

</div>
</div>
<a id="a24c3c6738aef3d711adb4debdcf759bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c3c6738aef3d711adb4debdcf759bc">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) stage-specific schedule associated with this definition. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00108">Halide::Stage::get_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00094">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="aa1b2b1f162aa1245f79e5f5eb6e589d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b2b1f162aa1245f79e5f5eb6e589d0">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a894f484113bd48249045c13b92c75bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894f484113bd48249045c13b92c75bc5">&#9670;&nbsp;</a></span>specializations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different stage-specific schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#a7e84f672454064d16ab214cbae90c464">Func::specialize</a> </p>

</div>
</div>
<a id="aa48069f34b6ce2c3e8c9cc7b23bbf1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48069f34b6ce2c3e8c9cc7b23bbf1af">&#9670;&nbsp;</a></span>specializations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeceee5e0023aaa27c790d07d2fbe9543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeceee5e0023aaa27c790d07d2fbe9543">&#9670;&nbsp;</a></span>add_specialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&amp; Halide::Internal::Definition::add_specialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a189eeb42a6547c30b3387cf7c1906a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189eeb42a6547c30b3387cf7c1906a07">&#9670;&nbsp;</a></span>source_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::Definition::source_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to get the source file and line where this definition was made using DWARF introspection. </p>
<p>Returns an empty string if no debug symbols were found or the debug symbols were not understood. Works on OS X and Linux only. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/<a class="el" href="_definition_8h_source.html">Definition.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
