<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::StageSchedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_halide_1_1_internal_1_1_stage_schedule.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_internal_1_1_stage_schedule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal::StageSchedule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  
 <a href="class_halide_1_1_internal_1_1_stage_schedule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_schedule_8h_source.html">Schedule.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a066b29df9ea4b1b065265fec15db1d71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a066b29df9ea4b1b065265fec15db1d71">StageSchedule</a> (<a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; StageScheduleContents &gt; c)</td></tr>
<tr class="separator:a066b29df9ea4b1b065265fec15db1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9302763f6eb24574552d4e73747d6fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#af9302763f6eb24574552d4e73747d6fe">StageSchedule</a> (const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;other)=default</td></tr>
<tr class="separator:af9302763f6eb24574552d4e73747d6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34499fd20f22c8f7c2e3fc6e694fd6e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a34499fd20f22c8f7c2e3fc6e694fd6e4">StageSchedule</a> ()</td></tr>
<tr class="separator:a34499fd20f22c8f7c2e3fc6e694fd6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244a8cb75852048f48b12a39b35c49a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a244a8cb75852048f48b12a39b35c49a5">get_copy</a> () const</td></tr>
<tr class="memdesc:a244a8cb75852048f48b12a39b35c49a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html" title="A schedule for a single stage of a Halide pipeline.">StageSchedule</a>.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a244a8cb75852048f48b12a39b35c49a5">More...</a><br /></td></tr>
<tr class="separator:a244a8cb75852048f48b12a39b35c49a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3133aa6819fb3fc6d2a0091f18814f80"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a3133aa6819fb3fc6d2a0091f18814f80">touched</a> ()</td></tr>
<tr class="memdesc:a3133aa6819fb3fc6d2a0091f18814f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag is set to true if the dims list has been manipulated by the user (or if a ScheduleHandle was created that could have been used to manipulate it).  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a3133aa6819fb3fc6d2a0091f18814f80">More...</a><br /></td></tr>
<tr class="separator:a3133aa6819fb3fc6d2a0091f18814f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be2c7d533fb2d62762bfe7989c7b4fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a3be2c7d533fb2d62762bfe7989c7b4fc">touched</a> () const</td></tr>
<tr class="separator:a3be2c7d533fb2d62762bfe7989c7b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae230d157d30202f2f36ecc5379ff1e23"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ae230d157d30202f2f36ecc5379ff1e23">rvars</a> () const</td></tr>
<tr class="memdesc:ae230d157d30202f2f36ecc5379ff1e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">RVars of reduction domain associated with this schedule if there is any.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#ae230d157d30202f2f36ecc5379ff1e23">More...</a><br /></td></tr>
<tr class="separator:ae230d157d30202f2f36ecc5379ff1e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3675189b5df54fb76960fbf186958ecc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a3675189b5df54fb76960fbf186958ecc">rvars</a> ()</td></tr>
<tr class="separator:a3675189b5df54fb76960fbf186958ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1374a42125be4b0309c801b67d0bd8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a5a1374a42125be4b0309c801b67d0bd8">splits</a> () const</td></tr>
<tr class="memdesc:a5a1374a42125be4b0309c801b67d0bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The traversal of the domain of a function can have some of its dimensions split into sub-dimensions.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a5a1374a42125be4b0309c801b67d0bd8">More...</a><br /></td></tr>
<tr class="separator:a5a1374a42125be4b0309c801b67d0bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66cdd0cc5c89d302a1d5105015d918a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ad66cdd0cc5c89d302a1d5105015d918a">splits</a> ()</td></tr>
<tr class="separator:ad66cdd0cc5c89d302a1d5105015d918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53036921b1a9874b96413ec39082aae"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#af53036921b1a9874b96413ec39082aae">dims</a> () const</td></tr>
<tr class="memdesc:af53036921b1a9874b96413ec39082aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list and ordering of dimensions used to evaluate this function, after all splits have taken place.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#af53036921b1a9874b96413ec39082aae">More...</a><br /></td></tr>
<tr class="separator:af53036921b1a9874b96413ec39082aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c961f1e67ae66c4f42bb1566a5f000d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a2c961f1e67ae66c4f42bb1566a5f000d">dims</a> ()</td></tr>
<tr class="separator:a2c961f1e67ae66c4f42bb1566a5f000d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0375ae0812ecc09da97a29f1dcfe1f1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ad0375ae0812ecc09da97a29f1dcfe1f1">prefetches</a> () const</td></tr>
<tr class="memdesc:ad0375ae0812ecc09da97a29f1dcfe1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may perform prefetching in some of the dimensions of a function.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#ad0375ae0812ecc09da97a29f1dcfe1f1">More...</a><br /></td></tr>
<tr class="separator:ad0375ae0812ecc09da97a29f1dcfe1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967f8b5e790dddc3fae23f69c5964c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a8967f8b5e790dddc3fae23f69c5964c6">prefetches</a> ()</td></tr>
<tr class="separator:a8967f8b5e790dddc3fae23f69c5964c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b3a0beadd44e076a269c336bc8c3b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_fuse_loop_level.html">FuseLoopLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a85b3a0beadd44e076a269c336bc8c3b5">fuse_level</a> () const</td></tr>
<tr class="memdesc:a85b3a0beadd44e076a269c336bc8c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innermost loop level of fused loop nest for this function stage.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a85b3a0beadd44e076a269c336bc8c3b5">More...</a><br /></td></tr>
<tr class="separator:a85b3a0beadd44e076a269c336bc8c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a190b44e8745ffe0e313c3c8b9492c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_fuse_loop_level.html">FuseLoopLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a4a190b44e8745ffe0e313c3c8b9492c3">fuse_level</a> ()</td></tr>
<tr class="separator:a4a190b44e8745ffe0e313c3c8b9492c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e6af1ded7aef13698def40b70e4a8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a031e6af1ded7aef13698def40b70e4a8">fused_pairs</a> () const</td></tr>
<tr class="memdesc:a031e6af1ded7aef13698def40b70e4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of function stages that are to be fused with this function stage from the outermost loop to a certain loop level.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a031e6af1ded7aef13698def40b70e4a8">More...</a><br /></td></tr>
<tr class="separator:a031e6af1ded7aef13698def40b70e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90300c656795a0aabbfb1f30336c8dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ad90300c656795a0aabbfb1f30336c8dd">fused_pairs</a> ()</td></tr>
<tr class="separator:ad90300c656795a0aabbfb1f30336c8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67db3e765e6a80fa577ce09a64d4b454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a67db3e765e6a80fa577ce09a64d4b454">allow_race_conditions</a> () const</td></tr>
<tr class="memdesc:a67db3e765e6a80fa577ce09a64d4b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are race conditions permitted?  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a67db3e765e6a80fa577ce09a64d4b454">More...</a><br /></td></tr>
<tr class="separator:a67db3e765e6a80fa577ce09a64d4b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3246d11112b783a06333bb672b8fbfc"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ac3246d11112b783a06333bb672b8fbfc">allow_race_conditions</a> ()</td></tr>
<tr class="separator:ac3246d11112b783a06333bb672b8fbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b62cd960fe718edaf41c40c0b69d715"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a8b62cd960fe718edaf41c40c0b69d715">atomic</a> () const</td></tr>
<tr class="memdesc:a8b62cd960fe718edaf41c40c0b69d715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use atomic update?  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#a8b62cd960fe718edaf41c40c0b69d715">More...</a><br /></td></tr>
<tr class="separator:a8b62cd960fe718edaf41c40c0b69d715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea8589eff51108501e91af95108c699"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a7ea8589eff51108501e91af95108c699">atomic</a> ()</td></tr>
<tr class="separator:a7ea8589eff51108501e91af95108c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d75cc17169b522b4a2f1e56579e67f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#af5d75cc17169b522b4a2f1e56579e67f">override_atomic_associativity_test</a> () const</td></tr>
<tr class="memdesc:af5d75cc17169b522b4a2f1e56579e67f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_atomic.html" title="Lock all the Store nodes in the body statement.">Atomic</a> updates are only allowed on associative reductions.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#af5d75cc17169b522b4a2f1e56579e67f">More...</a><br /></td></tr>
<tr class="separator:af5d75cc17169b522b4a2f1e56579e67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ff03f87f7e9419b36ef978c3229deb"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ac6ff03f87f7e9419b36ef978c3229deb">override_atomic_associativity_test</a> ()</td></tr>
<tr class="separator:ac6ff03f87f7e9419b36ef978c3229deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306e489e48799c772a2cfbbd8a16aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ad306e489e48799c772a2cfbbd8a16aa2">accept</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *) const</td></tr>
<tr class="memdesc:ad306e489e48799c772a2cfbbd8a16aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> through to all Exprs referenced in the Schedule.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#ad306e489e48799c772a2cfbbd8a16aa2">More...</a><br /></td></tr>
<tr class="separator:ad306e489e48799c772a2cfbbd8a16aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20ab0106a3a4ba6057f00741806f161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#ac20ab0106a3a4ba6057f00741806f161">mutate</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *)</td></tr>
<tr class="memdesc:ac20ab0106a3a4ba6057f00741806f161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g.">IRMutator</a> through to all Exprs referenced in the Schedule.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#ac20ab0106a3a4ba6057f00741806f161">More...</a><br /></td></tr>
<tr class="separator:ac20ab0106a3a4ba6057f00741806f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline. </p>
<p>Right now this interface is basically a struct, offering mutable access to its innards. In the future it may become more encapsulated. </p>

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00609">609</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a066b29df9ea4b1b065265fec15db1d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066b29df9ea4b1b065265fec15db1d71">&#9670;&nbsp;</a></span>StageSchedule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::StageSchedule::StageSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; StageScheduleContents &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00613">613</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>

</div>
</div>
<a id="af9302763f6eb24574552d4e73747d6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9302763f6eb24574552d4e73747d6fe">&#9670;&nbsp;</a></span>StageSchedule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::StageSchedule::StageSchedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34499fd20f22c8f7c2e3fc6e694fd6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34499fd20f22c8f7c2e3fc6e694fd6e4">&#9670;&nbsp;</a></span>StageSchedule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::StageSchedule::StageSchedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a244a8cb75852048f48b12a39b35c49a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244a8cb75852048f48b12a39b35c49a5">&#9670;&nbsp;</a></span>get_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> Halide::Internal::StageSchedule::get_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html" title="A schedule for a single stage of a Halide pipeline.">StageSchedule</a>. </p>

</div>
</div>
<a id="a3133aa6819fb3fc6d2a0091f18814f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3133aa6819fb3fc6d2a0091f18814f80">&#9670;&nbsp;</a></span>touched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; Halide::Internal::StageSchedule::touched </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag is set to true if the dims list has been manipulated by the user (or if a ScheduleHandle was created that could have been used to manipulate it). </p>
<p>It controls the warning that occurs if you schedule the vars of the pure step but not the update steps. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00094">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="a3be2c7d533fb2d62762bfe7989c7b4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be2c7d533fb2d62762bfe7989c7b4fc">&#9670;&nbsp;</a></span>touched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::StageSchedule::touched </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae230d157d30202f2f36ecc5379ff1e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae230d157d30202f2f36ecc5379ff1e23">&#9670;&nbsp;</a></span>rvars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a>&gt;&amp; Halide::Internal::StageSchedule::rvars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RVars of reduction domain associated with this schedule if there is any. </p>

</div>
</div>
<a id="a3675189b5df54fb76960fbf186958ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3675189b5df54fb76960fbf186958ecc">&#9670;&nbsp;</a></span>rvars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a>&gt;&amp; Halide::Internal::StageSchedule::rvars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a1374a42125be4b0309c801b67d0bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1374a42125be4b0309c801b67d0bd8">&#9670;&nbsp;</a></span>splits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a>&gt;&amp; Halide::Internal::StageSchedule::splits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The traversal of the domain of a function can have some of its dimensions split into sub-dimensions. </p>
<p>See <a class="el" href="class_halide_1_1_func.html#a42871686919ba35c8e357388c9251bdc">Func::split</a> </p>

</div>
</div>
<a id="ad66cdd0cc5c89d302a1d5105015d918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66cdd0cc5c89d302a1d5105015d918a">&#9670;&nbsp;</a></span>splits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a>&gt;&amp; Halide::Internal::StageSchedule::splits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af53036921b1a9874b96413ec39082aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53036921b1a9874b96413ec39082aae">&#9670;&nbsp;</a></span>dims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a>&gt;&amp; Halide::Internal::StageSchedule::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list and ordering of dimensions used to evaluate this function, after all splits have taken place. </p>
<p>The first dimension in the vector corresponds to the innermost for loop, and the last is the outermost. Also specifies what type of for loop to use for each dimension. Does not specify the bounds on each dimension. These get inferred from how the function is used, what the splits are, and any optional bounds in the list below. </p>

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a2c961f1e67ae66c4f42bb1566a5f000d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c961f1e67ae66c4f42bb1566a5f000d">&#9670;&nbsp;</a></span>dims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a>&gt;&amp; Halide::Internal::StageSchedule::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0375ae0812ecc09da97a29f1dcfe1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0375ae0812ecc09da97a29f1dcfe1f1">&#9670;&nbsp;</a></span>prefetches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a>&gt;&amp; Halide::Internal::StageSchedule::prefetches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may perform prefetching in some of the dimensions of a function. </p>
<p>See <a class="el" href="class_halide_1_1_func.html#a0348534d9e8b48742f5953df522972c7">Func::prefetch</a> </p>

</div>
</div>
<a id="a8967f8b5e790dddc3fae23f69c5964c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967f8b5e790dddc3fae23f69c5964c6">&#9670;&nbsp;</a></span>prefetches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a>&gt;&amp; Halide::Internal::StageSchedule::prefetches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85b3a0beadd44e076a269c336bc8c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b3a0beadd44e076a269c336bc8c3b5">&#9670;&nbsp;</a></span>fuse_level() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_fuse_loop_level.html">FuseLoopLevel</a>&amp; Halide::Internal::StageSchedule::fuse_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innermost loop level of fused loop nest for this function stage. </p>
<p>Fusion runs from outermost to this loop level. The stages being fused should not have producer/consumer relationship. See <a class="el" href="class_halide_1_1_func.html#a2edbedccd083710819655f6e83635a7e">Func::compute_with</a> and <a class="el" href="class_halide_1_1_func.html#a2edbedccd083710819655f6e83635a7e">Func::compute_with</a> </p>

</div>
</div>
<a id="a4a190b44e8745ffe0e313c3c8b9492c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a190b44e8745ffe0e313c3c8b9492c3">&#9670;&nbsp;</a></span>fuse_level() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_fuse_loop_level.html">FuseLoopLevel</a>&amp; Halide::Internal::StageSchedule::fuse_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a031e6af1ded7aef13698def40b70e4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e6af1ded7aef13698def40b70e4a8">&#9670;&nbsp;</a></span>fused_pairs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a>&gt;&amp; Halide::Internal::StageSchedule::fused_pairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of function stages that are to be fused with this function stage from the outermost loop to a certain loop level. </p>
<p>Those function stages are to be computed AFTER this function stage at the last fused loop level. This list is populated when <a class="el" href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c" title="Given a bunch of functions that call each other, determine an order in which to do the scheduling.">realization_order()</a> is called. See <a class="el" href="class_halide_1_1_func.html#a2edbedccd083710819655f6e83635a7e">Func::compute_with</a> </p>

</div>
</div>
<a id="ad90300c656795a0aabbfb1f30336c8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90300c656795a0aabbfb1f30336c8dd">&#9670;&nbsp;</a></span>fused_pairs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a>&gt;&amp; Halide::Internal::StageSchedule::fused_pairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67db3e765e6a80fa577ce09a64d4b454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67db3e765e6a80fa577ce09a64d4b454">&#9670;&nbsp;</a></span>allow_race_conditions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::StageSchedule::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are race conditions permitted? </p>

</div>
</div>
<a id="ac3246d11112b783a06333bb672b8fbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3246d11112b783a06333bb672b8fbfc">&#9670;&nbsp;</a></span>allow_race_conditions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; Halide::Internal::StageSchedule::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b62cd960fe718edaf41c40c0b69d715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b62cd960fe718edaf41c40c0b69d715">&#9670;&nbsp;</a></span>atomic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::StageSchedule::atomic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use atomic update? </p>

</div>
</div>
<a id="a7ea8589eff51108501e91af95108c699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea8589eff51108501e91af95108c699">&#9670;&nbsp;</a></span>atomic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; Halide::Internal::StageSchedule::atomic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5d75cc17169b522b4a2f1e56579e67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d75cc17169b522b4a2f1e56579e67f">&#9670;&nbsp;</a></span>override_atomic_associativity_test() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::StageSchedule::override_atomic_associativity_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_atomic.html" title="Lock all the Store nodes in the body statement.">Atomic</a> updates are only allowed on associative reductions. </p>
<p>We try to prove the associativity, but the user can override the associativity test and suppress compiler error if the prover fails to recognize the associativity or the user does not care. </p>

</div>
</div>
<a id="ac6ff03f87f7e9419b36ef978c3229deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ff03f87f7e9419b36ef978c3229deb">&#9670;&nbsp;</a></span>override_atomic_associativity_test() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; Halide::Internal::StageSchedule::override_atomic_associativity_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad306e489e48799c772a2cfbbd8a16aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad306e489e48799c772a2cfbbd8a16aa2">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::StageSchedule::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> through to all Exprs referenced in the Schedule. </p>

</div>
</div>
<a id="ac20ab0106a3a4ba6057f00741806f161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20ab0106a3a4ba6057f00741806f161">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::StageSchedule::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g.">IRMutator</a> through to all Exprs referenced in the Schedule. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/<a class="el" href="_schedule_8h_source.html">Schedule.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
