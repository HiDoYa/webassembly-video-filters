<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_halide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Halide Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it.  
<a href="namespace_halide.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">BoundaryConditions</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_boundary_conditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Funcs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_concise_casts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_concise_casts.html">ConciseCasts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_py_torch"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_py_torch.html">PyTorch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_runtime.html">Runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Halide::Buffer</a> is a named shared reference to a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality.">Halide::Runtime::Buffer</a>.  <a href="class_halide_1_1_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_argument_estimates.html">ArgumentEstimates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_argument.html">Argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing an argument to a halide-generated function.  <a href="struct_halide_1_1_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_cost_model.html">CostModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_default_cost_model.html">DefaultCostModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure storing the adjoints <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="class_halide_1_1_derivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> errors.  <a href="struct_halide_1_1_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_runtime_error.html">RuntimeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while running a JIT-compiled <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="struct_halide_1_1_runtime_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_compile_error.html">CompileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while compiling a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> attributes to a user error.  <a href="struct_halide_1_1_compile_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_error.html">InternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while compiling a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> attributes to an internal compiler bug, or to an invalid use of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s internals.  <a href="struct_halide_1_1_internal_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_compile_time_error_reporter.html">CompileTimeErrorReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_compile_time_error_reporter.html" title="CompileTimeErrorReporter is used at compile time (not runtime) when an error or warning is generated ...">CompileTimeErrorReporter</a> is used at compile time (<em>not</em> runtime) when an error or warning is generated by <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  <a href="class_halide_1_1_compile_time_error_reporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> syntax.  <a href="struct_halide_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lets you use an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> as a key in a map of the form map&lt;Expr, Foo, ExprCompare&gt;  <a href="struct_halide_1_1_expr_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_external_code.html">ExternalCode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument to an extern-defined <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="struct_halide_1_1_extern_func_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1float16__t.html">float16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a type that implements half precision floating point (IEEE754 2008 binary16) in software.  <a href="struct_halide_1_1float16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1bfloat16__t.html">bfloat16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a type that implements half precision floating point using the bfloat16 format.  <a href="struct_halide_1_1bfloat16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can represent Vars or RVars.  <a href="struct_halide_1_1_var_or_r_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html">Stage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="class_halide_1_1_stage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Vars or Exprs.  <a href="class_halide_1_1_func_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_tuple_element_ref.html">FuncTupleElementRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of front-end syntax of the form f(x, y, z)[index], where x, y, z are Vars or Exprs.  <a href="class_halide_1_1_func_tuple_element_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_eviction_key.html">EvictionKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for identifying purpose of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> passed to memoize.  <a href="class_halide_1_1_eviction_key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A halide function.  <a href="class_halide_1_1_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a> is a templated class that can be used to modify the behavior of the <a class="el" href="class_halide_1_1_generator.html">Generator</a> at code-generation time.  <a href="class_halide_1_1_generator_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_input.html">GeneratorInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_output.html">GeneratorOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_context.html" title="GeneratorContext is a base class that is used when using Generators (or Stubs) directly; it is used t...">GeneratorContext</a> is a base class that is used when using Generators (or Stubs) directly; it is used to allow the outer context (typically, either a <a class="el" href="class_halide_1_1_generator.html">Generator</a> or "top-level" code) to specify certain information to the inner context to ensure that inner and outer Generators are compiled in a compatible way.  <a href="class_halide_1_1_generator_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_names_interface.html">NamesInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator.html">Generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image_param.html">ImageParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Image parameter to a halide pipeline.  <a href="class_halide_1_1_image_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_module.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A halide module.  <a href="class_halide_1_1_module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle on the output buffer of a pipeline.  <a href="class_halide_1_1_output_image_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_param.html">Param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar parameter to a halide pipeline.  <a href="class_halide_1_1_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_param_map.html">ParamMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing the machine parameters to generate the auto-scheduled code for.  <a href="struct_halide_1_1_machine_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom lowering pass.  <a href="struct_halide_1_1_custom_lowering_pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_auto_scheduler_results.html">AutoSchedulerResults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="class_halide_1_1_pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_extern_c_function.html">ExternCFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_var.html">RVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reduction variable represents a single dimension of a reduction domain (<a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>).  <a href="class_halide_1_1_r_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_dom.html">RDom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional domain over which to iterate.  <a href="class_halide_1_1_r_dom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_realization.html">Realization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_realization.html" title="A Realization is a vector of references to existing Buffer objects.">Realization</a> is a vector of references to existing <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> objects.  <a href="class_halide_1_1_realization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a site in a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> statement at the top of the body of a particular for loop.  <a href="class_halide_1_1_loop_level.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_fuse_loop_level.html">FuseLoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html">Target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing a target machine and os to generate code for.  <a href="struct_halide_1_1_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a small array of Exprs for defining and calling functions with multiple outputs.  <a href="class_halide_1_1_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="struct_halide_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> variable, to be used when defining functions.  <a href="class_halide_1_1_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_implicit_var.html">ImplicitVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_test_result.html">TestResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_task.html">Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_simd_op_check_test.html">SimdOpCheckTest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adac6d1605235bf518c12a05ed6850d43"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a></td></tr>
<tr class="memdesc:adac6d1605235bf518c12a05ed6850d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">More...</a><br /></td></tr>
<tr class="separator:adac6d1605235bf518c12a05ed6850d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b585cf844dcb14fa12386d743cbb24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad7b585cf844dcb14fa12386d743cbb24">ScheduleHandle</a></td></tr>
<tr class="separator:ad7b585cf844dcb14fa12386d743cbb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe643966574f0ad69cad7f936c086740"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afe643966574f0ad69cad7f936c086740">ModuleFactory</a> = std::function&lt; <a class="el" href="class_halide_1_1_module.html">Module</a>(const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="separator:afe643966574f0ad69cad7f936c086740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2a7a400cd68d41f2868eebb762c32e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6e2a7a400cd68d41f2868eebb762c32e">CompilerLoggerFactory</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">Internal::CompilerLogger</a> &gt;(const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="separator:a6e2a7a400cd68d41f2868eebb762c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a35e107901afb7e58583ea88ae3a6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a00a35e107901afb7e58583ea88ae3a6b">AutoSchedulerFn</a> = std::function&lt; void(const <a class="el" href="class_halide_1_1_pipeline.html">Pipeline</a> &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;, const <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &amp;, <a class="el" href="struct_halide_1_1_auto_scheduler_results.html">AutoSchedulerResults</a> *outputs)&gt;</td></tr>
<tr class="separator:a00a35e107901afb7e58583ea88ae3a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> { <br />
&#160;&#160;<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">Host</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">Default_GPU</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaa33b7755e5f9b504d2d038eaca4ff28d">CUDA</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea7982b09a852b37f2afb1227eaf552e47">OpenCL</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea3adf0945d2bbb4c868f37d38e02684d5">OpenGLCompute</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaeaa57a9b4248ce3968e718895e1c2f04">Metal</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea125e13c182697c5a282e4de6d7999eb0">Hexagon</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea4b2626a6b8b94341748b21e603039989">HexagonDma</a>
, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaac083508369e66fdeb744a9dbf917bee">D3D12Compute</a>
<br />
 }</td></tr>
<tr class="memdesc:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of device API.  <a href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">More...</a><br /></td></tr>
<tr class="separator:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f02315017283b26196866c92d4da9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> { <br />
&#160;&#160;<a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb">Auto</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a556e9a86db9c921373c6b5097817214a">Heap</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a2187e1021a911b3807cc1bea2eb1a9ca">Stack</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a0ba7583639a274c434bbe6ef797115a4">Register</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9ae70f90d745f5615e5bccbf337fcf74b7">GPUShared</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9adca9ac9e90136a545f57ebe550531dbb">GPUTexture</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a54ef2e772f864e79d6ac27325edd9f0e">LockedCache</a>
, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a4838ea37d7bdc9f7edf4a6185f0496e2">VTCM</a>
<br />
 }</td></tr>
<tr class="memdesc:af28f02315017283b26196866c92d4da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing different address spaces to be used with Func::store_in.  <a href="namespace_halide.html#af28f02315017283b26196866c92d4da9">More...</a><br /></td></tr>
<tr class="separator:af28f02315017283b26196866c92d4da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0a73a2b8a7322d8ac330adfce8d134"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> { <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67">Default</a>
, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257">C</a>
, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134a618c337d168d3e2f339a16f8f6069c20">CPlusPlus</a>
 }</td></tr>
<tr class="memdesc:a9a0a73a2b8a7322d8ac330adfce8d134"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum to specify calling convention for extern stages.  <a href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">More...</a><br /></td></tr>
<tr class="separator:a9a0a73a2b8a7322d8ac330adfce8d134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8b92dac95804211c0a875302da5f4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a> { <br />
&#160;&#160;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a08d5f9e9048e2000531c3170f4b833b1">assembly</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a05bcd6bc2c5f7d9a2881e398f0b47046">bitcode</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a311f8e1f5e3fdcbfdc6478c22b10dc18">c_header</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a015af973befd454e4865798605d42142">c_source</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a186be22498341345705f076e5284b323">compiler_log</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a69145b419344ef1bae3f04b31a73e15f">cpp_stub</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a7398e19fe1290ceb66f93afe92b93c61">featurization</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a58be17eec9473900cc830f456fac020a">llvm_assembly</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4aa8cfde6331bd59eb2ac96f8911c4b666">object</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4ab0c78a2d6b974f99eb59ff3194523260">python_extension</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4ae511a3b21360f6b2149b9464c7536a75">pytorch_wrapper</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a563873d38950b841aebf89c3be1b1a35">registration</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a799855594adc0f2bd7302c69d3234b5a">schedule</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a1c1bec5ce39d59c7ef87be64f7d41a9e">static_library</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a217ecb18a8f8e5f1889339c3fa093fc3">stmt</a>
, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a86bb0db5358a18cf840463ed6fb31678">stmt_html</a>
<br />
 }</td></tr>
<tr class="memdesc:afdb8b92dac95804211c0a875302da5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enums specifying various kinds of outputs that can be produced from a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Pipeline.  <a href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">More...</a><br /></td></tr>
<tr class="separator:afdb8b92dac95804211c0a875302da5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172db5c21e58bfed0793b7152657623c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> { <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623cab206a1b4ea1097761f78e8876f6da779">External</a>
, <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623ca46a7ceaa07d4cf61082c34cbf8f6a95c">ExternalPlusMetadata</a>
, <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>
 }</td></tr>
<tr class="memdesc:a172db5c21e58bfed0793b7152657623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of linkage a function in a lowered <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> module can have.  <a href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">More...</a><br /></td></tr>
<tr class="separator:a172db5c21e58bfed0793b7152657623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1953af304956bd6a5d0bd780b135f56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> { <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>
, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a0e7445a36a4c4afba58997fbc4871f3b">HTML</a>
 }</td></tr>
<tr class="memdesc:ad1953af304956bd6a5d0bd780b135f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if the output printed to file should be as a normal string or as an HTML file which can be opened in a browerser and manipulated via JS and CSS.  <a href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">More...</a><br /></td></tr>
<tr class="separator:ad1953af304956bd6a5d0bd780b135f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b78b48c1fe9126344a218d07348f4d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> { <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da08825280e3f8137556325061ba67ff8c">Clamp</a>
, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">GuardWithIf</a>
, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b">NonFaulting</a>
 }</td></tr>
<tr class="memdesc:a36b78b48c1fe9126344a218d07348f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to handle accesses outside the original extents in a prefetch.  <a href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">More...</a><br /></td></tr>
<tr class="separator:a36b78b48c1fe9126344a218d07348f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6557df562bd7850664e70fdb8fea0f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> { <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa16b999f69f07356ae94c65a20b832926">RoundUp</a>
, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa5b80e0001d7f4873a60bbded160c687d">GuardWithIf</a>
, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0faa3c9898dfb77c232e7dbbcb95cadaa16">ShiftInwards</a>
, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">Auto</a>
 }</td></tr>
<tr class="memdesc:a6c6557df562bd7850664e70fdb8fea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to handle a tail case in a split when the factor does not provably divide the extent.  <a href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">More...</a><br /></td></tr>
<tr class="separator:a6c6557df562bd7850664e70fdb8fea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751041c9a6cffe776b613f4dd04c3354"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> { <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">AlignStart</a>
, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">AlignEnd</a>
, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a0835c1623d085e407eba4f9310103309">NoAlign</a>
, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">Auto</a>
 }</td></tr>
<tr class="memdesc:a751041c9a6cffe776b613f4dd04c3354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to handle the case when the start/end of the loops of stages computed with (fused) are not aligned.  <a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">More...</a><br /></td></tr>
<tr class="separator:a751041c9a6cffe776b613f4dd04c3354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98ec21770ee3d7bac1f0c1a9d5fd0644"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_default_cost_model.html">DefaultCostModel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a98ec21770ee3d7bac1f0c1a9d5fd0644">make_default_cost_model</a> (const std::string &amp;weights_in_dir=&quot;&quot;, const std::string &amp;weights_out_dir=&quot;&quot;, bool randomize_weights=false)</td></tr>
<tr class="separator:a98ec21770ee3d7bac1f0c1a9d5fd0644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952af26f2b37156587562bdeccfaba8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1952af26f2b37156587562bdeccfaba8">codegen_llvm</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, llvm::LLVMContext &amp;context)</td></tr>
<tr class="memdesc:a1952af26f2b37156587562bdeccfaba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> module, generate an llvm::Module.  <a href="namespace_halide.html#a1952af26f2b37156587562bdeccfaba8">More...</a><br /></td></tr>
<tr class="separator:a1952af26f2b37156587562bdeccfaba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7082de94433ce36f34d486a0bddbc200"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7082de94433ce36f34d486a0bddbc200">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:a7082de94433ce36f34d486a0bddbc200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an expression on an output stream (such as std::cout) in human-readable form.  <a href="namespace_halide.html#a7082de94433ce36f34d486a0bddbc200">More...</a><br /></td></tr>
<tr class="separator:a7082de94433ce36f34d486a0bddbc200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a873047edcc26c57685fd8f0b1e2e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af00a873047edcc26c57685fd8f0b1e2e">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;)</td></tr>
<tr class="memdesc:af00a873047edcc26c57685fd8f0b1e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide type on an output stream (such as std::cout) in human-readable form.  <a href="namespace_halide.html#af00a873047edcc26c57685fd8f0b1e2e">More...</a><br /></td></tr>
<tr class="separator:af00a873047edcc26c57685fd8f0b1e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e793e1d0e898cdd6003272ad051668"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80e793e1d0e898cdd6003272ad051668">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;)</td></tr>
<tr class="memdesc:a80e793e1d0e898cdd6003272ad051668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> on an output stream (such as std::cout) in human-readable form.  <a href="namespace_halide.html#a80e793e1d0e898cdd6003272ad051668">More...</a><br /></td></tr>
<tr class="separator:a80e793e1d0e898cdd6003272ad051668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd783f233611c16b4f805dacc89cca42"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afd783f233611c16b4f805dacc89cca42">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;)</td></tr>
<tr class="memdesc:afd783f233611c16b4f805dacc89cca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> in a human readable form.  <a href="namespace_halide.html#afd783f233611c16b4f805dacc89cca42">More...</a><br /></td></tr>
<tr class="separator:afd783f233611c16b4f805dacc89cca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e455180d26c51953b64f318f3c8b11f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1e455180d26c51953b64f318f3c8b11f">propagate_adjoints</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;output, const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;adjoint, const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;output_bounds)</td></tr>
<tr class="memdesc:a1e455180d26c51953b64f318f3c8b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and a corresponding adjoint, (back)propagate the adjoint to all dependent Funcs, buffers, and parameters.  <a href="namespace_halide.html#a1e455180d26c51953b64f318f3c8b11f">More...</a><br /></td></tr>
<tr class="separator:a1e455180d26c51953b64f318f3c8b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754b88aa3b1aa18a7809f665ba10aad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a754b88aa3b1aa18a7809f665ba10aad9">propagate_adjoints</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;output, const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; float &gt; &amp;adjoint)</td></tr>
<tr class="memdesc:a754b88aa3b1aa18a7809f665ba10aad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and a corresponding adjoint buffer, (back)propagate the adjoint to all dependent Funcs, buffers, and parameters.  <a href="namespace_halide.html#a754b88aa3b1aa18a7809f665ba10aad9">More...</a><br /></td></tr>
<tr class="separator:a754b88aa3b1aa18a7809f665ba10aad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a3ed6633ddd588c45cfa98dcaf84ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a98a3ed6633ddd588c45cfa98dcaf84ef">propagate_adjoints</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;output)</td></tr>
<tr class="memdesc:a98a3ed6633ddd588c45cfa98dcaf84ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a scalar <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with size 1, (back)propagate the gradient to all dependent Funcs, buffers, and parameters.  <a href="namespace_halide.html#a98a3ed6633ddd588c45cfa98dcaf84ef">More...</a><br /></td></tr>
<tr class="separator:a98a3ed6633ddd588c45cfa98dcaf84ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7566eca1e318568c044f5b14d914842"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af7566eca1e318568c044f5b14d914842">get_device_interface_for_device_api</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> d, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>(), const char *error_site=nullptr)</td></tr>
<tr class="memdesc:af7566eca1e318568c044f5b14d914842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the appropriate <a class="el" href="structhalide__device__interface__t.html" title="Each GPU API provides a halide_device_interface_t struct pointing to the code that manages device all...">halide_device_interface_t</a> * for a DeviceAPI.  <a href="namespace_halide.html#af7566eca1e318568c044f5b14d914842">More...</a><br /></td></tr>
<tr class="separator:af7566eca1e318568c044f5b14d914842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a1df88c4f9bd924bd79a1120d14694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a58a1df88c4f9bd924bd79a1120d14694">get_default_device_api_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a58a1df88c4f9bd924bd79a1120d14694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specific DeviceAPI that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> would select when presented with <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a> for a given target.  <a href="namespace_halide.html#a58a1df88c4f9bd924bd79a1120d14694">More...</a><br /></td></tr>
<tr class="separator:a58a1df88c4f9bd924bd79a1120d14694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27245995e7e6ad0923dd764ad621b5aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a27245995e7e6ad0923dd764ad621b5aa">host_supports_target_device</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a27245995e7e6ad0923dd764ad621b5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This attempts to sniff whether a given <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> (and its implied DeviceAPI) is usable on the current host.  <a href="namespace_halide.html#a27245995e7e6ad0923dd764ad621b5aa">More...</a><br /></td></tr>
<tr class="separator:a27245995e7e6ad0923dd764ad621b5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b356550ce5d4c3f8ab941cf3b474cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5b356550ce5d4c3f8ab941cf3b474cb3">exceptions_enabled</a> ()</td></tr>
<tr class="memdesc:a5b356550ce5d4c3f8ab941cf3b474cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> was compiled with exceptions.  <a href="namespace_halide.html#a5b356550ce5d4c3f8ab941cf3b474cb3">More...</a><br /></td></tr>
<tr class="separator:a5b356550ce5d4c3f8ab941cf3b474cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b2e4833f813a4e306f3407f663c393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a64b2e4833f813a4e306f3407f663c393">set_custom_compile_time_error_reporter</a> (<a class="el" href="class_halide_1_1_compile_time_error_reporter.html">CompileTimeErrorReporter</a> *error_reporter)</td></tr>
<tr class="memdesc:a64b2e4833f813a4e306f3407f663c393"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default error reporter logs to stderr, then throws an exception (if HALIDE_WITH_EXCEPTIONS) or calls abort (if not).  <a href="namespace_halide.html#a64b2e4833f813a4e306f3407f663c393">More...</a><br /></td></tr>
<tr class="separator:a64b2e4833f813a4e306f3407f663c393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49ee5776e58865649c8268328508d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae49ee5776e58865649c8268328508d2a">fast_integer_divide</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> numerator, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> denominator)</td></tr>
<tr class="memdesc:ae49ee5776e58865649c8268328508d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer division by small values can be done exactly as multiplies and shifts.  <a href="namespace_halide.html#ae49ee5776e58865649c8268328508d2a">More...</a><br /></td></tr>
<tr class="separator:ae49ee5776e58865649c8268328508d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84586a3960712309cd2939a54bbac587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a84586a3960712309cd2939a54bbac587">fast_integer_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> numerator, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> denominator)</td></tr>
<tr class="memdesc:a84586a3960712309cd2939a54bbac587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the fast integer division tables to implement a modulo operation via the Euclidean identity: ab = a - (a/b)*b.  <a href="namespace_halide.html#a84586a3960712309cd2939a54bbac587">More...</a><br /></td></tr>
<tr class="separator:a84586a3960712309cd2939a54bbac587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842daf6fbd0f87ec9ea8336cb0cdd23e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a> (const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;a, const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;b)</td></tr>
<tr class="memdesc:a842daf6fbd0f87ec9ea8336cb0cdd23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit overloads of min and max for <a class="el" href="class_halide_1_1_func_ref.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Vars or Exprs.">FuncRef</a>.  <a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">More...</a><br /></td></tr>
<tr class="separator:a842daf6fbd0f87ec9ea8336cb0cdd23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2c7f5fe6c79a49dcbb28951cf8405d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a> (const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;a, const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;b)</td></tr>
<tr class="separator:aea2c7f5fe6c79a49dcbb28951cf8405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f3541db2d08c4e3f18df546b8796ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34f3541db2d08c4e3f18df546b8796ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a34f3541db2d08c4e3f18df546b8796ff">evaluate</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a34f3541db2d08c4e3f18df546b8796ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expression.  <a href="namespace_halide.html#a34f3541db2d08c4e3f18df546b8796ff">More...</a><br /></td></tr>
<tr class="separator:a34f3541db2d08c4e3f18df546b8796ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36a37228e934e5d99e0800ccc0a94a7"><td class="memTemplParams" colspan="2">template&lt;typename First , typename... Rest&gt; </td></tr>
<tr class="memitem:ab36a37228e934e5d99e0800ccc0a94a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab36a37228e934e5d99e0800ccc0a94a7">evaluate</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, First first, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:ab36a37228e934e5d99e0800ccc0a94a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>.  <a href="namespace_halide.html#ab36a37228e934e5d99e0800ccc0a94a7">More...</a><br /></td></tr>
<tr class="separator:ab36a37228e934e5d99e0800ccc0a94a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece4281929aec52e480d8021c43b020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ece4281929aec52e480d8021c43b020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3ece4281929aec52e480d8021c43b020">evaluate_may_gpu</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a3ece4281929aec52e480d8021c43b020"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expression.  <a href="namespace_halide.html#a3ece4281929aec52e480d8021c43b020">More...</a><br /></td></tr>
<tr class="separator:a3ece4281929aec52e480d8021c43b020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ad1afdbe47ccd8e21b6576900e82e"><td class="memTemplParams" colspan="2">template&lt;typename First , typename... Rest&gt; </td></tr>
<tr class="memitem:a1d1ad1afdbe47ccd8e21b6576900e82e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1d1ad1afdbe47ccd8e21b6576900e82e">evaluate_may_gpu</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, First first, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a1d1ad1afdbe47ccd8e21b6576900e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>.  <a href="namespace_halide.html#a1d1ad1afdbe47ccd8e21b6576900e82e">More...</a><br /></td></tr>
<tr class="separator:a1d1ad1afdbe47ccd8e21b6576900e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">operator+</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a+(T) b)</td></tr>
<tr class="memdesc:a7ffe416c9264a301f4dbee5088cd4212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between GeneratorParam&lt;T&gt; and any type that supports operator+ with T.  <a href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">More...</a><br /></td></tr>
<tr class="separator:a7ffe416c9264a301f4dbee5088cd4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad0b04406900c92aff4fe7df31bf35d6c">operator+</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a+b)</td></tr>
<tr class="separator:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">operator-</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a -(T) b)</td></tr>
<tr class="memdesc:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between GeneratorParam&lt;T&gt; and any type that supports operator- with T.  <a href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">More...</a><br /></td></tr>
<tr class="separator:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad63c3bccbde6ba2a4986f11bf662bf7e">operator-</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a - b)</td></tr>
<tr class="separator:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">operator*</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a *(T) b)</td></tr>
<tr class="memdesc:a24aabc3f5a598cb3c662e05b01243ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between GeneratorParam&lt;T&gt; and any type that supports operator* with T.  <a href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">More...</a><br /></td></tr>
<tr class="separator:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a17ffddd99ce9d53114517a17496e45b1">operator*</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a *b)</td></tr>
<tr class="separator:a17ffddd99ce9d53114517a17496e45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">operator/</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a/(T) b)</td></tr>
<tr class="memdesc:addcc05645a8be0bf5b547891b5eedbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between GeneratorParam&lt;T&gt; and any type that supports operator/ with T.  <a href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">More...</a><br /></td></tr>
<tr class="separator:addcc05645a8be0bf5b547891b5eedbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aedb1bbedd0274448f1b81fe8de753287">operator/</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a/b)</td></tr>
<tr class="separator:aedb1bbedd0274448f1b81fe8de753287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">operator%</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a %(T) b)</td></tr>
<tr class="memdesc:a993b255e504fe0b7812c60db527c997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo between GeneratorParam&lt;T&gt; and any type that supports operator% with T.  <a href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">More...</a><br /></td></tr>
<tr class="separator:a993b255e504fe0b7812c60db527c997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e0eb4d1f94756aa0776e126762c4a5c">operator%</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a % b)</td></tr>
<tr class="separator:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">operator&gt;</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a &gt;(T) b)</td></tr>
<tr class="memdesc:ab7126caa58fad82bb502a72f7ba72dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt; with T.  <a href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">More...</a><br /></td></tr>
<tr class="separator:ab7126caa58fad82bb502a72f7ba72dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a212d29d2096665d1ee6bdec6ac8cb5ad">operator&gt;</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt; b)</td></tr>
<tr class="separator:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">operator&lt;</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a&lt;(T) b)</td></tr>
<tr class="memdesc:a1f99adc84a7324351d6037eacb3f9157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt; with T.  <a href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">More...</a><br /></td></tr>
<tr class="separator:a1f99adc84a7324351d6037eacb3f9157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab6493da795ebe5c52ce922583d7aed4">operator&lt;</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt; b)</td></tr>
<tr class="separator:aab6493da795ebe5c52ce922583d7aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">operator&gt;=</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a &gt;=(T) b)</td></tr>
<tr class="memdesc:a016a50dc9625193a554ec0d51fb8d953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt;= with T.  <a href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">More...</a><br /></td></tr>
<tr class="separator:a016a50dc9625193a554ec0d51fb8d953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4598327ce18c80e8b2f89edde2554e02">operator&gt;=</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt;=b)</td></tr>
<tr class="separator:a4598327ce18c80e8b2f89edde2554e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">operator&lt;=</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a&lt;=(T) b)</td></tr>
<tr class="memdesc:aa4053db56eee7933acebf91f83803cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt;= with T.  <a href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">More...</a><br /></td></tr>
<tr class="separator:aa4053db56eee7933acebf91f83803cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a730bcf31dedcc336b12929d2afe35ea2">operator&lt;=</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt;=b)</td></tr>
<tr class="separator:a730bcf31dedcc336b12929d2afe35ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">operator==</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a==(T) b)</td></tr>
<tr class="memdesc:a12fecab5f39831c5d8444fbf700c0e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between GeneratorParam&lt;T&gt; and any type that supports operator== with T.  <a href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">More...</a><br /></td></tr>
<tr class="separator:a12fecab5f39831c5d8444fbf700c0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac9aa81c242a4d52174dfe07e28dd856f">operator==</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a==b)</td></tr>
<tr class="separator:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">operator!=</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a !=(T) b)</td></tr>
<tr class="memdesc:abe8ddebe6a310029aaf2096c17750a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between between GeneratorParam&lt;T&gt; and any type that supports operator!= with T.  <a href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">More...</a><br /></td></tr>
<tr class="separator:abe8ddebe6a310029aaf2096c17750a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af53392f7139bea898ab547a1aa14f8cb">operator!=</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a !=b)</td></tr>
<tr class="separator:af53392f7139bea898ab547a1aa14f8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">operator&amp;&amp;</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a &amp;&amp;(T) b)</td></tr>
<tr class="memdesc:a8e8cc876748afd9ec969b7d0d45d1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and between between GeneratorParam&lt;T&gt; and any type that supports operator&amp;&amp; with T.  <a href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">More...</a><br /></td></tr>
<tr class="separator:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a228ada08fcdf1652525a98f2f0f0df44">operator&amp;&amp;</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &amp;&amp;b)</td></tr>
<tr class="separator:a228ada08fcdf1652525a98f2f0f0df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac3fe93546b3f630e218bae59afba254f">operator&amp;&amp;</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype((T) a &amp;&amp;(T) b)</td></tr>
<tr class="separator:ac3fe93546b3f630e218bae59afba254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">operator||</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(a||(T) b)</td></tr>
<tr class="memdesc:a2ab1d71b2448732fda75553fc7f23c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or between between GeneratorParam&lt;T&gt; and any type that supports operator|| with T.  <a href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">More...</a><br /></td></tr>
<tr class="separator:a2ab1d71b2448732fda75553fc7f23c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af4786dcd28f875b5886c08221ceade3b">operator||</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a||b)</td></tr>
<tr class="separator:af4786dcd28f875b5886c08221ceade3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adf2ad1425d57e892ab6f16d66af3b882">operator||</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype((T) a||(T) b)</td></tr>
<tr class="separator:adf2ad1425d57e892ab6f16d66af3b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">min</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Internal::GeneratorMinMax::min_forward</a>(a, b))</td></tr>
<tr class="memdesc:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum between GeneratorParam&lt;T&gt; and any type that supports min with T.  <a href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">More...</a><br /></td></tr>
<tr class="separator:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38f0112267498bcda0747506b9d82af8">min</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Internal::GeneratorMinMax::min_forward</a>(a, b))</td></tr>
<tr class="separator:a38f0112267498bcda0747506b9d82af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">max</a> (const Other &amp;a, const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Internal::GeneratorMinMax::max_forward</a>(a, b))</td></tr>
<tr class="memdesc:aa350166ccd23cc6430356bb6833d3910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum value between GeneratorParam&lt;T&gt; and any type that supports max with T.  <a href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">More...</a><br /></td></tr>
<tr class="separator:aa350166ccd23cc6430356bb6833d3910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb5a870f8517436e4720b50792f8fdd1">max</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Internal::GeneratorMinMax::max_forward</a>(a, b))</td></tr>
<tr class="separator:aeb5a870f8517436e4720b50792f8fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">operator!</a> (const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;a) -&gt; decltype(!(T) a)</td></tr>
<tr class="memdesc:a534f823d7f303e81b20bdff79e38179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not operator for <a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a>.  <a href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">More...</a><br /></td></tr>
<tr class="separator:a534f823d7f303e81b20bdff79e38179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa8982b04d0b5faf76de0fd4c0cc33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;sum&quot;)</td></tr>
<tr class="memdesc:a41aa8982b04d0b5faf76de0fd4c0cc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">More...</a><br /></td></tr>
<tr class="separator:a41aa8982b04d0b5faf76de0fd4c0cc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71599f1dae36c608e3236e06a7fdf9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a71599f1dae36c608e3236e06a7fdf9b5">product</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;product&quot;)</td></tr>
<tr class="separator:a71599f1dae36c608e3236e06a7fdf9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c3805a6d059a671810c6d004e8d1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a20c3805a6d059a671810c6d004e8d1bd">maximum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;maximum&quot;)</td></tr>
<tr class="separator:a20c3805a6d059a671810c6d004e8d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45b50a1d7838663e5cfaceff50d8b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab45b50a1d7838663e5cfaceff50d8b7">minimum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;minimum&quot;)</td></tr>
<tr class="separator:aab45b50a1d7838663e5cfaceff50d8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace593c64f8634a1c323db86ac4d80663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ace593c64f8634a1c323db86ac4d80663">sum</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;sum&quot;)</td></tr>
<tr class="memdesc:ace593c64f8634a1c323db86ac4d80663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> is stated explicitly.  <a href="namespace_halide.html#ace593c64f8634a1c323db86ac4d80663">More...</a><br /></td></tr>
<tr class="separator:ace593c64f8634a1c323db86ac4d80663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afead2dd46805437cceb61926b3abaeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afead2dd46805437cceb61926b3abaeb8">product</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;product&quot;)</td></tr>
<tr class="separator:afead2dd46805437cceb61926b3abaeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8431916e36bd66ced9083f9052e7972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa8431916e36bd66ced9083f9052e7972">maximum</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;maximum&quot;)</td></tr>
<tr class="separator:aa8431916e36bd66ced9083f9052e7972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a44140d5b2aad1fa4d308d70c081f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5a44140d5b2aad1fa4d308d70c081f19">minimum</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;minimum&quot;)</td></tr>
<tr class="separator:a5a44140d5b2aad1fa4d308d70c081f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0312becda0f0debcb8bfc6d8413105c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0312becda0f0debcb8bfc6d8413105c6">argmax</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmax&quot;)</td></tr>
<tr class="memdesc:a0312becda0f0debcb8bfc6d8413105c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> which minimizes or maximizes the expression.  <a href="namespace_halide.html#a0312becda0f0debcb8bfc6d8413105c6">More...</a><br /></td></tr>
<tr class="separator:a0312becda0f0debcb8bfc6d8413105c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f171f43c7cce3a17b60ac9127c63b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1f171f43c7cce3a17b60ac9127c63b12">argmin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmin&quot;)</td></tr>
<tr class="separator:a1f171f43c7cce3a17b60ac9127c63b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516a301c43e36cd6226124423ecd5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac516a301c43e36cd6226124423ecd5ba">argmax</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmax&quot;)</td></tr>
<tr class="separator:ac516a301c43e36cd6226124423ecd5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f1499e2f36600d4cf308c8c4a0793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af61f1499e2f36600d4cf308c8c4a0793">argmin</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmin&quot;)</td></tr>
<tr class="separator:af61f1499e2f36600d4cf308c8c4a0793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">cast</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">More...</a><br /></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br /></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">operator+</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br /></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d7f25e89e1f74d7d76e370161f7358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">operator+</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a28d7f25e89e1f74d7d76e370161f7358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">More...</a><br /></td></tr>
<tr class="separator:a28d7f25e89e1f74d7d76e370161f7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95625f031290fffefab2365275c4981f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a95625f031290fffefab2365275c4981f">operator+</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a95625f031290fffefab2365275c4981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant integer and an expression.  <a href="namespace_halide.html#a95625f031290fffefab2365275c4981f">More...</a><br /></td></tr>
<tr class="separator:a95625f031290fffefab2365275c4981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">operator+=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">More...</a><br /></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">More...</a><br /></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant integer from an expression.  <a href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">More...</a><br /></td></tr>
<tr class="separator:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">operator-</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a929a86c18d4952daa3d1bad7b2b448fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts an expression from a constant integer.  <a href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">More...</a><br /></td></tr>
<tr class="separator:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">More...</a><br /></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">operator-=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br /></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">operator*</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">More...</a><br /></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add192217868f9861b756a85d212c0ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#add192217868f9861b756a85d212c0ecd">operator*</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:add192217868f9861b756a85d212c0ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an expression and a constant integer.  <a href="namespace_halide.html#add192217868f9861b756a85d212c0ecd">More...</a><br /></td></tr>
<tr class="separator:add192217868f9861b756a85d212c0ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93ddfca97d22f96789eea9b8c5d355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">operator*</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abe93ddfca97d22f96789eea9b8c5d355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a constant integer and an expression.  <a href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">More...</a><br /></td></tr>
<tr class="separator:abe93ddfca97d22f96789eea9b8c5d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">operator*=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br /></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">operator/</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br /></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">operator/=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">More...</a><br /></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">operator/</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an expression by a constant integer.  <a href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">More...</a><br /></td></tr>
<tr class="separator:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351f5d64c664ba9d65178161e1937db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">operator/</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8351f5d64c664ba9d65178161e1937db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a constant integer by an expression.  <a href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">More...</a><br /></td></tr>
<tr class="separator:a8351f5d64c664ba9d65178161e1937db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">operator%</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br /></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">operator%</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods an expression by a constant integer.  <a href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">More...</a><br /></td></tr>
<tr class="separator:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2825498112ddec5da6caa3deaf435e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb2825498112ddec5da6caa3deaf435e">operator%</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:acb2825498112ddec5da6caa3deaf435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods a constant integer by an expression.  <a href="namespace_halide.html#acb2825498112ddec5da6caa3deaf435e">More...</a><br /></td></tr>
<tr class="separator:acb2825498112ddec5da6caa3deaf435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">operator&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">More...</a><br /></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014703a60d365b71dee6def5cb7a6f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">operator&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a014703a60d365b71dee6def5cb7a6f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than a constant integer.  <a href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">More...</a><br /></td></tr>
<tr class="separator:a014703a60d365b71dee6def5cb7a6f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af05e2a8405c578614399da8ffba005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">operator&gt;</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a4af05e2a8405c578614399da8ffba005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than an expression.  <a href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">More...</a><br /></td></tr>
<tr class="separator:a4af05e2a8405c578614399da8ffba005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">operator&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">More...</a><br /></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b253d012615166e933d5b39d0bc83fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">operator&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a8b253d012615166e933d5b39d0bc83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than a constant integer.  <a href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">More...</a><br /></td></tr>
<tr class="separator:a8b253d012615166e933d5b39d0bc83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee20253bf83a4cdd89537cc6e8161524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">operator&lt;</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:aee20253bf83a4cdd89537cc6e8161524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than an expression.  <a href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">More...</a><br /></td></tr>
<tr class="separator:aee20253bf83a4cdd89537cc6e8161524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">operator&lt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br /></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">operator&lt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a0616c33325d7b8ee67a4e2e305f5f375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than or equal to a constant integer.  <a href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">More...</a><br /></td></tr>
<tr class="separator:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b263f999854f1e7e1ee8602998bb016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">operator&lt;=</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a6b263f999854f1e7e1ee8602998bb016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than or equal to an expression.  <a href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">More...</a><br /></td></tr>
<tr class="separator:a6b263f999854f1e7e1ee8602998bb016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">operator&gt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br /></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc55d0783c46ace37a0b413d82dd100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9fc55d0783c46ace37a0b413d82dd100">operator&gt;=</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, int b)</td></tr>
<tr class="memdesc:a9fc55d0783c46ace37a0b413d82dd100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than or equal to a constant integer.  <a href="namespace_halide.html#a9fc55d0783c46ace37a0b413d82dd100">More...</a><br /></td></tr>
<tr class="separator:a9fc55d0783c46ace37a0b413d82dd100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a977de0ab82ad7e0ac7d4c6321554d6c9">operator&gt;=</a> (int a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than or equal to an expression.  <a href="namespace_halide.html#a977de0ab82ad7e0ac7d4c6321554d6c9">More...</a><br /></td></tr>
<tr class="separator:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">operator==</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br /></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">operator==</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is equal to a constant integer.  <a href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">More...</a><br /></td></tr>
<tr class="separator:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115d4df85c9d3b9e9221f0c62c765858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">operator==</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a115d4df85c9d3b9e9221f0c62c765858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is equal to an expression.  <a href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">More...</a><br /></td></tr>
<tr class="separator:a115d4df85c9d3b9e9221f0c62c765858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">operator!=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">More...</a><br /></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">operator!=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is not equal to a constant integer.  <a href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">More...</a><br /></td></tr>
<tr class="separator:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c1c720efb61b649e495eac92c0c6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">operator!=</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a82c1c720efb61b649e495eac92c0c6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is not equal to an expression.  <a href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">More...</a><br /></td></tr>
<tr class="separator:a82c1c720efb61b649e495eac92c0c6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">operator&amp;&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br /></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c979cf5df557f554752e177655026f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab6c979cf5df557f554752e177655026f">operator&amp;&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, bool b)</td></tr>
<tr class="memdesc:ab6c979cf5df557f554752e177655026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool.  <a href="namespace_halide.html#ab6c979cf5df557f554752e177655026f">More...</a><br /></td></tr>
<tr class="separator:ab6c979cf5df557f554752e177655026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eda141b66c0d5bdc3b3faebc229b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a01eda141b66c0d5bdc3b3faebc229b44">operator&amp;&amp;</a> (bool a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a01eda141b66c0d5bdc3b3faebc229b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">operator||</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="namespace_halide.html#a3528931d7929d533103ada2badca092c">More...</a><br /></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38218eafbf9de824d559a4ff593a5617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38218eafbf9de824d559a4ff593a5617">operator||</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, bool b)</td></tr>
<tr class="memdesc:a38218eafbf9de824d559a4ff593a5617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool.  <a href="namespace_halide.html#a38218eafbf9de824d559a4ff593a5617">More...</a><br /></td></tr>
<tr class="separator:a38218eafbf9de824d559a4ff593a5617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131cefcee0f570a9bbf98121326f7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3131cefcee0f570a9bbf98121326f7d8">operator||</a> (bool a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a3131cefcee0f570a9bbf98121326f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">operator!</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">More...</a><br /></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">max</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br /></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d007e9eff86b8854b12840303294b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">max</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:a65d007e9eff86b8854b12840303294b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expression and a constant integer.  <a href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">More...</a><br /></td></tr>
<tr class="separator:a65d007e9eff86b8854b12840303294b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950ad100fb78022bf9c49003d6ccc19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">max</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a7950ad100fb78022bf9c49003d6ccc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of a constant integer and an expression.  <a href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">More...</a><br /></td></tr>
<tr class="separator:a7950ad100fb78022bf9c49003d6ccc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30475861d1493c3353e62ec77a3b516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad30475861d1493c3353e62ec77a3b516">max</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:ad30475861d1493c3353e62ec77a3b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba49d8dff61c221859c462054375258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ba49d8dff61c221859c462054375258">max</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a7ba49d8dff61c221859c462054375258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ff27a6f9948cb752117cf7064449f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1ff27a6f9948cb752117cf7064449f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b1ff27a6f9948cb752117cf7064449f">max</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a6b1ff27a6f9948cb752117cf7064449f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a6b1ff27a6f9948cb752117cf7064449f">More...</a><br /></td></tr>
<tr class="separator:a6b1ff27a6f9948cb752117cf7064449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade891378c7247910129a61258cf00a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ade891378c7247910129a61258cf00a56">min</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:ade891378c7247910129a61258cf00a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expression and a constant integer.  <a href="namespace_halide.html#ade891378c7247910129a61258cf00a56">More...</a><br /></td></tr>
<tr class="separator:ade891378c7247910129a61258cf00a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">min</a> (int a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of a constant integer and an expression.  <a href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">More...</a><br /></td></tr>
<tr class="separator:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f42d034894ac2f27a09f73627437a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a79f42d034894ac2f27a09f73627437a0">min</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a79f42d034894ac2f27a09f73627437a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68e4e576c9e0ca6588c3e5bc54856589">min</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa8132b0bbea7c1a5146765a22d981e5c">min</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:aa8132b0bbea7c1a5146765a22d981e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#aa8132b0bbea7c1a5146765a22d981e5c">More...</a><br /></td></tr>
<tr class="separator:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">operator+</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="memdesc:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">More...</a><br /></td></tr>
<tr class="separator:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b7b04f00436d90aad52a74a230181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a704b7b04f00436d90aad52a74a230181">operator+</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a704b7b04f00436d90aad52a74a230181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb362e84f0a152acd46b3ab42da29b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aacb362e84f0a152acd46b3ab42da29b9">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:aacb362e84f0a152acd46b3ab42da29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d01cda7bea93467113a5d32b00467a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47d01cda7bea93467113a5d32b00467a">operator-</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a47d01cda7bea93467113a5d32b00467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ccd78b6034d015358838478f4147b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a585ccd78b6034d015358838478f4147b">operator*</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a585ccd78b6034d015358838478f4147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a96077a9c1ec602e9196f7fe0a6dec2bf">operator*</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a77dce878e2e6156e9e9ec00f240c3de3">operator/</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c179840fe2018ea7106e3c7305516b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2c179840fe2018ea7106e3c7305516b6">operator/</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a2c179840fe2018ea7106e3c7305516b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ffb094c58badc44f353a94681dbfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a7ffb094c58badc44f353a94681dbfe">operator%</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a9a7ffb094c58badc44f353a94681dbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced81e366b73b3c1503905f0c594c516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aced81e366b73b3c1503905f0c594c516">operator%</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:aced81e366b73b3c1503905f0c594c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fb3edae8f6879c195ad373c0d7a7b86">operator&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe14360d4dab7d8119572f3aefdbbb25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe14360d4dab7d8119572f3aefdbbb25">operator&gt;</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:abe14360d4dab7d8119572f3aefdbbb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5730454f894a93bebbaf72dbc714e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4e5730454f894a93bebbaf72dbc714e1">operator&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a4e5730454f894a93bebbaf72dbc714e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47dd5b9660e5510cc23bbf8fa8e5f4b7">operator&lt;</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070410b979a0b62fdb67d6f13fbdc1d4">operator&gt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2e1d96814511a965a43e835947966e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4d2e1d96814511a965a43e835947966e">operator&gt;=</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a4d2e1d96814511a965a43e835947966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944b1232804900cdde74619fbfeda68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab944b1232804900cdde74619fbfeda68">operator&lt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:ab944b1232804900cdde74619fbfeda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5fc2ce1a66bdb1877f337436295cfc90">operator&lt;=</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ebe338276d9e91223e9f7f57eaa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a506ebe338276d9e91223e9f7f57eaa46">operator==</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:a506ebe338276d9e91223e9f7f57eaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae54bb0b329c0bb93eb19a2dc3a4e2285">operator==</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32c2846c632946f95a2ea9f60da704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abf32c2846c632946f95a2ea9f60da704">operator!=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, float b)</td></tr>
<tr class="separator:abf32c2846c632946f95a2ea9f60da704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af60a387c587e80408e8fa8b63bfb7cdb">operator!=</a> (float a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="separator:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b1c066344e4816e822a467522bb1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">clamp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;min_val, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;max_val)</td></tr>
<tr class="memdesc:a40b1c066344e4816e822a467522bb1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">More...</a><br /></td></tr>
<tr class="separator:a40b1c066344e4816e822a467522bb1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">abs</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br /></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">absd</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br /></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> true_value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br /></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Args... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac19df75a6ad3b8a7e7a2acaa84c5c9eb">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="namespace_halide.html#ac19df75a6ad3b8a7e7a2acaa84c5c9eb">More...</a><br /></td></tr>
<tr class="separator:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">tuple_select</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;condition, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;true_value, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;false_value)</td></tr>
<tr class="memdesc:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of ternary <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples.  <a href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">More...</a><br /></td></tr>
<tr class="separator:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace388be6ec6a0d3e2ad02993aba8cc41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ace388be6ec6a0d3e2ad02993aba8cc41">tuple_select</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;condition, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;true_value, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;false_value)</td></tr>
<tr class="separator:ace388be6ec6a0d3e2ad02993aba8cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae2fe5d43378f4d24f33980dbf2a8094f">tuple_select</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;c0, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;v0, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;c1, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;v1, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of multiway <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples.  <a href="namespace_halide.html#ae2fe5d43378f4d24f33980dbf2a8094f">More...</a><br /></td></tr>
<tr class="separator:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134581388acb9d7ef198a759d733e2a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4134581388acb9d7ef198a759d733e2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4134581388acb9d7ef198a759d733e2a">tuple_select</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c0, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;v0, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c1, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;v1, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a4134581388acb9d7ef198a759d733e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872ea25baf89339321f85340ed48c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">mux</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;id, const std::initializer_list&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a6872ea25baf89339321f85340ed48c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oftentimes we want to pack a list of expressions with the same type into a channel dimension, e.g., img(x, y, c) = select(c == 0, 100, // Red c == 1, 50, // Green 25); // Blue This is tedious when the list is long.  <a href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">More...</a><br /></td></tr>
<tr class="separator:a6872ea25baf89339321f85340ed48c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448d91aca15f1e6a5610fbc8cc0b15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1448d91aca15f1e6a5610fbc8cc0b15b">mux</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;id, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="separator:a1448d91aca15f1e6a5610fbc8cc0b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1093d3bc68908f364e9bddf5803286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4b1093d3bc68908f364e9bddf5803286">mux</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;id, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;values)</td></tr>
<tr class="separator:a4b1093d3bc68908f364e9bddf5803286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">More...</a><br /></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">asin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br /></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">cos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br /></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">acos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">More...</a><br /></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">tan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br /></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">atan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br /></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">atan2</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br /></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">sinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">More...</a><br /></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">asinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br /></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">cosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">More...</a><br /></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">acosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br /></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">tanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">More...</a><br /></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">atanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br /></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">More...</a><br /></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410c523b5f2f78733ca45d946a9ededb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a410c523b5f2f78733ca45d946a9ededb">hypot</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y)</td></tr>
<tr class="memdesc:a410c523b5f2f78733ca45d946a9ededb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="namespace_halide.html#a410c523b5f2f78733ca45d946a9ededb">More...</a><br /></td></tr>
<tr class="separator:a410c523b5f2f78733ca45d946a9ededb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">More...</a><br /></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">More...</a><br /></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">pow</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br /></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afcc3e2a1e80bd2b512b38aa87aa91f9e">erf</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="namespace_halide.html#afcc3e2a1e80bd2b512b38aa87aa91f9e">More...</a><br /></td></tr>
<tr class="separator:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f774e4779466acb57a6e571cb636ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f774e4779466acb57a6e571cb636ba6">fast_sin</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a8f774e4779466acb57a6e571cb636ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast vectorizable approximation to some trigonometric functions for Float(32).  <a href="namespace_halide.html#a8f774e4779466acb57a6e571cb636ba6">More...</a><br /></td></tr>
<tr class="separator:a8f774e4779466acb57a6e571cb636ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137dfeea487e7444f0b20c14b545c0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a137dfeea487e7444f0b20c14b545c0dd">fast_cos</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:a137dfeea487e7444f0b20c14b545c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0c7bd26b46c10f2c3a6fc36da6a89518">fast_log</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="namespace_halide.html#a0c7bd26b46c10f2c3a6fc36da6a89518">More...</a><br /></td></tr>
<tr class="separator:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744536415e304e37370fa6e216300354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a744536415e304e37370fa6e216300354">fast_exp</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a744536415e304e37370fa6e216300354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="namespace_halide.html#a744536415e304e37370fa6e216300354">More...</a><br /></td></tr>
<tr class="separator:a744536415e304e37370fa6e216300354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">fast_pow</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">More...</a><br /></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343eac4b4aa329e52c7cbf8167902696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">fast_inverse</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a343eac4b4aa329e52c7cbf8167902696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">More...</a><br /></td></tr>
<tr class="separator:a343eac4b4aa329e52c7cbf8167902696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4424b070b363f53107a6c2705bbe50b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">fast_inverse_sqrt</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ad4424b070b363f53107a6c2705bbe50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">More...</a><br /></td></tr>
<tr class="separator:ad4424b070b363f53107a6c2705bbe50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">floor</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">More...</a><br /></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">ceil</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">More...</a><br /></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">round</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">More...</a><br /></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f93889910a28197d2a1631486a433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a287f93889910a28197d2a1631486a433">trunc</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a287f93889910a28197d2a1631486a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="namespace_halide.html#a287f93889910a28197d2a1631486a433">More...</a><br /></td></tr>
<tr class="separator:a287f93889910a28197d2a1631486a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c5b6b09e0f679724ccfb95515b338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">is_nan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ab71c5b6b09e0f679724ccfb95515b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">More...</a><br /></td></tr>
<tr class="separator:ab71c5b6b09e0f679724ccfb95515b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac519f67137d32cdf11dd43101d626349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac519f67137d32cdf11dd43101d626349">is_inf</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ac519f67137d32cdf11dd43101d626349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is Inf or -Inf.  <a href="namespace_halide.html#ac519f67137d32cdf11dd43101d626349">More...</a><br /></td></tr>
<tr class="separator:ac519f67137d32cdf11dd43101d626349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f45a449357e2b40f7008e5630fb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac70f45a449357e2b40f7008e5630fb63">is_finite</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ac70f45a449357e2b40f7008e5630fb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a finite value (ie, neither NaN nor Inf).  <a href="namespace_halide.html#ac70f45a449357e2b40f7008e5630fb63">More...</a><br /></td></tr>
<tr class="separator:ac70f45a449357e2b40f7008e5630fb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a18e72ac620ae5d7944f8b15244ec5e32">fract</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a18e72ac620ae5d7944f8b15244ec5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="namespace_halide.html#a18e72ac620ae5d7944f8b15244ec5e32">More...</a><br /></td></tr>
<tr class="separator:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">reinterpret</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">More...</a><br /></td></tr>
<tr class="separator:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2012c20f1666555e7a229c9db1b64091">reinterpret</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:a2012c20f1666555e7a229c9db1b64091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8e49b0b42230077ee6bdca669d299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">operator&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4ec8e49b0b42230077ee6bdca669d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">More...</a><br /></td></tr>
<tr class="separator:a4ec8e49b0b42230077ee6bdca669d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88242b4128c62353a9be9cec97ce7517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a88242b4128c62353a9be9cec97ce7517">operator&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, int y)</td></tr>
<tr class="memdesc:a88242b4128c62353a9be9cec97ce7517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of an expression and an integer.  <a href="namespace_halide.html#a88242b4128c62353a9be9cec97ce7517">More...</a><br /></td></tr>
<tr class="separator:a88242b4128c62353a9be9cec97ce7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e5d84cbffa329f76a5a43aac5d3dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a839e5d84cbffa329f76a5a43aac5d3dd">operator&amp;</a> (int x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="separator:a839e5d84cbffa329f76a5a43aac5d3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">operator|</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br /></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b42f239b51e5665705b31eeb353e64d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7b42f239b51e5665705b31eeb353e64d">operator|</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, int y)</td></tr>
<tr class="memdesc:a7b42f239b51e5665705b31eeb353e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of an expression and an integer.  <a href="namespace_halide.html#a7b42f239b51e5665705b31eeb353e64d">More...</a><br /></td></tr>
<tr class="separator:a7b42f239b51e5665705b31eeb353e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585fea347a8ec3bd113b466f6a8f5c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a585fea347a8ec3bd113b466f6a8f5c93">operator|</a> (int x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="separator:a585fea347a8ec3bd113b466f6a8f5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">operator^</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise xor of two expressions (which need not have the same type).  <a href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">More...</a><br /></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879829a780e257db389ba9ad59689f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a879829a780e257db389ba9ad59689f94">operator^</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, int y)</td></tr>
<tr class="memdesc:a879829a780e257db389ba9ad59689f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise xor of an expression and an integer.  <a href="namespace_halide.html#a879829a780e257db389ba9ad59689f94">More...</a><br /></td></tr>
<tr class="separator:a879829a780e257db389ba9ad59689f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367813f3f387e6e43565767a92d9829a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a367813f3f387e6e43565767a92d9829a">operator^</a> (int x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="separator:a367813f3f387e6e43565767a92d9829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c07e39289b14103ccd45ee31630a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">operator~</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:afc9c07e39289b14103ccd45ee31630a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">More...</a><br /></td></tr>
<tr class="separator:afc9c07e39289b14103ccd45ee31630a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">operator&lt;&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">More...</a><br /></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9bce43f9178ddb2fda8f1ef8c5755384">operator&lt;&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, int y)</td></tr>
<tr class="separator:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">operator&gt;&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br /></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7223753c831bcb54d39bbdf40733d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab8e7223753c831bcb54d39bbdf40733d">operator&gt;&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, int y)</td></tr>
<tr class="separator:ab8e7223753c831bcb54d39bbdf40733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="namespace_halide.html#a55158f5f229510194c425dfae256d530">More...</a><br /></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd5e65a4c167c112de447c628c099a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">popcount</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a41dd5e65a4c167c112de447c628c099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">More...</a><br /></td></tr>
<tr class="separator:a41dd5e65a4c167c112de447c628c099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39642cc99af99045ec5f424cde8709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">count_leading_zeros</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a0e39642cc99af99045ec5f424cde8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">More...</a><br /></td></tr>
<tr class="separator:a0e39642cc99af99045ec5f424cde8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">count_trailing_zeros</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:aa0042ff9c2283a15cda1a1e72de460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">More...</a><br /></td></tr>
<tr class="separator:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e12242ab5a192bdaa953510ae95bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">div_round_to_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:aed6e12242ab5a192bdaa953510ae95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two integers, rounding towards zero.  <a href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">More...</a><br /></td></tr>
<tr class="separator:aed6e12242ab5a192bdaa953510ae95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">mod_round_to_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:ab0456fd6414e279eb3afdecf53eb8af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the remainder of dividing two integers, when division is rounding toward zero.  <a href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">More...</a><br /></td></tr>
<tr class="separator:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd57263c72c6712b643ab6486ed026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> seed=<a class="el" href="struct_halide_1_1_expr.html">Expr</a>())</td></tr>
<tr class="memdesc:a59bd57263c72c6712b643ab6486ed026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">More...</a><br /></td></tr>
<tr class="separator:a59bd57263c72c6712b643ab6486ed026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160cd421537be8b4cd44fc32958604c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">random_uint</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> seed=<a class="el" href="struct_halide_1_1_expr.html">Expr</a>())</td></tr>
<tr class="memdesc:a160cd421537be8b4cd44fc32958604c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed unsigned 32-bit integer.  <a href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">More...</a><br /></td></tr>
<tr class="separator:a160cd421537be8b4cd44fc32958604c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5b59d6a43446e311633912427b2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">random_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> seed=<a class="el" href="struct_halide_1_1_expr.html">Expr</a>())</td></tr>
<tr class="memdesc:aaed5b59d6a43446e311633912427b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">More...</a><br /></td></tr>
<tr class="separator:aaed5b59d6a43446e311633912427b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad933f903f12d02dc4a41950751feb8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">print</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ad933f903f12d02dc4a41950751feb8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints out its value whenever it is evaluated.  <a href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">More...</a><br /></td></tr>
<tr class="separator:ad933f903f12d02dc4a41950751feb8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb98ec9f8091af1beca6d93e9a95f23a">print</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, Args &amp;&amp;...args)</td></tr>
<tr class="separator:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452ed699c61260cc230629777fc9cafa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a452ed699c61260cc230629777fc9cafa">print_when</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a452ed699c61260cc230629777fc9cafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="namespace_halide.html#a452ed699c61260cc230629777fc9cafa">More...</a><br /></td></tr>
<tr class="separator:a452ed699c61260cc230629777fc9cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc63366304ec6c0d67fd89fc6d985f34"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abc63366304ec6c0d67fd89fc6d985f34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc63366304ec6c0d67fd89fc6d985f34">print_when</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, Args &amp;&amp;...args)</td></tr>
<tr class="separator:abc63366304ec6c0d67fd89fc6d985f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac350d72e774314bb32beeb718d53c09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">require</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ac350d72e774314bb32beeb718d53c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that guarantees a precondition.  <a href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">More...</a><br /></td></tr>
<tr class="separator:ac350d72e774314bb32beeb718d53c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0298ea2955b3ed763e7bfca9f5b805ea">require</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">undef</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">More...</a><br /></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0c61f9a3eb7d89644951cf835ade09fa">memoize_tag</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0c61f9a3eb7d89644951cf835ade09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="namespace_halide.html#a0c61f9a3eb7d89644951cf835ade09fa">More...</a><br /></td></tr>
<tr class="separator:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">likely</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">More...</a><br /></td></tr>
<tr class="separator:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">likely_if_innermost</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.  <a href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">More...</a><br /></td></tr>
<tr class="separator:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">saturating_cast</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a57a635db3b781aded60c79533001b9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">More...</a><br /></td></tr>
<tr class="separator:a57a635db3b781aded60c79533001b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe60c27f54efe535f84d7f94ce61c053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe60c27f54efe535f84d7f94ce61c053">saturating_cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:abe60c27f54efe535f84d7f94ce61c053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type, clamping to the minimum and maximum values of the result type.  <a href="namespace_halide.html#abe60c27f54efe535f84d7f94ce61c053">More...</a><br /></td></tr>
<tr class="separator:abe60c27f54efe535f84d7f94ce61c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ccca78986958e405d34f08f41a103a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab2ccca78986958e405d34f08f41a103a">strict_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ab2ccca78986958e405d34f08f41a103a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a best effort attempt to preserve IEEE floating-point semantics in evaluating an expression.  <a href="namespace_halide.html#ab2ccca78986958e405d34f08f41a103a">More...</a><br /></td></tr>
<tr class="separator:ab2ccca78986958e405d34f08f41a103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f11f05c5df67082747354f264d30f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17">unsafe_promise_clamped</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;value, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>)</td></tr>
<tr class="memdesc:a5f11f05c5df67082747354f264d30f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that promises another <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> is clamped but do not generate code to check the assertion or modify the value.  <a href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17">More...</a><br /></td></tr>
<tr class="separator:a5f11f05c5df67082747354f264d30f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0498c6cada8da13d05bf285a813d16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:aa0498c6cada8da13d05bf285a813d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter and gather are used for update definition which must store multiple values to distinct locations at the same time.  <a href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">More...</a><br /></td></tr>
<tr class="separator:aa0498c6cada8da13d05bf285a813d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435458ed41a7427361761df8b62fc047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a435458ed41a7427361761df8b62fc047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a035edd08e7ece3238ce2fa5ede9d8eb7">scatter</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e82c6354cdd3a95aa207291ca15522b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7e82c6354cdd3a95aa207291ca15522b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e82c6354cdd3a95aa207291ca15522b">gather</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a7e82c6354cdd3a95aa207291ca15522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6246c45e7f5c10b2c8182407d5ba17"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2a6246c45e7f5c10b2c8182407d5ba17">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> &amp;)</td></tr>
<tr class="memdesc:a2a6246c45e7f5c10b2c8182407d5ba17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide device api type in human-readable form.  <a href="namespace_halide.html#a2a6246c45e7f5c10b2c8182407d5ba17">More...</a><br /></td></tr>
<tr class="separator:a2a6246c45e7f5c10b2c8182407d5ba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6f8beae5821f95bbba90792d937970"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6f8beae5821f95bbba90792d937970">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> &amp;)</td></tr>
<tr class="memdesc:a9d6f8beae5821f95bbba90792d937970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide memory type in human-readable form.  <a href="namespace_halide.html#a9d6f8beae5821f95bbba90792d937970">More...</a><br /></td></tr>
<tr class="separator:a9d6f8beae5821f95bbba90792d937970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9776f81e1a9f3bb14ae9c75aec1f0965"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9776f81e1a9f3bb14ae9c75aec1f0965">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &amp;t)</td></tr>
<tr class="memdesc:a9776f81e1a9f3bb14ae9c75aec1f0965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide tail strategy in human-readable form.  <a href="namespace_halide.html#a9776f81e1a9f3bb14ae9c75aec1f0965">More...</a><br /></td></tr>
<tr class="separator:a9776f81e1a9f3bb14ae9c75aec1f0965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3765573080d05859d10c3ca8c83e18"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afa3765573080d05859d10c3ca8c83e18">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> &amp;)</td></tr>
<tr class="memdesc:afa3765573080d05859d10c3ca8c83e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a> in human-readable form.  <a href="namespace_halide.html#afa3765573080d05859d10c3ca8c83e18">More...</a><br /></td></tr>
<tr class="separator:afa3765573080d05859d10c3ca8c83e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad059dd67c80872feb005e9d52c3a15d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad059dd67c80872feb005e9d52c3a15d1">lambda</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:ad059dd67c80872feb005e9d52c3a15d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a zero-dimensional halide function that returns the given expression.  <a href="namespace_halide.html#ad059dd67c80872feb005e9d52c3a15d1">More...</a><br /></td></tr>
<tr class="separator:ad059dd67c80872feb005e9d52c3a15d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ef6cc86eb071f7805a56aca29b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6582ef6cc86eb071f7805a56aca29b03">lambda</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a6582ef6cc86eb071f7805a56aca29b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1-D halide function in the first argument that returns the second argument.  <a href="namespace_halide.html#a6582ef6cc86eb071f7805a56aca29b03">More...</a><br /></td></tr>
<tr class="separator:a6582ef6cc86eb071f7805a56aca29b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7585838cf49ace5557096df29377510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af7585838cf49ace5557096df29377510">lambda</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af7585838cf49ace5557096df29377510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2-D halide function in the first two arguments that returns the last argument.  <a href="namespace_halide.html#af7585838cf49ace5557096df29377510">More...</a><br /></td></tr>
<tr class="separator:af7585838cf49ace5557096df29377510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62749bb94be1fd67800ab967c000f3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a62749bb94be1fd67800ab967c000f3ad">lambda</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;z, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a62749bb94be1fd67800ab967c000f3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3-D halide function in the first three arguments that returns the last argument.  <a href="namespace_halide.html#a62749bb94be1fd67800ab967c000f3ad">More...</a><br /></td></tr>
<tr class="separator:a62749bb94be1fd67800ab967c000f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992c3a587f783919c6a0ac1dd9a132fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a992c3a587f783919c6a0ac1dd9a132fe">lambda</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;z, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;w, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a992c3a587f783919c6a0ac1dd9a132fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 4-D halide function in the first four arguments that returns the last argument.  <a href="namespace_halide.html#a992c3a587f783919c6a0ac1dd9a132fe">More...</a><br /></td></tr>
<tr class="separator:a992c3a587f783919c6a0ac1dd9a132fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca087d4cae6b284a1c40caecdd5361a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0ca087d4cae6b284a1c40caecdd5361a">lambda</a> (const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;x, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;y, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;z, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;w, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;v, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0ca087d4cae6b284a1c40caecdd5361a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 5-D halide function in the first five arguments that returns the last argument.  <a href="namespace_halide.html#a0ca087d4cae6b284a1c40caecdd5361a">More...</a><br /></td></tr>
<tr class="separator:a0ca087d4cae6b284a1c40caecdd5361a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ab8a65be814772d7be2b7a724fd125"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a50ab8a65be814772d7be2b7a724fd125">compile_module_to_llvm_module</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, llvm::LLVMContext &amp;context)</td></tr>
<tr class="memdesc:a50ab8a65be814772d7be2b7a724fd125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an LLVM module.  <a href="namespace_halide.html#a50ab8a65be814772d7be2b7a724fd125">More...</a><br /></td></tr>
<tr class="separator:a50ab8a65be814772d7be2b7a724fd125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e16a74bdfa8d1b76a27bd67398ec48"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::raw_fd_ostream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac6e16a74bdfa8d1b76a27bd67398ec48">make_raw_fd_ostream</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ac6e16a74bdfa8d1b76a27bd67398ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an llvm output stream for writing to files.  <a href="namespace_halide.html#ac6e16a74bdfa8d1b76a27bd67398ec48">More...</a><br /></td></tr>
<tr class="separator:ac6e16a74bdfa8d1b76a27bd67398ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4edc7d7f9c03823de1140f647541ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4edc7d7f9c03823de1140f647541ed8">compile_llvm_module_to_object</a> (llvm::Module &amp;module, <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;out)</td></tr>
<tr class="memdesc:aa4edc7d7f9c03823de1140f647541ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to native targets (objects, native assembly).  <a href="namespace_halide.html#aa4edc7d7f9c03823de1140f647541ed8">More...</a><br /></td></tr>
<tr class="separator:aa4edc7d7f9c03823de1140f647541ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9675efb52f754f47b531e86547dcc669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9675efb52f754f47b531e86547dcc669">compile_llvm_module_to_assembly</a> (llvm::Module &amp;module, <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;out)</td></tr>
<tr class="separator:a9675efb52f754f47b531e86547dcc669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab518840a992e5d9f7aa93a85d9d8054d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab518840a992e5d9f7aa93a85d9d8054d">compile_llvm_module_to_llvm_bitcode</a> (llvm::Module &amp;module, <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;out)</td></tr>
<tr class="memdesc:ab518840a992e5d9f7aa93a85d9d8054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to LLVM targets (bitcode, LLVM assembly).  <a href="namespace_halide.html#ab518840a992e5d9f7aa93a85d9d8054d">More...</a><br /></td></tr>
<tr class="separator:ab518840a992e5d9f7aa93a85d9d8054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b4c504c70bbdde213d0f787c721f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69b4c504c70bbdde213d0f787c721f20">compile_llvm_module_to_llvm_assembly</a> (llvm::Module &amp;module, <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;out)</td></tr>
<tr class="separator:a69b4c504c70bbdde213d0f787c721f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b55d90043852c79eb873c1dec3590b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a09b55d90043852c79eb873c1dec3590b">create_static_library</a> (const std::vector&lt; std::string &gt; &amp;src_files, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const std::string &amp;dst_file, bool deterministic=true)</td></tr>
<tr class="memdesc:a09b55d90043852c79eb873c1dec3590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the list of src_files into dst_file, using the appropriate static library format for the given target (e.g., .a or .lib).  <a href="namespace_halide.html#a09b55d90043852c79eb873c1dec3590b">More...</a><br /></td></tr>
<tr class="separator:a09b55d90043852c79eb873c1dec3590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f589a059692f84a1a3d1fe8056df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af69f589a059692f84a1a3d1fe8056df5">link_modules</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_module.html">Module</a> &gt; &amp;modules)</td></tr>
<tr class="memdesc:af69f589a059692f84a1a3d1fe8056df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a set of modules together into one module.  <a href="namespace_halide.html#af69f589a059692f84a1a3d1fe8056df5">More...</a><br /></td></tr>
<tr class="separator:af69f589a059692f84a1a3d1fe8056df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b41a54a453737dcdd34e6d1058353f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4b41a54a453737dcdd34e6d1058353f">compile_standalone_runtime</a> (const std::string &amp;object_filename, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:aa4b41a54a453737dcdd34e6d1058353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object file containing the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime for a given target.  <a href="namespace_halide.html#aa4b41a54a453737dcdd34e6d1058353f">More...</a><br /></td></tr>
<tr class="separator:aa4b41a54a453737dcdd34e6d1058353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04de7316843ac7c1a0a0126228caab32"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a04de7316843ac7c1a0a0126228caab32">compile_standalone_runtime</a> (const std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string &gt; &amp;output_files, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a04de7316843ac7c1a0a0126228caab32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object and/or static library file containing the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime for a given target.  <a href="namespace_halide.html#a04de7316843ac7c1a0a0126228caab32">More...</a><br /></td></tr>
<tr class="separator:a04de7316843ac7c1a0a0126228caab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c901cdbf0e9c7ffac2226b078a579ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7c901cdbf0e9c7ffac2226b078a579ae">compile_multitarget</a> (const std::string &amp;fn_name, const std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string &gt; &amp;output_files, const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;targets, const std::vector&lt; std::string &gt; &amp;suffixes, const <a class="el" href="namespace_halide.html#afe643966574f0ad69cad7f936c086740">ModuleFactory</a> &amp;module_factory, const <a class="el" href="namespace_halide.html#a6e2a7a400cd68d41f2868eebb762c32e">CompilerLoggerFactory</a> &amp;compiler_logger_factory=nullptr)</td></tr>
<tr class="separator:a7c901cdbf0e9c7ffac2226b078a579ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8877b8b863a6b16d6ff13e196ec457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ada8877b8b863a6b16d6ff13e196ec457">user_context_value</a> ()</td></tr>
<tr class="memdesc:ada8877b8b863a6b16d6ff13e196ec457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> corresponding to the user context passed to the function (if any).  <a href="namespace_halide.html#ada8877b8b863a6b16d6ff13e196ec457">More...</a><br /></td></tr>
<tr class="separator:ada8877b8b863a6b16d6ff13e196ec457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a59ae3e07905e1b92d87a1ec835b77f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4a59ae3e07905e1b92d87a1ec835b77f">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;)</td></tr>
<tr class="memdesc:a4a59ae3e07905e1b92d87a1ec835b77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in a human-readable form.  <a href="namespace_halide.html#a4a59ae3e07905e1b92d87a1ec835b77f">More...</a><br /></td></tr>
<tr class="separator:a4a59ae3e07905e1b92d87a1ec835b77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190e59daf23cf2899dd676749a8742cc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a190e59daf23cf2899dd676749a8742cc">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;)</td></tr>
<tr class="memdesc:a190e59daf23cf2899dd676749a8742cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> in a human-readable form.  <a href="namespace_halide.html#a190e59daf23cf2899dd676749a8742cc">More...</a><br /></td></tr>
<tr class="separator:a190e59daf23cf2899dd676749a8742cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae94266acfeba1bce3298e333ba4b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c">get_host_target</a> ()</td></tr>
<tr class="memdesc:a0ae94266acfeba1bce3298e333ba4b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target corresponding to the host machine.  <a href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c">More...</a><br /></td></tr>
<tr class="separator:a0ae94266acfeba1bce3298e333ba4b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25236e75d4d73bee045028da680215d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">get_target_from_environment</a> ()</td></tr>
<tr class="memdesc:ab25236e75d4d73bee045028da680215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> will use.  <a href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">More...</a><br /></td></tr>
<tr class="separator:ab25236e75d4d73bee045028da680215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2cf046902155db63e83374f23a47b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a> ()</td></tr>
<tr class="memdesc:a9d2cf046902155db63e83374f23a47b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> will use for jit-compilation.  <a href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">More...</a><br /></td></tr>
<tr class="separator:a9d2cf046902155db63e83374f23a47b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab19de8fa28eb2396a0b8d40c338491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8ab19de8fa28eb2396a0b8d40c338491">target_feature_for_device_api</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> api)</td></tr>
<tr class="memdesc:a8ab19de8fa28eb2396a0b8d40c338491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> feature corresponding to a DeviceAPI.  <a href="namespace_halide.html#a8ab19de8fa28eb2396a0b8d40c338491">More...</a><br /></td></tr>
<tr class="separator:a8ab19de8fa28eb2396a0b8d40c338491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a0c034814a65d55bb848fe9c96653b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a> (int bits, int lanes=1)</td></tr>
<tr class="memdesc:a70a0c034814a65d55bb848fe9c96653b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing a signed integer type.  <a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">More...</a><br /></td></tr>
<tr class="separator:a70a0c034814a65d55bb848fe9c96653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb5f455b5c4bce0c54575bc67bf9599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a> (int bits, int lanes=1)</td></tr>
<tr class="memdesc:a0eb5f455b5c4bce0c54575bc67bf9599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing an unsigned integer type.  <a href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">More...</a><br /></td></tr>
<tr class="separator:a0eb5f455b5c4bce0c54575bc67bf9599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11df91175e8ac20ce33379c178e8c7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a> (int bits, int lanes=1)</td></tr>
<tr class="memdesc:a11df91175e8ac20ce33379c178e8c7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a floating-point type.  <a href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">More...</a><br /></td></tr>
<tr class="separator:a11df91175e8ac20ce33379c178e8c7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7fe222498c37bde1eaa2c771fb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e0f7fe222498c37bde1eaa2c771fb0c">BFloat</a> (int bits, int lanes=1)</td></tr>
<tr class="memdesc:a0e0f7fe222498c37bde1eaa2c771fb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a floating-point type in the bfloat format.  <a href="namespace_halide.html#a0e0f7fe222498c37bde1eaa2c771fb0c">More...</a><br /></td></tr>
<tr class="separator:a0e0f7fe222498c37bde1eaa2c771fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26cb40c3218a0e075879e44374a4d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad26cb40c3218a0e075879e44374a4d9d">Bool</a> (int lanes=1)</td></tr>
<tr class="memdesc:ad26cb40c3218a0e075879e44374a4d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean type.  <a href="namespace_halide.html#ad26cb40c3218a0e075879e44374a4d9d">More...</a><br /></td></tr>
<tr class="separator:ad26cb40c3218a0e075879e44374a4d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e876323440c13edf4fa63112050c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a92e876323440c13edf4fa63112050c8d">Handle</a> (int lanes=1, const <a class="el" href="structhalide__handle__cplusplus__type.html">halide_handle_cplusplus_type</a> *handle_type=nullptr)</td></tr>
<tr class="memdesc:a92e876323440c13edf4fa63112050c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handle type.  <a href="namespace_halide.html#a92e876323440c13edf4fa63112050c8d">More...</a><br /></td></tr>
<tr class="separator:a92e876323440c13edf4fa63112050c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">type_of</a> ()</td></tr>
<tr class="memdesc:a230bbc98235cdeaea250aa9ab19f3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the halide equivalent of a C type.  <a href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">More...</a><br /></td></tr>
<tr class="separator:a230bbc98235cdeaea250aa9ab19f3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834f79e4ba8398f31f2512cd4949ab3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0834f79e4ba8398f31f2512cd4949ab3">type_to_c_type</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> type, bool include_space, bool c_plus_plus=true)</td></tr>
<tr class="memdesc:a0834f79e4ba8398f31f2512cd4949ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type to a C++ type.  <a href="namespace_halide.html#a0834f79e4ba8398f31f2512cd4949ab3">More...</a><br /></td></tr>
<tr class="separator:a0834f79e4ba8398f31f2512cd4949ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abdb3bac86d5020a2fc5c0fad5eba8592">load_plugin</a> (const std::string &amp;lib_name)</td></tr>
<tr class="memdesc:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin in the form of a dynamic library (e.g.  <a href="namespace_halide.html#abdb3bac86d5020a2fc5c0fad5eba8592">More...</a><br /></td></tr>
<tr class="separator:abdb3bac86d5020a2fc5c0fad5eba8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab7e8f5756fe34d428d6c70095cdcf8b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab7e8f5756fe34d428d6c70095cdcf8b">head1_channels</a> = 8</td></tr>
<tr class="separator:aab7e8f5756fe34d428d6c70095cdcf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa373ab31181627dc3ed16ac676e561a8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa373ab31181627dc3ed16ac676e561a8">head1_w</a> = 40</td></tr>
<tr class="separator:aa373ab31181627dc3ed16ac676e561a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8790329f3be3d6c675a7868c944311"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aee8790329f3be3d6c675a7868c944311">head1_h</a> = 7</td></tr>
<tr class="separator:aee8790329f3be3d6c675a7868c944311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bf8c7312090d7f312590aec7192719"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a93bf8c7312090d7f312590aec7192719">head2_channels</a> = 24</td></tr>
<tr class="separator:a93bf8c7312090d7f312590aec7192719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1660f1a4cc56d0271d2942ce9437ec8c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1660f1a4cc56d0271d2942ce9437ec8c">head2_w</a> = 39</td></tr>
<tr class="separator:a1660f1a4cc56d0271d2942ce9437ec8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde902a9d2b5fae2afad7f7b7edb1c9c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abde902a9d2b5fae2afad7f7b7edb1c9c">conv1_channels</a> = 32</td></tr>
<tr class="separator:abde902a9d2b5fae2afad7f7b7edb1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeae4f594180635f1a0a60c0dac5fe72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abeae4f594180635f1a0a60c0dac5fe72">all_device_apis</a> []</td></tr>
<tr class="memdesc:abeae4f594180635f1a0a60c0dac5fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array containing all the device apis.  <a href="namespace_halide.html#abeae4f594180635f1a0a60c0dac5fe72">More...</a><br /></td></tr>
<tr class="separator:abeae4f594180635f1a0a60c0dac5fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. </p>
<p>Defines methods for manipulating and analyzing boolean expressions.</p>
<p>This file defines the LoopNest, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> schedule, and contains methods to generate candidates for scheduling as well as extract a featurization that can be used to cost each candidate. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="adac6d1605235bf518c12a05ed6850d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac6d1605235bf518c12a05ed6850d43">&#9670;&nbsp;</a></span>Region</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Halide::Region</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00343">343</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="ad7b585cf844dcb14fa12386d743cbb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b585cf844dcb14fa12386d743cbb24">&#9670;&nbsp;</a></span>ScheduleHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_halide_1_1_stage.html">Stage</a> <a class="el" href="namespace_halide.html#ad7b585cf844dcb14fa12386d743cbb24">Halide::ScheduleHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00463">463</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a id="afe643966574f0ad69cad7f936c086740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe643966574f0ad69cad7f936c086740">&#9670;&nbsp;</a></span>ModuleFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide.html#afe643966574f0ad69cad7f936c086740">Halide::ModuleFactory</a> = typedef std::function&lt;<a class="el" href="class_halide_1_1_module.html">Module</a>(const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_module_8h_source.html#l00220">220</a> of file <a class="el" href="_module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a6e2a7a400cd68d41f2868eebb762c32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2a7a400cd68d41f2868eebb762c32e">&#9670;&nbsp;</a></span>CompilerLoggerFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide.html#a6e2a7a400cd68d41f2868eebb762c32e">Halide::CompilerLoggerFactory</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">Internal::CompilerLogger</a>&gt;(const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_module_8h_source.html#l00221">221</a> of file <a class="el" href="_module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a00a35e107901afb7e58583ea88ae3a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a35e107901afb7e58583ea88ae3a6b">&#9670;&nbsp;</a></span>AutoSchedulerFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide.html#a00a35e107901afb7e58583ea88ae3a6b">Halide::AutoSchedulerFn</a> = typedef std::function&lt;void(const <a class="el" href="class_halide_1_1_pipeline.html">Pipeline</a> &amp;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;, const <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &amp;, <a class="el" href="struct_halide_1_1_auto_scheduler_results.html">AutoSchedulerResults</a> *outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_pipeline_8h_source.html#l00093">93</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">&#9670;&nbsp;</a></span>DeviceAPI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">Halide::DeviceAPI</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of device API. </p>
<p>Used by schedules, and in the For loop IR node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2"></a>Host&#160;</td><td class="fielddoc"><p>Used to denote for loops that run on the same device as the containing code. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8"></a>Default_GPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaa33b7755e5f9b504d2d038eaca4ff28d"></a>CUDA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea7982b09a852b37f2afb1227eaf552e47"></a>OpenCL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea3adf0945d2bbb4c868f37d38e02684d5"></a>OpenGLCompute&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaeaa57a9b4248ce3968e718895e1c2f04"></a>Metal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea125e13c182697c5a282e4de6d7999eb0"></a>Hexagon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea4b2626a6b8b94341748b21e603039989"></a>HexagonDma&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaac083508369e66fdeb744a9dbf917bee"></a>D3D12Compute&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_device_a_p_i_8h_source.html#l00015">15</a> of file <a class="el" href="_device_a_p_i_8h_source.html">DeviceAPI.h</a>.</p>

</div>
</div>
<a id="af28f02315017283b26196866c92d4da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28f02315017283b26196866c92d4da9">&#9670;&nbsp;</a></span>MemoryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">Halide::MemoryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing different address spaces to be used with <a class="el" href="class_halide_1_1_func.html#acd1cab6886b924854e827eb3bba2bc35" title="Set the type of memory this Func should be stored in.">Func::store_in</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb"></a>Auto&#160;</td><td class="fielddoc"><p>Let <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> select a storage type automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a556e9a86db9c921373c6b5097817214a"></a>Heap&#160;</td><td class="fielddoc"><p>Heap/global memory. </p>
<p>Allocated using halide_malloc, or halide_device_malloc </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a2187e1021a911b3807cc1bea2eb1a9ca"></a>Stack&#160;</td><td class="fielddoc"><p>Stack memory. </p>
<p>Allocated using alloca. Requires a constant size. Corresponds to per-thread local memory on the GPU. If all accesses are at constant coordinates, may be promoted into the register file at the discretion of the register allocator. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a0ba7583639a274c434bbe6ef797115a4"></a>Register&#160;</td><td class="fielddoc"><p>Register memory. </p>
<p>The allocation should be promoted into the register file. All stores must be at constant coordinates. May be spilled to the stack at the discretion of the register allocator. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9ae70f90d745f5615e5bccbf337fcf74b7"></a>GPUShared&#160;</td><td class="fielddoc"><p>Allocation is stored in GPU shared memory. </p>
<p>Also known as "local" in OpenCL, and "threadgroup" in metal. Can be shared across GPU threads within the same block. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9adca9ac9e90136a545f57ebe550531dbb"></a>GPUTexture&#160;</td><td class="fielddoc"><p>Allocation is stored in GPU texture memory and accessed through hardware sampler. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a54ef2e772f864e79d6ac27325edd9f0e"></a>LockedCache&#160;</td><td class="fielddoc"><p>Allocate Locked Cache Memory to act as local memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="af28f02315017283b26196866c92d4da9a4838ea37d7bdc9f7edf4a6185f0496e2"></a>VTCM&#160;</td><td class="fielddoc"><p>Vector Tightly Coupled Memory. </p>
<p>HVX (Hexagon) local memory available on v65+. This memory has higher performance and lower power. Ideal for intermediate buffers. Necessary for vgather-vscatter instructions on Hexagon </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00346">346</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a9a0a73a2b8a7322d8ac330adfce8d134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0a73a2b8a7322d8ac330adfce8d134">&#9670;&nbsp;</a></span>NameMangling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">Halide::NameMangling</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum to specify calling convention for extern stages. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a0a73a2b8a7322d8ac330adfce8d134a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"><p>Match whatever is specified in the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a0a73a2b8a7322d8ac330adfce8d134a0d61f8370cad1d412f80b84d143e1257"></a>C&#160;</td><td class="fielddoc"><p>No name mangling. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a0a73a2b8a7322d8ac330adfce8d134a618c337d168d3e2f339a16f8f6069c20"></a>CPlusPlus&#160;</td><td class="fielddoc"><p>C++ name mangling. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_function_8h_source.html#l00024">24</a> of file <a class="el" href="_function_8h_source.html">Function.h</a>.</p>

</div>
</div>
<a id="afdb8b92dac95804211c0a875302da5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb8b92dac95804211c0a875302da5f4">&#9670;&nbsp;</a></span>Output</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Halide::Output</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enums specifying various kinds of outputs that can be produced from a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline.">Pipeline</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a08d5f9e9048e2000531c3170f4b833b1"></a>assembly&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a05bcd6bc2c5f7d9a2881e398f0b47046"></a>bitcode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a311f8e1f5e3fdcbfdc6478c22b10dc18"></a>c_header&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a015af973befd454e4865798605d42142"></a>c_source&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a186be22498341345705f076e5284b323"></a>compiler_log&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a69145b419344ef1bae3f04b31a73e15f"></a>cpp_stub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a7398e19fe1290ceb66f93afe92b93c61"></a>featurization&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a58be17eec9473900cc830f456fac020a"></a>llvm_assembly&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4aa8cfde6331bd59eb2ac96f8911c4b666"></a>object&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4ab0c78a2d6b974f99eb59ff3194523260"></a>python_extension&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4ae511a3b21360f6b2149b9464c7536a75"></a>pytorch_wrapper&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a563873d38950b841aebf89c3be1b1a35"></a>registration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a799855594adc0f2bd7302c69d3234b5a"></a>schedule&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a1c1bec5ce39d59c7ef87be64f7d41a9e"></a>static_library&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a217ecb18a8f8e5f1889339c3fa093fc3"></a>stmt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afdb8b92dac95804211c0a875302da5f4a86bb0db5358a18cf840463ed6fb31678"></a>stmt_html&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_module_8h_source.html#l00027">27</a> of file <a class="el" href="_module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a172db5c21e58bfed0793b7152657623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172db5c21e58bfed0793b7152657623c">&#9670;&nbsp;</a></span>LinkageType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">Halide::LinkageType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> of linkage a function in a lowered <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> module can have. </p>
<p>Also controls whether auxiliary functions and metadata are generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a172db5c21e58bfed0793b7152657623cab206a1b4ea1097761f78e8876f6da779"></a>External&#160;</td><td class="fielddoc"><p>Visible externally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a172db5c21e58bfed0793b7152657623ca46a7ceaa07d4cf61082c34cbf8f6a95c"></a>ExternalPlusMetadata&#160;</td><td class="fielddoc"><p>Visible externally. <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> metadata and an argv wrapper are also generated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3"></a>Internal&#160;</td><td class="fielddoc"><p>Not visible externally, similar to 'static' linkage in C. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_module_8h_source.html#l00048">48</a> of file <a class="el" href="_module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ad1953af304956bd6a5d0bd780b135f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1953af304956bd6a5d0bd780b135f56">&#9670;&nbsp;</a></span>StmtOutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">Halide::StmtOutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to determine if the output printed to file should be as a normal string or as an HTML file which can be opened in a browerser and manipulated via JS and CSS. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91"></a>Text&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1953af304956bd6a5d0bd780b135f56a0e7445a36a4c4afba58997fbc4871f3b"></a>HTML&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_pipeline_8h_source.html#l00061">61</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>

</div>
</div>
<a id="a36b78b48c1fe9126344a218d07348f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b78b48c1fe9126344a218d07348f4d">&#9670;&nbsp;</a></span>PrefetchBoundStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">Halide::PrefetchBoundStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different ways to handle accesses outside the original extents in a prefetch. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a36b78b48c1fe9126344a218d07348f4da08825280e3f8137556325061ba67ff8c"></a>Clamp&#160;</td><td class="fielddoc"><p>Clamp the prefetched exprs by intersecting the prefetched region with the original extents. </p>
<p>This may make the exprs of the prefetched region more complicated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d"></a>GuardWithIf&#160;</td><td class="fielddoc"><p>Guard the prefetch with if-guards that ignores the prefetch if any of the prefetched region ever goes beyond the original extents (i.e. </p>
<p>all or nothing). </p>
</td></tr>
<tr><td class="fieldname"><a id="a36b78b48c1fe9126344a218d07348f4da744c9ae316f75de6b586a6eb11f8df0b"></a>NonFaulting&#160;</td><td class="fielddoc"><p>Leave the prefetched exprs as are (no if-guards around the prefetch and no intersecting with the original extents). </p>
<p>This makes the prefetch exprs simpler but this may cause prefetching of region outside the original extents. This is good if prefetch won't fault when accessing region outside the original extents. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_prefetch_directive_8h_source.html#l00016">16</a> of file <a class="el" href="_prefetch_directive_8h_source.html">PrefetchDirective.h</a>.</p>

</div>
</div>
<a id="a6c6557df562bd7850664e70fdb8fea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6557df562bd7850664e70fdb8fea0f">&#9670;&nbsp;</a></span>TailStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">Halide::TailStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different ways to handle a tail case in a split when the factor does not provably divide the extent. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c6557df562bd7850664e70fdb8fea0fa16b999f69f07356ae94c65a20b832926"></a>RoundUp&#160;</td><td class="fielddoc"><p>Round up the extent to be a multiple of the split factor. </p>
<p>Not legal for RVars, as it would change the meaning of the algorithm. Pros: generates the simplest, fastest code. Cons: if used on a stage that reads from the input or writes to the output, constrains the input or output size to be a multiple of the split factor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c6557df562bd7850664e70fdb8fea0fa5b80e0001d7f4873a60bbded160c687d"></a>GuardWithIf&#160;</td><td class="fielddoc"><p>Guard the inner loop with an if statement that prevents evaluation beyond the original extent. </p>
<p>Always legal. The if statement is treated like a boundary condition, and factored out into a loop epilogue if possible. Pros: no redundant re-evaluation; does not constrain input our output sizes. Cons: increases code size due to separate tail-case handling; vectorization will scalarize in the tail case to handle the if statement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c6557df562bd7850664e70fdb8fea0faa3c9898dfb77c232e7dbbcb95cadaa16"></a>ShiftInwards&#160;</td><td class="fielddoc"><p>Prevent evaluation beyond the original extent by shifting the tail case inwards, re-evaluating some points near the end. </p>
<p>Only legal for pure variables in pure definitions. If the inner loop is very simple, the tail case is treated like a boundary condition and factored out into an epilogue.</p>
<p>This is a good trade-off between several factors. Like RoundUp, it supports vectorization well, because the inner loop is always a fixed size with no data-dependent branching. It increases code size slightly for inner loops due to the epilogue handling, but not for outer loops (e.g. loops over tiles). If used on a stage that reads from an input or writes to an output, this stategy only requires that the input/output extent be at least the split factor, instead of a multiple of the split factor as with RoundUp. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb"></a>Auto&#160;</td><td class="fielddoc"><p>For pure definitions use ShiftInwards. </p>
<p>For pure vars in update definitions use RoundUp. For RVars in update definitions use GuardWithIf. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00032">32</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>

</div>
</div>
<a id="a751041c9a6cffe776b613f4dd04c3354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751041c9a6cffe776b613f4dd04c3354">&#9670;&nbsp;</a></span>LoopAlignStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">Halide::LoopAlignStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different ways to handle the case when the start/end of the loops of stages computed with (fused) are not aligned. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b"></a>AlignStart&#160;</td><td class="fielddoc"><p>Shift the start of the fused loops to align. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af"></a>AlignEnd&#160;</td><td class="fielddoc"><p>Shift the end of the fused loops to align. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751041c9a6cffe776b613f4dd04c3354a0835c1623d085e407eba4f9310103309"></a>NoAlign&#160;</td><td class="fielddoc"><p>compute_with will make no attempt to align the start/end of the fused loops. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb"></a>Auto&#160;</td><td class="fielddoc"><p>By default, LoopAlignStrategy is set to NoAlign. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00077">77</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a98ec21770ee3d7bac1f0c1a9d5fd0644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ec21770ee3d7bac1f0c1a9d5fd0644">&#9670;&nbsp;</a></span>make_default_cost_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="class_halide_1_1_default_cost_model.html">DefaultCostModel</a>&gt; Halide::make_default_cost_model </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>weights_in_dir</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>weights_out_dir</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>randomize_weights</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1952af26f2b37156587562bdeccfaba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1952af26f2b37156587562bdeccfaba8">&#9670;&nbsp;</a></span>codegen_llvm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::codegen_llvm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> module, generate an llvm::Module. </p>

</div>
</div>
<a id="a7082de94433ce36f34d486a0bddbc200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7082de94433ce36f34d486a0bddbc200">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an expression on an output stream (such as std::cout) in human-readable form. </p>

</div>
</div>
<a id="af00a873047edcc26c57685fd8f0b1e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a873047edcc26c57685fd8f0b1e2e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide type on an output stream (such as std::cout) in human-readable form. </p>

</div>
</div>
<a id="a80e793e1d0e898cdd6003272ad051668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e793e1d0e898cdd6003272ad051668">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> on an output stream (such as std::cout) in human-readable form. </p>

</div>
</div>
<a id="afd783f233611c16b4f805dacc89cca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd783f233611c16b4f805dacc89cca42">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> in a human readable form. </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="a1e455180d26c51953b64f318f3c8b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e455180d26c51953b64f318f3c8b11f">&#9670;&nbsp;</a></span>propagate_adjoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a> Halide::propagate_adjoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>output_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and a corresponding adjoint, (back)propagate the adjoint to all dependent Funcs, buffers, and parameters. </p>
<p>The bounds of output and adjoint need to be specified with pair {min, extent} For each <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> the output depends on, and for the pure definition and each update of that <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, it generates a derivative <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> stored in the <a class="el" href="class_halide_1_1_derivative.html" title="Helper structure storing the adjoints Func.">Derivative</a>. </p>

</div>
</div>
<a id="a754b88aa3b1aa18a7809f665ba10aad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754b88aa3b1aa18a7809f665ba10aad9">&#9670;&nbsp;</a></span>propagate_adjoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a> Halide::propagate_adjoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and a corresponding adjoint buffer, (back)propagate the adjoint to all dependent Funcs, buffers, and parameters. </p>
<p>For each <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> the output depends on, and for the pure definition and each update of that <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, it generates a derivative <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> stored in the <a class="el" href="class_halide_1_1_derivative.html" title="Helper structure storing the adjoints Func.">Derivative</a>. </p>

</div>
</div>
<a id="a98a3ed6633ddd588c45cfa98dcaf84ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a3ed6633ddd588c45cfa98dcaf84ef">&#9670;&nbsp;</a></span>propagate_adjoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_derivative.html">Derivative</a> Halide::propagate_adjoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a scalar <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with size 1, (back)propagate the gradient to all dependent Funcs, buffers, and parameters. </p>
<p>For each <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> the output depends on, and for the pure definition and each update of that <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, it generates a derivative <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> stored in the <a class="el" href="class_halide_1_1_derivative.html" title="Helper structure storing the adjoints Func.">Derivative</a>. </p>

</div>
</div>
<a id="af7566eca1e318568c044f5b14d914842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7566eca1e318568c044f5b14d914842">&#9670;&nbsp;</a></span>get_device_interface_for_device_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a>* Halide::get_device_interface_for_device_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">get_jit_target_from_environment</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_site</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the appropriate <a class="el" href="structhalide__device__interface__t.html" title="Each GPU API provides a halide_device_interface_t struct pointing to the code that manages device all...">halide_device_interface_t</a> * for a DeviceAPI. </p>
<p>If error_site is non-null, e.g. the name of the routine calling get_device_interface_for_device_api, a user_error is reported if the requested device API is not enabled in or supported by the target, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> has been compiled without this device API, or the device API is None or Host or a bad value. The error_site argument is printed in the error message. If error_site is null, this routine returns nullptr instead of calling user_error. </p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00585">Halide::Buffer&lt; T &gt;::copy_to_device()</a>, <a class="el" href="_buffer_8h_source.html#l00595">Halide::Buffer&lt; T &gt;::device_malloc()</a>, and <a class="el" href="_buffer_8h_source.html#l00604">Halide::Buffer&lt; T &gt;::device_wrap_native()</a>.</p>

</div>
</div>
<a id="a58a1df88c4f9bd924bd79a1120d14694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a1df88c4f9bd924bd79a1120d14694">&#9670;&nbsp;</a></span>get_default_device_api_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> Halide::get_default_device_api_for_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specific DeviceAPI that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> would select when presented with <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a> for a given target. </p>
<p>If no suitable api is enabled in the target, returns <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2" title="Used to denote for loops that run on the same device as the containing code.">DeviceAPI::Host</a>. </p>

</div>
</div>
<a id="a27245995e7e6ad0923dd764ad621b5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27245995e7e6ad0923dd764ad621b5aa">&#9670;&nbsp;</a></span>host_supports_target_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::host_supports_target_device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This attempts to sniff whether a given <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> (and its implied DeviceAPI) is usable on the current host. </p>
<p>If it appears to be usable, return true; if not, return false. Note that a return value of true does <em>not</em> guarantee that future usage of that device will succeed; it is intended mainly as a simple diagnostic to allow early-exit when a desired device is definitely not usable. Also note that this call is <em>NOT</em> threadsafe, as it temporarily redirect various global error-handling hooks in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a9">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="a5b356550ce5d4c3f8ab941cf3b474cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b356550ce5d4c3f8ab941cf3b474cb3">&#9670;&nbsp;</a></span>exceptions_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::exceptions_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> was compiled with exceptions. </p>

</div>
</div>
<a id="a64b2e4833f813a4e306f3407f663c393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b2e4833f813a4e306f3407f663c393">&#9670;&nbsp;</a></span>set_custom_compile_time_error_reporter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::set_custom_compile_time_error_reporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_compile_time_error_reporter.html">CompileTimeErrorReporter</a> *&#160;</td>
          <td class="paramname"><em>error_reporter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default error reporter logs to stderr, then throws an exception (if HALIDE_WITH_EXCEPTIONS) or calls abort (if not). </p>
<p>This allows customization of that behavior if a more gentle response to error reporting is desired. Note that error_reporter is expected to remain valid across all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> usage; it is up to the caller to ensure that this is the case (and to do any cleanup necessary). </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="ae49ee5776e58865649c8268328508d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49ee5776e58865649c8268328508d2a">&#9670;&nbsp;</a></span>fast_integer_divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_integer_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer division by small values can be done exactly as multiplies and shifts. </p>
<p>This function does integer division for numerators of various integer types (8, 16, 32 bit signed and unsigned) numerators and uint8 denominators. The type of the result is the type of the numerator. The unsigned version is faster than the signed version, so cast the numerator to an unsigned int if you know it's positive.</p>
<p>If your divisor is compile-time constant, <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> performs a slightly better optimization automatically, so there's no need to use this function (but it won't hurt).</p>
<p>This function vectorizes well on arm, and well on x86 for 16 and 8 bit vectors. For 32-bit vectors on x86 you're better off using native integer division.</p>
<p>Also, this routine treats division by zero as division by</p><ol type="1">
<li>I.e. it interprets the uint8 divisor as a number from 1 to 256 inclusive. </li>
</ol>

</div>
</div>
<a id="a84586a3960712309cd2939a54bbac587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84586a3960712309cd2939a54bbac587">&#9670;&nbsp;</a></span>fast_integer_modulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_integer_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the fast integer division tables to implement a modulo operation via the Euclidean identity: ab = a - (a/b)*b. </p>

</div>
</div>
<a id="a842daf6fbd0f87ec9ea8336cb0cdd23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842daf6fbd0f87ec9ea8336cb0cdd23e">&#9670;&nbsp;</a></span>min() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit overloads of min and max for <a class="el" href="class_halide_1_1_func_ref.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Vars or Exprs.">FuncRef</a>. </p>
<p>These exist to disambiguate calls to min on FuncRefs when a user has pulled both <a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e" title="Explicit overloads of min and max for FuncRef.">Halide::min</a> and std::min into their namespace. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#a4">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a0">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a1">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00578">578</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01212">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00594">halide_default_do_loop_task()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00600">halide_default_do_par_for()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00797">halide_do_loop_task()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00792">halide_do_par_for()</a>, <a class="el" href="_simplify___internal_8h_source.html#l00072">Halide::Internal::Simplify::ExprInfo::intersect()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00679">min()</a>, <a class="el" href="_generator_8h_source.html#l01203">Halide::Internal::GeneratorMinMax::min_forward()</a>, <a class="el" href="_param_8h_source.html#l00114">Halide::Param&lt; T &gt;::Param()</a>, <a class="el" href="_r_dom_8h_source.html#l00218">Halide::RDom::RDom()</a>, <a class="el" href="_util_8h_source.html#l00075">Halide::Internal::safe_numeric_cast()</a>, <a class="el" href="_generator_8h_source.html#l02592">Halide::Internal::GeneratorOutput_Func&lt; T &gt;::set_estimate()</a>, <a class="el" href="_generator_8h_source.html#l01715">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;::set_estimate()</a>, <a class="el" href="_generator_8h_source.html#l01875">Halide::Internal::GeneratorInput_Func&lt; T &gt;::set_estimate()</a>, <a class="el" href="_param_8h_source.html#l00233">Halide::Param&lt; T &gt;::set_min_value()</a>, <a class="el" href="_param_8h_source.html#l00228">Halide::Param&lt; T &gt;::set_range()</a>, and <a class="el" href="_function_d_a_g_8h_source.html#l00243">Halide::Internal::Autoscheduler::Span::union_with()</a>.</p>

</div>
</div>
<a id="aea2c7f5fe6c79a49dcbb28951cf8405d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2c7f5fe6c79a49dcbb28951cf8405d">&#9670;&nbsp;</a></span>max() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func_ref.html">FuncRef</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a2">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a3">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00581">581</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01393">Halide::Runtime::Buffer&lt; T, D &gt;::contains()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01212">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, <a class="el" href="_elf_8h_source.html#l00309">Halide::Internal::Elf::Section::get_size()</a>, <a class="el" href="_simplify___internal_8h_source.html#l00072">Halide::Internal::Simplify::ExprInfo::intersect()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00644">max()</a>, <a class="el" href="_generator_8h_source.html#l01212">Halide::Internal::GeneratorMinMax::max_forward()</a>, <a class="el" href="_param_8h_source.html#l00114">Halide::Param&lt; T &gt;::Param()</a>, <a class="el" href="_util_8h_source.html#l00075">Halide::Internal::safe_numeric_cast()</a>, <a class="el" href="_param_8h_source.html#l00240">Halide::Param&lt; T &gt;::set_max_value()</a>, <a class="el" href="_param_8h_source.html#l00228">Halide::Param&lt; T &gt;::set_range()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01365">Halide::Runtime::Buffer&lt; T, D &gt;::translate()</a>, <a class="el" href="_function_d_a_g_8h_source.html#l00243">Halide::Internal::Autoscheduler::Span::union_with()</a>, and <a class="el" href="cmdline_8h_source.html#l00646">cmdline::parser::usage()</a>.</p>

</div>
</div>
<a id="a34f3541db2d08c4e3f18df546b8796ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f3541db2d08c4e3f18df546b8796ff">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> T Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expression. </p>
<p>This can be thought of as a scalar version of <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Func::realize</a> </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02486">2486</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Halide::Func::realize()</a>, <a class="el" href="_expr_8h_source.html#l00320">Halide::Expr::type()</a>, and <a class="el" href="_errors_8h_source.html#l00015">user_assert</a>.</p>

</div>
</div>
<a id="ab36a37228e934e5d99e0800ccc0a94a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36a37228e934e5d99e0800ccc0a94a7">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02499">2499</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02469">Halide::Internal::assign_results()</a>, <a class="el" href="_func_8h_source.html#l02454">Halide::Internal::check_types()</a>, and <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Halide::Func::realize()</a>.</p>

</div>
</div>
<a id="a3ece4281929aec52e480d8021c43b020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ece4281929aec52e480d8021c43b020">&#9670;&nbsp;</a></span>evaluate_may_gpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> T Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expression. </p>
<p>This can be thought of as a scalar version of <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Func::realize</a>. Can use GPU if jit target from environment specifies one. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02528">2528</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Halide::Func::realize()</a>, <a class="el" href="_func_8h_source.html#l02510">Halide::Internal::schedule_scalar()</a>, <a class="el" href="_expr_8h_source.html#l00320">Halide::Expr::type()</a>, and <a class="el" href="_errors_8h_source.html#l00015">user_assert</a>.</p>

</div>
</div>
<a id="a1d1ad1afdbe47ccd8e21b6576900e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ad1afdbe47ccd8e21b6576900e82e">&#9670;&nbsp;</a></span>evaluate_may_gpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>. </p>
<p>Can use GPU if jit target from environment specifies one. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02544">2544</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02469">Halide::Internal::assign_results()</a>, <a class="el" href="_func_8h_source.html#l02454">Halide::Internal::check_types()</a>, <a class="el" href="class_halide_1_1_func.html#a8ab12935949cc586b9c0a731551e8175">Halide::Func::realize()</a>, and <a class="el" href="_func_8h_source.html#l02510">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a id="a7ffe416c9264a301f4dbee5088cd4212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffe416c9264a301f4dbee5088cd4212">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a + (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition between GeneratorParam&lt;T&gt; and any type that supports operator+ with T. </p>
<p>Returns type of underlying operator+. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a4">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01019">1019</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ad0b04406900c92aff4fe7df31bf35d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b04406900c92aff4fe7df31bf35d6c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a + b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01023">1023</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a3fcc2cb5052cc21ff4819dad8d62c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcc2cb5052cc21ff4819dad8d62c86f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a - (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction between GeneratorParam&lt;T&gt; and any type that supports operator- with T. </p>
<p>Returns type of underlying operator-. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01032">1032</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ad63c3bccbde6ba2a4986f11bf662bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63c3bccbde6ba2a4986f11bf662bf7e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a - b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01036">1036</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a24aabc3f5a598cb3c662e05b01243ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aabc3f5a598cb3c662e05b01243ebb">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a * (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication between GeneratorParam&lt;T&gt; and any type that supports operator* with T. </p>
<p>Returns type of underlying operator*. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a5">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01045">1045</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a17ffddd99ce9d53114517a17496e45b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ffddd99ce9d53114517a17496e45b1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a * b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01049">1049</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="addcc05645a8be0bf5b547891b5eedbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcc05645a8be0bf5b547891b5eedbd6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a / (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division between GeneratorParam&lt;T&gt; and any type that supports operator/ with T. </p>
<p>Returns type of underlying operator/. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01058">1058</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="aedb1bbedd0274448f1b81fe8de753287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb1bbedd0274448f1b81fe8de753287">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a / b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01062">1062</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a993b255e504fe0b7812c60db527c997b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993b255e504fe0b7812c60db527c997b">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a % (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modulo between GeneratorParam&lt;T&gt; and any type that supports operator% with T. </p>
<p>Returns type of underlying operator%. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01071">1071</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a8e0eb4d1f94756aa0776e126762c4a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0eb4d1f94756aa0776e126762c4a5c">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a % b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01075">1075</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ab7126caa58fad82bb502a72f7ba72dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7126caa58fad82bb502a72f7ba72dae">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a &gt; (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt; with T. </p>
<p>Returns type of underlying operator&gt;. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01084">1084</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a212d29d2096665d1ee6bdec6ac8cb5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212d29d2096665d1ee6bdec6ac8cb5ad">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &gt; b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01088">1088</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a1f99adc84a7324351d6037eacb3f9157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99adc84a7324351d6037eacb3f9157">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a &lt; (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt; with T. </p>
<p>Returns type of underlying operator&lt;. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01097">1097</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="aab6493da795ebe5c52ce922583d7aed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6493da795ebe5c52ce922583d7aed4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &lt; b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01101">1101</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a016a50dc9625193a554ec0d51fb8d953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016a50dc9625193a554ec0d51fb8d953">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a &gt;= (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt;= with T. </p>
<p>Returns type of underlying operator&gt;=. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01110">1110</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a4598327ce18c80e8b2f89edde2554e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4598327ce18c80e8b2f89edde2554e02">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &gt;= b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01114">1114</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="aa4053db56eee7933acebf91f83803cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4053db56eee7933acebf91f83803cff">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a &lt;= (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt;= with T. </p>
<p>Returns type of underlying operator&lt;=. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01123">1123</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a730bcf31dedcc336b12929d2afe35ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730bcf31dedcc336b12929d2afe35ea2">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &lt;= b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01127">1127</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a12fecab5f39831c5d8444fbf700c0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fecab5f39831c5d8444fbf700c0e04">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a == (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison between GeneratorParam&lt;T&gt; and any type that supports operator== with T. </p>
<p>Returns type of underlying operator==. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01136">1136</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ac9aa81c242a4d52174dfe07e28dd856f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa81c242a4d52174dfe07e28dd856f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a == b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01140">1140</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="abe8ddebe6a310029aaf2096c17750a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8ddebe6a310029aaf2096c17750a1e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a != (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison between between GeneratorParam&lt;T&gt; and any type that supports operator!= with T. </p>
<p>Returns type of underlying operator!=. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01149">1149</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="af53392f7139bea898ab547a1aa14f8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53392f7139bea898ab547a1aa14f8cb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a != b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01153">1153</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a8e8cc876748afd9ec969b7d0d45d1008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8cc876748afd9ec969b7d0d45d1008">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a &amp;&amp; (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical and between between GeneratorParam&lt;T&gt; and any type that supports operator&amp;&amp; with T. </p>
<p>Returns type of underlying operator&amp;&amp;. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01162">1162</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a228ada08fcdf1652525a98f2f0f0df44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228ada08fcdf1652525a98f2f0f0df44">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &amp;&amp; b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01166">1166</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ac3fe93546b3f630e218bae59afba254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fe93546b3f630e218bae59afba254f">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a &amp;&amp; (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01170">1170</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a2ab1d71b2448732fda75553fc7f23c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab1d71b2448732fda75553fc7f23c89">&#9670;&nbsp;</a></span>operator||() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a || (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical or between between GeneratorParam&lt;T&gt; and any type that supports operator|| with T. </p>
<p>Returns type of underlying operator||. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01179">1179</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="af4786dcd28f875b5886c08221ceade3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4786dcd28f875b5886c08221ceade3b">&#9670;&nbsp;</a></span>operator||() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a || b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01183">1183</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="adf2ad1425d57e892ab6f16d66af3b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2ad1425d57e892ab6f16d66af3b882">&#9670;&nbsp;</a></span>operator||() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((T)a || (T)b) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01187">1187</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a0fcc240a43e9bd59167b72a75ba39d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcc240a43e9bd59167b72a75ba39d3a">&#9670;&nbsp;</a></span>min() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::min </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Internal::GeneratorMinMax::min_forward</a>(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute minimum between GeneratorParam&lt;T&gt; and any type that supports min with T. </p>
<p>Will automatically import std::min. Returns type of underlying min call. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01227">1227</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l01203">Halide::Internal::GeneratorMinMax::min_forward()</a>.</p>

</div>
</div>
<a id="a38f0112267498bcda0747506b9d82af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f0112267498bcda0747506b9d82af8">&#9670;&nbsp;</a></span>min() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Internal::GeneratorMinMax::min_forward</a>(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01231">1231</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l01203">Halide::Internal::GeneratorMinMax::min_forward()</a>.</p>

</div>
</div>
<a id="aa350166ccd23cc6430356bb6833d3910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa350166ccd23cc6430356bb6833d3910">&#9670;&nbsp;</a></span>max() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::max </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Internal::GeneratorMinMax::max_forward</a>(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum value between GeneratorParam&lt;T&gt; and any type that supports max with T. </p>
<p>Will automatically import std::max. Returns type of underlying max call. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01240">1240</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l01212">Halide::Internal::GeneratorMinMax::max_forward()</a>.</p>

</div>
</div>
<a id="aeb5a870f8517436e4720b50792f8fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5a870f8517436e4720b50792f8fdd1">&#9670;&nbsp;</a></span>max() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Other , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Internal::GeneratorMinMax::max_forward</a>(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01244">1244</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l01212">Halide::Internal::GeneratorMinMax::max_forward()</a>.</p>

</div>
</div>
<a id="a534f823d7f303e81b20bdff79e38179c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534f823d7f303e81b20bdff79e38179c">&#9670;&nbsp;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; decltype(!(T)a) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not operator for <a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a>. </p>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01251">1251</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a41aa8982b04d0b5faf76de0fd4c0cc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aa8982b04d0b5faf76de0fd4c0cc33">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;sum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example using <a class="el" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> :</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>(f(x + r));</div>
<div class="ttc" id="anamespace_halide_html_a41aa8982b04d0b5faf76de0fd4c0cc33"><div class="ttname"><a href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">Halide::sum</a></div><div class="ttdeci">Expr sum(Expr, const std::string &amp;s=&quot;sum&quot;)</div><div class="ttdoc">An inline reduction.</div></div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a4">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a71599f1dae36c608e3236e06a7fdf9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71599f1dae36c608e3236e06a7fdf9b5">&#9670;&nbsp;</a></span>product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;product&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20c3805a6d059a671810c6d004e8d1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c3805a6d059a671810c6d004e8d1bd">&#9670;&nbsp;</a></span>maximum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;maximum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a6">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00164">Halide::SimdOpCheckTest::check_one()</a>.</p>

</div>
</div>
<a id="aab45b50a1d7838663e5cfaceff50d8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab45b50a1d7838663e5cfaceff50d8b7">&#9670;&nbsp;</a></span>minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;minimum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a7">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ace593c64f8634a1c323db86ac4d80663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace593c64f8634a1c323db86ac4d80663">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;sum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> is stated explicitly. </p>
<p>The expression can refer to multiple RDoms, and only the inner one is captured by the reduction. This allows you to write expressions like: </p><div class="fragment"><div class="line">RDom r1(0, 10), r2(0, 10), r3(0, 10);</div>
<div class="line">Expr e = <a class="code" href="namespace_halide.html#aab45b50a1d7838663e5cfaceff50d8b7">minimum</a>(r1, <a class="code" href="namespace_halide.html#a71599f1dae36c608e3236e06a7fdf9b5">product</a>(r2, <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>(r3, r1 + r2 + r3)));</div>
<div class="ttc" id="anamespace_halide_html_a71599f1dae36c608e3236e06a7fdf9b5"><div class="ttname"><a href="namespace_halide.html#a71599f1dae36c608e3236e06a7fdf9b5">Halide::product</a></div><div class="ttdeci">Expr product(Expr, const std::string &amp;s=&quot;product&quot;)</div></div>
<div class="ttc" id="anamespace_halide_html_aab45b50a1d7838663e5cfaceff50d8b7"><div class="ttname"><a href="namespace_halide.html#aab45b50a1d7838663e5cfaceff50d8b7">Halide::minimum</a></div><div class="ttdeci">Expr minimum(Expr, const std::string &amp;s=&quot;minimum&quot;)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afead2dd46805437cceb61926b3abaeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afead2dd46805437cceb61926b3abaeb8">&#9670;&nbsp;</a></span>product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;product&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8431916e36bd66ced9083f9052e7972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8431916e36bd66ced9083f9052e7972">&#9670;&nbsp;</a></span>maximum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::maximum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;maximum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a44140d5b2aad1fa4d308d70c081f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a44140d5b2aad1fa4d308d70c081f19">&#9670;&nbsp;</a></span>minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::minimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;minimum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0312becda0f0debcb8bfc6d8413105c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0312becda0f0debcb8bfc6d8413105c6">&#9670;&nbsp;</a></span>argmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmax&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> which minimizes or maximizes the expression. </p>
<p>The expression must refer to some <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>. Also returns the extreme value of the expression as the last element of the tuple. </p>

</div>
</div>
<a id="a1f171f43c7cce3a17b60ac9127c63b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f171f43c7cce3a17b60ac9127c63b12">&#9670;&nbsp;</a></span>argmin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmin&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a6">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac516a301c43e36cd6226124423ecd5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516a301c43e36cd6226124423ecd5ba">&#9670;&nbsp;</a></span>argmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmax&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af61f1499e2f36600d4cf308c8c4a0793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61f1499e2f36600d4cf308c8c4a0793">&#9670;&nbsp;</a></span>argmin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmin&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c6da1a731c0804063458b531e8a849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6da1a731c0804063458b531e8a849">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression to the halide type corresponding to the C++ type T. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a6">tutorial/lesson_14_types.cpp</a>, and <a class="el" href="tutorial_2lesson_15_generators_8cpp-example.html#a3">tutorial/lesson_15_generators.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00366">366</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_concise_casts_8h_source.html#l00028">Halide::ConciseCasts::bf16()</a>, <a class="el" href="_generator_8h_source.html#l02934">Halide::NamesInterface::cast()</a>, <a class="el" href="_concise_casts_8h_source.html#l00023">Halide::ConciseCasts::f32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00018">Halide::ConciseCasts::f64()</a>, <a class="el" href="_concise_casts_8h_source.html#l00043">Halide::ConciseCasts::i16()</a>, <a class="el" href="_concise_casts_8h_source.html#l00038">Halide::ConciseCasts::i32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00033">Halide::ConciseCasts::i64()</a>, <a class="el" href="_concise_casts_8h_source.html#l00048">Halide::ConciseCasts::i8()</a>, <a class="el" href="_concise_casts_8h_source.html#l00063">Halide::ConciseCasts::u16()</a>, <a class="el" href="_concise_casts_8h_source.html#l00058">Halide::ConciseCasts::u32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00053">Halide::ConciseCasts::u64()</a>, and <a class="el" href="_concise_casts_8h_source.html#l00068">Halide::ConciseCasts::u8()</a>.</p>

</div>
</div>
<a id="a69ce0e6da961a52ace4b8fa8444fac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ce0e6da961a52ace4b8fa8444fac20">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast an expression to a new type. </p>

</div>
</div>
<a id="a2db532b84ba55ff72555c4b427fc42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db532b84ba55ff72555c4b427fc42bc">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a28d7f25e89e1f74d7d76e370161f7358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d7f25e89e1f74d7d76e370161f7358">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an expression and a constant integer. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="a95625f031290fffefab2365275c4981f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95625f031290fffefab2365275c4981f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constant integer and an expression. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="acd77e71422999076fa3339829ac8c30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd77e71422999076fa3339829ac8c30d">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the first expression to be the sum of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

</div>
</div>
<a id="a86f3eb27005363158ca0e934811c98ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f3eb27005363158ca0e934811c98ed">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a065c7f5ec94e00c50ce57e0acd336eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065c7f5ec94e00c50ce57e0acd336eaa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a constant integer from an expression. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="a929a86c18d4952daa3d1bad7b2b448fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929a86c18d4952daa3d1bad7b2b448fc">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts an expression from a constant integer. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="a80881209a15ed749e168d6edbcb6f687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80881209a15ed749e168d6edbcb6f687">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negative of the argument. </p>
<p>Does no type casting, so more formally: return that number which when added to the original, yields zero of the same type. For unsigned integers the negative is still an unsigned integer. E.g. in UInt(8), the negative of 56 is 200, because 56 + 200 == 0 </p>

</div>
</div>
<a id="a94db82f1af5cd7492bb503c2238ade8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94db82f1af5cd7492bb503c2238ade8a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the first expression to be the difference of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

</div>
</div>
<a id="a908c6748ab34a4a66274b196b6900af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908c6748ab34a4a66274b196b6900af5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="add192217868f9861b756a85d212c0ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add192217868f9861b756a85d212c0ecd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply an expression and a constant integer. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="abe93ddfca97d22f96789eea9b8c5d355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe93ddfca97d22f96789eea9b8c5d355">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a constant integer and an expression. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="ac0c84f284a38d6018e2d4e5d075c8b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c84f284a38d6018e2d4e5d075c8b5b">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the first expression to be the product of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

</div>
</div>
<a id="a73e12ddd6395e3a1c1286e2e3c51e675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e12ddd6395e3a1c1286e2e3c51e675">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>
<p>Note that integer division in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> is not the same as integer division in C-like languages in two ways.</p>
<p>First, signed integer division in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> rounds according to the sign of the denominator. This means towards minus infinity for positive denominators, and towards positive infinity for negative denominators. This is unlike C, which rounds towards zero. This decision ensures that upsampling expressions like f(x/2, y/2) don't have funny discontinuities when x and y cross zero.</p>
<p>Second, division by zero returns zero instead of faulting. For types where overflow is defined behavior, division of the largest negative signed integer by -1 returns the larged negative signed integer for the type (i.e. it wraps). This ensures that a division operation can never have a side-effect, which is helpful in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> because scheduling directives can expand the domain of computation of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, potentially introducing new zero-division. </p>

</div>
</div>
<a id="a3c0da6820c40a5911fb23d973283487f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0da6820c40a5911fb23d973283487f">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the first expression to be the ratio of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. Note that signed integer division in <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> rounds towards minus infinity, unlike C, which rounds towards zero. </p>

</div>
</div>
<a id="a1dfc6078f426cdc7e80fe36681d01e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfc6078f426cdc7e80fe36681d01e5e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides an expression by a constant integer. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="a8351f5d64c664ba9d65178161e1937db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8351f5d64c664ba9d65178161e1937db">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides a constant integer by an expression. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="abc191ed3318e2072d18f42d11f5b01d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc191ed3318e2072d18f42d11f5b01d4">&#9670;&nbsp;</a></span>operator%() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>
<p>There are two key differences between C-like languages and <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> for the modulo operation, which complement the way division works.</p>
<p>First, the result is never negative, so x % 2 is always zero or one, unlike in C-like languages. x % -2 is equivalent, and is also always zero or one. Second, mod by zero evaluates to zero (unlike in C, where it faults). This makes modulo, like division, a side-effect-free operation. </p>

</div>
</div>
<a id="a63ba15c22ee9addfc1b08fd6642d2c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ba15c22ee9addfc1b08fd6642d2c4d">&#9670;&nbsp;</a></span>operator%() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mods an expression by a constant integer. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="acb2825498112ddec5da6caa3deaf435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2825498112ddec5da6caa3deaf435e">&#9670;&nbsp;</a></span>operator%() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mods a constant integer by an expression. </p>
<p>Coerces the type of the integer to match the type of the expression. Errors if the integer cannot be represented in the type of the expression. </p>

</div>
</div>
<a id="af9105ae9f0995f450825e522170f5d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9105ae9f0995f450825e522170f5d1e">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a014703a60d365b71dee6def5cb7a6f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014703a60d365b71dee6def5cb7a6f2c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is greater than a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a4af05e2a8405c578614399da8ffba005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af05e2a8405c578614399da8ffba005">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is greater than an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="abbad5ee20448455260670dec22c76a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbad5ee20448455260670dec22c76a21">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a8b253d012615166e933d5b39d0bc83fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b253d012615166e933d5b39d0bc83fc">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is less than a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="aee20253bf83a4cdd89537cc6e8161524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee20253bf83a4cdd89537cc6e8161524">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is less than an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="ad297e6fa5deb0ba4e8ad7fe344629706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad297e6fa5deb0ba4e8ad7fe344629706">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a0616c33325d7b8ee67a4e2e305f5f375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616c33325d7b8ee67a4e2e305f5f375">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is less than or equal to a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a6b263f999854f1e7e1ee8602998bb016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b263f999854f1e7e1ee8602998bb016">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is less than or equal to an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a8f2e815b9cc7475802c0fb6a7e7ae6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e815b9cc7475802c0fb6a7e7ae6ae">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a9fc55d0783c46ace37a0b413d82dd100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc55d0783c46ace37a0b413d82dd100">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is greater than or equal to a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a977de0ab82ad7e0ac7d4c6321554d6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977de0ab82ad7e0ac7d4c6321554d6c9">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is greater than or equal to an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="abfbbb2e5820938f4d8f0a8b2324776df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbbb2e5820938f4d8f0a8b2324776df">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="adc3fdd8106c4413b0606a5cb73d3ec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3fdd8106c4413b0606a5cb73d3ec1c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is equal to a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a115d4df85c9d3b9e9221f0c62c765858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115d4df85c9d3b9e9221f0c62c765858">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is equal to an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a8d3d11c86964dbb2586103744cac1614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3d11c86964dbb2586103744cac1614">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>

</div>
</div>
<a id="a59dbd0c68dfe117d2d1351d8f86cae4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dbd0c68dfe117d2d1351d8f86cae4f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether an expression is not equal to a constant integer. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a82c1c720efb61b649e495eac92c0c6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c1c720efb61b649e495eac92c0c6eb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether a constant integer is not equal to an expression. </p>
<p>Coerces the integer to the type of the expression. Errors if the integer is not representable in that type. </p>

</div>
</div>
<a id="a02df159d6ed5236cc8e02d04bf72be4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02df159d6ed5236cc8e02d04bf72be4f">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logical and of the two arguments. </p>

</div>
</div>
<a id="ab6c979cf5df557f554752e177655026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c979cf5df557f554752e177655026f">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical and of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool. </p>
<p>Either returns the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> representing false, depending on the bool. </p>

</div>
</div>
<a id="a01eda141b66c0d5bdc3b3faebc229b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eda141b66c0d5bdc3b3faebc229b44">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3528931d7929d533103ada2badca092c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3528931d7929d533103ada2badca092c">&#9670;&nbsp;</a></span>operator||() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logical or of the two arguments. </p>

</div>
</div>
<a id="a38218eafbf9de824d559a4ff593a5617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38218eafbf9de824d559a4ff593a5617">&#9670;&nbsp;</a></span>operator||() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool. </p>
<p>Either returns the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> representing true, depending on the bool. </p>

</div>
</div>
<a id="a3131cefcee0f570a9bbf98121326f7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131cefcee0f570a9bbf98121326f7d8">&#9670;&nbsp;</a></span>operator||() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb54256bfab344b6720775cf2e0936e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb54256bfab344b6720775cf2e0936e0">&#9670;&nbsp;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator! </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logical not the argument. </p>

</div>
</div>
<a id="a9a00cabb9f57b4cf5d101b2af338f5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a00cabb9f57b4cf5d101b2af338f5ec">&#9670;&nbsp;</a></span>max() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>
<p>Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>

</div>
</div>
<a id="a65d007e9eff86b8854b12840303294b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d007e9eff86b8854b12840303294b9">&#9670;&nbsp;</a></span>max() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of an expression and a constant integer. </p>
<p>The integer is coerced to the type of the expression. Errors if the integer is not representable as that type. Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>

</div>
</div>
<a id="a7950ad100fb78022bf9c49003d6ccc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7950ad100fb78022bf9c49003d6ccc19">&#9670;&nbsp;</a></span>max() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of a constant integer and an expression. </p>
<p>The integer is coerced to the type of the expression. Errors if the integer is not representable as that type. Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>

</div>
</div>
<a id="ad30475861d1493c3353e62ec77a3b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30475861d1493c3353e62ec77a3b516">&#9670;&nbsp;</a></span>max() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00644">644</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00581">max()</a>.</p>

</div>
</div>
<a id="a7ba49d8dff61c221859c462054375258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba49d8dff61c221859c462054375258">&#9670;&nbsp;</a></span>max() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00647">647</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00581">max()</a>.</p>

</div>
</div>
<a id="a6b1ff27a6f9948cb752117cf7064449f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1ff27a6f9948cb752117cf7064449f">&#9670;&nbsp;</a></span>max() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>
<p>Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). The expressions are folded from right ie. max(.., max(.., ..)). The arguments can be any mix of types but must all be convertible to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00659">659</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00581">max()</a>.</p>

</div>
</div>
<a id="a38b5db24ca379dda8241433c0014c940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b5db24ca379dda8241433c0014c940">&#9670;&nbsp;</a></span>min() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade891378c7247910129a61258cf00a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade891378c7247910129a61258cf00a56">&#9670;&nbsp;</a></span>min() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression representing the lesser of an expression and a constant integer. </p>
<p>The integer is coerced to the type of the expression. Errors if the integer is not representable as that type. Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>

</div>
</div>
<a id="a1af2f7c75c30e16933e0e0f1a89b6a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af2f7c75c30e16933e0e0f1a89b6a07">&#9670;&nbsp;</a></span>min() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression representing the lesser of a constant integer and an expression. </p>
<p>The integer is coerced to the type of the expression. Errors if the integer is not representable as that type. Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>

</div>
</div>
<a id="a79f42d034894ac2f27a09f73627437a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f42d034894ac2f27a09f73627437a0">&#9670;&nbsp;</a></span>min() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00679">679</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00578">min()</a>.</p>

</div>
</div>
<a id="a68e4e576c9e0ca6588c3e5bc54856589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e4e576c9e0ca6588c3e5bc54856589">&#9670;&nbsp;</a></span>min() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00682">682</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00578">min()</a>.</p>

</div>
</div>
<a id="aa8132b0bbea7c1a5146765a22d981e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8132b0bbea7c1a5146765a22d981e5c">&#9670;&nbsp;</a></span>min() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the lesser of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>. </p>
<p>Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). The expressions are folded from right ie. min(.., min(.., ..)). The arguments can be any mix of types but must all be convertible to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00694">694</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00578">min()</a>.</p>

</div>
</div>
<a id="a8d830f627b9fd99f8845dadcde7b0dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d830f627b9fd99f8845dadcde7b0dd1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operators on floats treats those floats as Exprs. </p>
<p>Making these explicit prevents implicit float-&gt;int casts that might otherwise occur. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00702">702</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a704b7b04f00436d90aad52a74a230181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704b7b04f00436d90aad52a74a230181">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00705">705</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="aacb362e84f0a152acd46b3ab42da29b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb362e84f0a152acd46b3ab42da29b9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00708">708</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a47d01cda7bea93467113a5d32b00467a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d01cda7bea93467113a5d32b00467a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00711">711</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a585ccd78b6034d015358838478f4147b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ccd78b6034d015358838478f4147b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00714">714</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a96077a9c1ec602e9196f7fe0a6dec2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96077a9c1ec602e9196f7fe0a6dec2bf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00717">717</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a77dce878e2e6156e9e9ec00f240c3de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dce878e2e6156e9e9ec00f240c3de3">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00720">720</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a2c179840fe2018ea7106e3c7305516b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c179840fe2018ea7106e3c7305516b6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00723">723</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a9a7ffb094c58badc44f353a94681dbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7ffb094c58badc44f353a94681dbfe">&#9670;&nbsp;</a></span>operator%() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00726">726</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="aced81e366b73b3c1503905f0c594c516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced81e366b73b3c1503905f0c594c516">&#9670;&nbsp;</a></span>operator%() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00729">729</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a3fb3edae8f6879c195ad373c0d7a7b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb3edae8f6879c195ad373c0d7a7b86">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00732">732</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="abe14360d4dab7d8119572f3aefdbbb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe14360d4dab7d8119572f3aefdbbb25">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00735">735</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a4e5730454f894a93bebbaf72dbc714e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5730454f894a93bebbaf72dbc714e1">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00738">738</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a47dd5b9660e5510cc23bbf8fa8e5f4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dd5b9660e5510cc23bbf8fa8e5f4b7">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00741">741</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a070410b979a0b62fdb67d6f13fbdc1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070410b979a0b62fdb67d6f13fbdc1d4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00744">744</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a4d2e1d96814511a965a43e835947966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2e1d96814511a965a43e835947966e">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00747">747</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="ab944b1232804900cdde74619fbfeda68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab944b1232804900cdde74619fbfeda68">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00750">750</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a5fc2ce1a66bdb1877f337436295cfc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc2ce1a66bdb1877f337436295cfc90">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00753">753</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a506ebe338276d9e91223e9f7f57eaa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506ebe338276d9e91223e9f7f57eaa46">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00756">756</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="ae54bb0b329c0bb93eb19a2dc3a4e2285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54bb0b329c0bb93eb19a2dc3a4e2285">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00759">759</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="abf32c2846c632946f95a2ea9f60da704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf32c2846c632946f95a2ea9f60da704">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00762">762</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="af60a387c587e80408e8fa8b63bfb7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60a387c587e80408e8fa8b63bfb7cdb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00765">765</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a40b1c066344e4816e822a467522bb1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b1c066344e4816e822a467522bb1f1">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamps an expression to lie within the given bounds. </p>
<p>The bounds are type-cast to match the expression. Vectorizes as well as min/max. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#a0">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a5">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a0">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae698f4bfd37d3d15cee4bf22c4627e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae698f4bfd37d3d15cee4bf22c4627e0d">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of a signed integer or floating-point expression. </p>
<p>Vectorizes cleanly. Unlike in C, abs of a signed integer returns an unsigned integer of the same bit width. This means that abs of the most negative integer doesn't overflow. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">Halide::Internal::IRMatcher::fuzz_test_rule()</a>, and <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a8d96f6e421c7a9a25f3d027283c7149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d96f6e421c7a9a25f3d027283c7149d">&#9670;&nbsp;</a></span>absd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::absd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the absolute difference between two values. </p>
<p>Vectorizes cleanly. Returns an unsigned value of the same bit width. There are various ways to write this yourself, but they contain numerous gotchas and don't always compile to good code, so use this instead. </p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00164">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a9d6371892ae38e7eb681fd3f23945b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6371892ae38e7eb681fd3f23945b06">&#9670;&nbsp;</a></span>select() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments. </p>
<p>If the first argument is true, then return the second, else return the third. Typically vectorizes cleanly, but benefits from SSE41 or newer on x86. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a0">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00799">select()</a>.</p>

</div>
</div>
<a id="ac19df75a6ad3b8a7e7a2acaa84c5c9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19df75a6ad3b8a7e7a2acaa84c5c9eb">&#9670;&nbsp;</a></span>select() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Args... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00799">799</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select()</a>.</p>

</div>
</div>
<a id="a8f04c3a60a6f50464ee6aca3d484ee3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f04c3a60a6f50464ee6aca3d484ee3e">&#9670;&nbsp;</a></span>tuple_select() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent of ternary <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples. </p>
<p>If the condition is a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, it must match the size of the true and false Tuples. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00814">tuple_select()</a>.</p>

</div>
</div>
<a id="ace388be6ec6a0d3e2ad02993aba8cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace388be6ec6a0d3e2ad02993aba8cc41">&#9670;&nbsp;</a></span>tuple_select() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2fe5d43378f4d24f33980dbf2a8094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fe5d43378f4d24f33980dbf2a8094f">&#9670;&nbsp;</a></span>tuple_select() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent of multiway <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples. </p>
<p>If the condition is a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, it must match the size of the true and false Tuples. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00814">814</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">tuple_select()</a>.</p>

</div>
</div>
<a id="a4134581388acb9d7ef198a759d733e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4134581388acb9d7ef198a759d733e2a">&#9670;&nbsp;</a></span>tuple_select() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00819">819</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">tuple_select()</a>.</p>

</div>
</div>
<a id="a6872ea25baf89339321f85340ed48c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6872ea25baf89339321f85340ed48c14">&#9670;&nbsp;</a></span>mux() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::mux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Oftentimes we want to pack a list of expressions with the same type into a channel dimension, e.g., img(x, y, c) = select(c == 0, 100, // Red c == 1, 50, // Green 25); // Blue This is tedious when the list is long. </p>
<p>The following function provide convinent syntax that allow one to write: img(x, y, c) = mux(c, {100, 50, 25});</p>
<p>As with the select equivalent, if the first argument (the index) is out of range, the expression evaluates to the last value. </p>

</div>
</div>
<a id="a1448d91aca15f1e6a5610fbc8cc0b15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448d91aca15f1e6a5610fbc8cc0b15b">&#9670;&nbsp;</a></span>mux() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::mux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1093d3bc68908f364e9bddf5803286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1093d3bc68908f364e9bddf5803286">&#9670;&nbsp;</a></span>mux() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::mux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1fca22f79625765096133e39caee5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1fca22f79625765096133e39caee5e">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a0">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a0">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a1">tutorial/lesson_13_tuples.cpp</a>, and <a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a5">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3bfc77a80e6b40a6c00899a8e2ad1f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfc77a80e6b40a6c00899a8e2ad1f28">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the arcsine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="a7e1ef33189b99c7b8bc73b5e10121834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1ef33189b99c7b8bc73b5e10121834">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a1">tutorial/lesson_04_debugging_2.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a2">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a722a64d3ef272e07177d95b624968951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722a64d3ef272e07177d95b624968951">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="ad18f43994d3cf73c20b7eb62b243076e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18f43994d3cf73c20b7eb62b243076e">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="abe3b0ec19519602bc880a1ae0236f1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3b0ec19519602bc880a1ae0236f1c3">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="a5646de466ac31efd07ec5af1e4603cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5646de466ac31efd07ec5af1e4603cbf">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the angle of a floating-point gradient. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="abe05bc670b713a278f8182457a750bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe05bc670b713a278f8182457a750bd9">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic sine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="abb5d3eac37ebfab1c8a2abf7ab1ebfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic arcsinhe of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="a68aff5fc199ecbabe209ce32ec507292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68aff5fc199ecbabe209ce32ec507292">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="a2ce048ac6f7c309d26c83fbc3132be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce048ac6f7c309d26c83fbc3132be2b">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="acb15a9760067c05d2e5a343f529188be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb15a9760067c05d2e5a343f529188be">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="acd93e33e8d82be7cf9487e881d834ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd93e33e8d82be7cf9487e881d834ec9">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hyperbolic arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

</div>
</div>
<a id="abc7f08f13439b86581a47162e1a2d2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7f08f13439b86581a47162e1a2d2de">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the square root of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Typically vectorizes cleanly. </p>

</div>
</div>
<a id="a410c523b5f2f78733ca45d946a9ededb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410c523b5f2f78733ca45d946a9ededb">&#9670;&nbsp;</a></span>hypot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the square root of the sum of the squares of two floating-point expressions. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Vectorizes cleanly. </p>

</div>
</div>
<a id="a877c6187068d6e839e548776dfa7dde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c6187068d6e839e548776dfa7dde3">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the exponential of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). For Float(64) arguments, this calls the system exp function, and does not vectorize well. For Float(32) arguments, this function is vectorizable, does the right thing for extremely small or extremely large inputs, and is accurate up to the last bit of the mantissa. Vectorizes cleanly. </p>

</div>
</div>
<a id="a02f1c38239e6e977fea90b94217499ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f1c38239e6e977fea90b94217499ae">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the logarithm of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). For Float(64) arguments, this calls the system log function, and does not vectorize well. For Float(32) arguments, this function is vectorizable, does the right thing for inputs &lt;= 0 (returns -inf or nan), and is accurate up to the last bit of the mantissa. Vectorizes cleanly. </p>

</div>
</div>
<a id="a4dd83996070aa3e4bc3a102a654176fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd83996070aa3e4bc3a102a654176fa">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one floating point expression raised to the power of another. </p>
<p>The type of the result is given by the type of the first argument. If the first argument is not a floating-point type, it is cast to Float(32). For Float(32), cleanly vectorizable, and accurate up to the last few bits of the mantissa. Gets worse when approaching overflow. Vectorizes cleanly. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a1">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afcc3e2a1e80bd2b512b38aa87aa91f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc3e2a1e80bd2b512b38aa87aa91f9e">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the error function erf. </p>
<p>Only available for Float(32). Accurate up to the last three bits of the mantissa. Vectorizes cleanly. </p>

</div>
</div>
<a id="a8f774e4779466acb57a6e571cb636ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f774e4779466acb57a6e571cb636ba6">&#9670;&nbsp;</a></span>fast_sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast vectorizable approximation to some trigonometric functions for Float(32). </p>
<p>Absolute approximation error is less than 1e-5. </p>

</div>
</div>
<a id="a137dfeea487e7444f0b20c14b545c0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137dfeea487e7444f0b20c14b545c0dd">&#9670;&nbsp;</a></span>fast_cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c7bd26b46c10f2c3a6fc36da6a89518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7bd26b46c10f2c3a6fc36da6a89518">&#9670;&nbsp;</a></span>fast_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable log for Float(32). </p>
<p>Returns nonsense for x &lt;= 0.0f. Accurate up to the last 5 bits of the mantissa. Vectorizes cleanly. </p>

</div>
</div>
<a id="a744536415e304e37370fa6e216300354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744536415e304e37370fa6e216300354">&#9670;&nbsp;</a></span>fast_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable exp for Float(32). </p>
<p>Returns nonsense for inputs that would overflow or underflow. Typically accurate up to the last 5 bits of the mantissa. Gets worse when approaching overflow. Vectorizes cleanly. </p>

</div>
</div>
<a id="a958457cd688f84d583779e649c9e52e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958457cd688f84d583779e649c9e52e6">&#9670;&nbsp;</a></span>fast_pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable pow for Float(32). </p>
<p>Returns nonsense for x &lt; 0.0f. Accurate up to the last 5 bits of the mantissa for typical exponents. Gets worse when approaching overflow. Vectorizes cleanly. </p>

</div>
</div>
<a id="a343eac4b4aa329e52c7cbf8167902696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343eac4b4aa329e52c7cbf8167902696">&#9670;&nbsp;</a></span>fast_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate inverse for Float(32). </p>
<p>Corresponds to the rcpps instruction on x86, and the vrecpe instruction on ARM. Vectorizes cleanly. Note that this can produce slightly different results across different implementations of the same architecture (e.g. AMD vs Intel), even when strict_float is enabled. </p>

</div>
</div>
<a id="ad4424b070b363f53107a6c2705bbe50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4424b070b363f53107a6c2705bbe50b">&#9670;&nbsp;</a></span>fast_inverse_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_inverse_sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate inverse square root for Float(32). </p>
<p>Corresponds to the rsqrtps instruction on x86, and the vrsqrte instruction on ARM. Vectorizes cleanly. Note that this can produce slightly different results across different implementations of the same architecture (e.g. AMD vs Intel), even when strict_float is enabled. </p>

</div>
</div>
<a id="aed670387016322f8db2b7abdecdc0e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed670387016322f8db2b7abdecdc0e4c">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the greatest whole number less than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00288">Halide::Internal::mod_imp&lt; double &gt;()</a>.</p>

</div>
</div>
<a id="a070dde32195d1ae83082c15fd11d5d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070dde32195d1ae83082c15fd11d5d90">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the least whole number greater than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

</div>
</div>
<a id="a9d2090a77072af682d9e2daea086d2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2090a77072af682d9e2daea086d2fe">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the whole number closest to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. On ties, we follow IEEE754 conventions and round to the nearest even number. Vectorizes cleanly. </p>

</div>
</div>
<a id="a287f93889910a28197d2a1631486a433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287f93889910a28197d2a1631486a433">&#9670;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the integer part of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

</div>
</div>
<a id="ab71c5b6b09e0f679724ccfb95515b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71c5b6b09e0f679724ccfb95515b338">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the argument is a Not a Number (NaN). </p>
<p>Requires a floating point argument. Vectorizes cleanly. Note that the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> passed in will be evaluated in strict_float mode, regardless of whether strict_float mode is enabled in the current <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="ac519f67137d32cdf11dd43101d626349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac519f67137d32cdf11dd43101d626349">&#9670;&nbsp;</a></span>is_inf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::is_inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the argument is Inf or -Inf. </p>
<p>Requires a floating point argument. Vectorizes cleanly. Note that the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> passed in will be evaluated in strict_float mode, regardless of whether strict_float mode is enabled in the current <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="ac70f45a449357e2b40f7008e5630fb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70f45a449357e2b40f7008e5630fb63">&#9670;&nbsp;</a></span>is_finite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::is_finite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the argument is a finite value (ie, neither NaN nor Inf). </p>
<p>Requires a floating point argument. Vectorizes cleanly. Note that the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> passed in will be evaluated in strict_float mode, regardless of whether strict_float mode is enabled in the current <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="a18e72ac620ae5d7944f8b15244ec5e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e72ac620ae5d7944f8b15244ec5e32">&#9670;&nbsp;</a></span>fract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the fractional part of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value has the same sign as the original expression. Vectorizes cleanly. </p>

</div>
</div>
<a id="a0f13f0a9e97bf7673ca5a8e04b1bd9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">&#9670;&nbsp;</a></span>reinterpret() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::reinterpret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinterpret the bits of one value as another type. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01037">reinterpret()</a>, and <a class="el" href="_generator_8h_source.html#l01990">Halide::Internal::GeneratorInput_Scalar&lt; T &gt;::set_estimate()</a>.</p>

</div>
</div>
<a id="a2012c20f1666555e7a229c9db1b64091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2012c20f1666555e7a229c9db1b64091">&#9670;&nbsp;</a></span>reinterpret() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::reinterpret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01037">1037</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">reinterpret()</a>.</p>

</div>
</div>
<a id="a4ec8e49b0b42230077ee6bdca669d299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec8e49b0b42230077ee6bdca669d299">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise and of two expressions (which need not have the same type). </p>
<p>The result type is the wider of the two expressions. Only integral types are allowed and both expressions must be signed or both must be unsigned. </p>

</div>
</div>
<a id="a88242b4128c62353a9be9cec97ce7517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88242b4128c62353a9be9cec97ce7517">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise and of an expression and an integer. </p>
<p>The type of the result is the type of the expression argument. </p>

</div>
</div>
<a id="a839e5d84cbffa329f76a5a43aac5d3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e5d84cbffa329f76a5a43aac5d3dd">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe8bec8d2f6194f4db7b88e554173f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8bec8d2f6194f4db7b88e554173f05">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise or of two expressions (which need not have the same type). </p>
<p>The result type is the wider of the two expressions. Only integral types are allowed and both expressions must be signed or both must be unsigned. </p>

</div>
</div>
<a id="a7b42f239b51e5665705b31eeb353e64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b42f239b51e5665705b31eeb353e64d">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise or of an expression and an integer. </p>
<p>The type of the result is the type of the expression argument. </p>

</div>
</div>
<a id="a585fea347a8ec3bd113b466f6a8f5c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585fea347a8ec3bd113b466f6a8f5c93">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator| </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdde4dd479f4eb59631e09148897ad2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdde4dd479f4eb59631e09148897ad2a">&#9670;&nbsp;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise xor of two expressions (which need not have the same type). </p>
<p>The result type is the wider of the two expressions. Only integral types are allowed and both expressions must be signed or both must be unsigned. </p>

</div>
</div>
<a id="a879829a780e257db389ba9ad59689f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879829a780e257db389ba9ad59689f94">&#9670;&nbsp;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise xor of an expression and an integer. </p>
<p>The type of the result is the type of the expression argument. </p>

</div>
</div>
<a id="a367813f3f387e6e43565767a92d9829a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367813f3f387e6e43565767a92d9829a">&#9670;&nbsp;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator^ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9c07e39289b14103ccd45ee31630a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c07e39289b14103ccd45ee31630a3">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise not of an expression. </p>

</div>
</div>
<a id="a39865d2369d130f6c8e435c860cafb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39865d2369d130f6c8e435c860cafb14">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the bits of an integer value left. </p>
<p>This is actually less efficient than multiplying by 2^n, because <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s optimization passes understand multiplication, and will compile it to shifting. This operator is only for if you really really need bit shifting (e.g. because the exponent is a run-time parameter). The type of the result is equal to the type of the first argument. Both arguments must have integer type. </p>

</div>
</div>
<a id="a9bce43f9178ddb2fda8f1ef8c5755384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bce43f9178ddb2fda8f1ef8c5755384">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0615561baf45c3d84e7d36c77204ee3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0615561baf45c3d84e7d36c77204ee3d">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the bits of an integer value right. </p>
<p>Does sign extension for signed integers. This is less efficient than dividing by a power of two. <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s definition of division (always round to negative infinity) means that all divisions by powers of two get compiled to bit-shifting, and <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s optimization routines understand division and can work with it. The type of the result is equal to the type of the first argument. Both arguments must have integer type. </p>

</div>
</div>
<a id="ab8e7223753c831bcb54d39bbdf40733d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7223753c831bcb54d39bbdf40733d">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55158f5f229510194c425dfae256d530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55158f5f229510194c425dfae256d530">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolate between the two values according to a weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zero_val</td><td>The result when weight is 0 </td></tr>
    <tr><td class="paramname">one_val</td><td>The result when weight is 1 </td></tr>
    <tr><td class="paramname">weight</td><td>The interpolation amount</td></tr>
  </table>
  </dd>
</dl>
<p>Both zero_val and one_val must have the same type. All types are supported, including bool.</p>
<p>The weight is treated as its own type and must be float or an unsigned integer type. It is scaled to the bit-size of the type of x and y if they are integer, or converted to float if they are float. Integer weights are converted to float via division by the full-range value of the weight's type. Floating-point weights used to interpolate between integer values must be between 0.0f and 1.0f, and an error may be signaled if it is not provably so. (clamp operators can be added to provide proof. Currently an error is only signalled for constant weights.)</p>
<p>For integer linear interpolation, out of range values cannot be represented. In particular, weights that are conceptually less than 0 or greater than 1.0 are not representable. As such the result is always between x and y (inclusive of course). For lerp with floating-point values and floating-point weight, the full range of a float is valid, however underflow and overflow can still occur.</p>
<p>Ordering is not required between zero_val and one_val: lerp(42, 69, .5f) == lerp(69, 42, .5f) == 56</p>
<p>Results for integer types are for exactly rounded arithmetic. As such, there are cases where 16-bit and float differ because 32-bit floating-point (float) does not have enough precision to produce the exact result. (Likely true for 32-bit integer vs. double-precision floating-point as well.)</p>
<p>At present, double precision and 64-bit integers are not supported.</p>
<p>Generally, lerp will vectorize as if it were an operation on a type twice the bit size of the inferred type for x and y.</p>
<p>Some examples: </p><div class="fragment"><div class="line"><span class="comment">// Since Halide does not have direct type delcarations, casts</span></div>
<div class="line"><span class="comment">// below are used to indicate the types of the parameters.</span></div>
<div class="line"><span class="comment">// Such casts not required or expected in actual code where types</span></div>
<div class="line"><span class="comment">// are inferred.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;float&gt;(x), cast&lt;float&gt;(y), cast&lt;float&gt;(w)) -&gt;</div>
<div class="line">  x * (1.0f - w) + y * w</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;uint8_t&gt;(x), cast&lt;uint8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;uint8_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +</div>
<div class="line">                cast&lt;uint8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note addition in Halide promoted uint8_t + int8_t to int16_t already,</span></div>
<div class="line"><span class="comment">// the outer cast is added for clarity.</span></div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;uint8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;int16_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +</div>
<div class="line">                cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;int8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;float&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;int8_t&gt;(cast&lt;int8_t&gt;(x) * (1.0f - cast&lt;float&gt;(w)) +</div>
<div class="line">               cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w))</div>
<div class="ttc" id="anamespace_halide_html_a55158f5f229510194c425dfae256d530"><div class="ttname"><a href="namespace_halide.html#a55158f5f229510194c425dfae256d530">Halide::lerp</a></div><div class="ttdeci">Expr lerp(Expr zero_val, Expr one_val, Expr weight)</div><div class="ttdoc">Linear interpolate between the two values according to a weight.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a41dd5e65a4c167c112de447c628c099a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dd5e65a4c167c112de447c628c099a">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::popcount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of set bits in an expression. </p>

</div>
</div>
<a id="a0e39642cc99af99045ec5f424cde8709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39642cc99af99045ec5f424cde8709">&#9670;&nbsp;</a></span>count_leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::count_leading_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of leading zero bits in an expression. </p>
<p>If the expression is zero, the result is the number of bits in the type. </p>

</div>
</div>
<a id="aa0042ff9c2283a15cda1a1e72de460ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0042ff9c2283a15cda1a1e72de460ad">&#9670;&nbsp;</a></span>count_trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::count_trailing_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of trailing zero bits in an expression. </p>
<p>If the expression is zero, the result is the number of bits in the type. </p>

</div>
</div>
<a id="aed6e12242ab5a192bdaa953510ae95bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e12242ab5a192bdaa953510ae95bf">&#9670;&nbsp;</a></span>div_round_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::div_round_to_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide two integers, rounding towards zero. </p>
<p>This is the typical behavior of most hardware architectures, which differs from <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s division operator, which is Euclidean (rounds towards -infinity). Will throw a runtime error if y is zero, or if y is -1 and x is the minimum signed integer. </p>

</div>
</div>
<a id="ab0456fd6414e279eb3afdecf53eb8af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0456fd6414e279eb3afdecf53eb8af8">&#9670;&nbsp;</a></span>mod_round_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::mod_round_to_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the remainder of dividing two integers, when division is rounding toward zero. </p>
<p>This is the typical behavior of most hardware architectures, which differs from <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s mod operator, which is Euclidean (produces the remainder when division rounds towards -infinity). Will throw a runtime error if y is zero. </p>

</div>
</div>
<a id="a59bd57263c72c6712b643ab6486ed026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd57263c72c6712b643ab6486ed026">&#9670;&nbsp;</a></span>random_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::random_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="struct_halide_1_1_expr.html">Expr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f). </p>
<p>For random numbers of other types, use lerp with a random float as the last parameter.</p>
<p>Optionally takes a seed.</p>
<p>Note that: </p><div class="fragment"><div class="line">Expr x = <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>();</div>
<div class="line">Expr y = x + x;</div>
<div class="ttc" id="anamespace_halide_html_a59bd57263c72c6712b643ab6486ed026"><div class="ttname"><a href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">Halide::random_float</a></div><div class="ttdeci">Expr random_float(Expr seed=Expr())</div><div class="ttdoc">Return a random variable representing a uniformly distributed float in the half-open interval [0....</div></div>
</div><!-- fragment --><p>is very different to</p>
<div class="fragment"><div class="line">Expr y = <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>() + <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>();</div>
</div><!-- fragment --><p>The first doubles a random variable, and the second adds two independent random variables.</p>
<p>A given random variable takes on a unique value that depends deterministically on the pure variables of the function they belong to, the identity of the function itself, and which definition of the function it is used in. They are, however, shared across tuple elements.</p>
<p>This function vectorizes cleanly. </p>

</div>
</div>
<a id="a160cd421537be8b4cd44fc32958604c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160cd421537be8b4cd44fc32958604c2">&#9670;&nbsp;</a></span>random_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::random_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="struct_halide_1_1_expr.html">Expr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random variable representing a uniformly distributed unsigned 32-bit integer. </p>
<p>See <a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>. Vectorizes cleanly. </p>

</div>
</div>
<a id="aaed5b59d6a43446e311633912427b2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed5b59d6a43446e311633912427b2b3">&#9670;&nbsp;</a></span>random_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::random_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="struct_halide_1_1_expr.html">Expr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random variable representing a uniformly distributed 32-bit integer. </p>
<p>See <a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>. Vectorizes cleanly. </p>

</div>
</div>
<a id="ad933f903f12d02dc4a41950751feb8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad933f903f12d02dc4a41950751feb8f9">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints out its value whenever it is evaluated. </p>
<p>It also prints out everything else in the arguments list, separated by spaces. This can include string literals. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a2">tutorial/lesson_04_debugging_2.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01247">print()</a>.</p>

</div>
</div>
<a id="abb98ec9f8091af1beca6d93e9a95f23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb98ec9f8091af1beca6d93e9a95f23a">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01247">1247</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00311">Halide::Internal::collect_print_args()</a>, and <a class="el" href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">print()</a>.</p>

</div>
</div>
<a id="a452ed699c61260cc230629777fc9cafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452ed699c61260cc230629777fc9cafa">&#9670;&nbsp;</a></span>print_when() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print_when </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints whenever it is evaluated, provided that the condition is true. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a3">tutorial/lesson_04_debugging_2.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01260">print_when()</a>.</p>

</div>
</div>
<a id="abc63366304ec6c0d67fd89fc6d985f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc63366304ec6c0d67fd89fc6d985f34">&#9670;&nbsp;</a></span>print_when() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print_when </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01260">1260</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00311">Halide::Internal::collect_print_args()</a>, and <a class="el" href="namespace_halide.html#a452ed699c61260cc230629777fc9cafa">print_when()</a>.</p>

</div>
</div>
<a id="ac350d72e774314bb32beeb718d53c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac350d72e774314bb32beeb718d53c09e">&#9670;&nbsp;</a></span>require() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that guarantees a precondition. </p>
<p>If 'condition' is true, the return value is equal to the first <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. If 'condition' is false, <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8" title="Halide calls this function on runtime errors (for example bounds checking failures).">halide_error()</a> is called, and the return value is arbitrary. Any additional arguments after the first <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> are stringified and passed as a user-facing message to <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8" title="Halide calls this function on runtime errors (for example bounds checking failures).">halide_error()</a>, similar to <a class="el" href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9" title="Create an Expr that prints out its value whenever it is evaluated.">print()</a>.</p>
<p>Note that this essentially <em>always</em> inserts a runtime check into the generated code (except when the condition can be proven at compile time); as such, it should be avoided inside inner loops, except for debugging or testing purposes. Note also that it does not vectorize cleanly (vector values will be scalarized for the check).</p>
<p>However, using this to make assertions about (say) input values can be useful, both in terms of correctness and (potentially) in terms of code generation, e.g. </p><div class="fragment"><div class="line">Param&lt;int&gt; p;</div>
<div class="line">Expr y = <a class="code" href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">require</a>(p &gt; 0, p);</div>
<div class="ttc" id="anamespace_halide_html_ac350d72e774314bb32beeb718d53c09e"><div class="ttname"><a href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">Halide::require</a></div><div class="ttdeci">Expr require(Expr condition, const std::vector&lt; Expr &gt; &amp;values)</div><div class="ttdoc">Create an Expr that that guarantees a precondition.</div></div>
</div><!-- fragment --><p> will allow the optimizer to assume positive, nonzero values for y. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01293">require()</a>.</p>

</div>
</div>
<a id="a0298ea2955b3ed763e7bfca9f5b805ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0298ea2955b3ed763e7bfca9f5b805ea">&#9670;&nbsp;</a></span>require() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01293">1293</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00311">Halide::Internal::collect_print_args()</a>, and <a class="el" href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">require()</a>.</p>

</div>
</div>
<a id="a9389bcacbed602df70eae94826312e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9389bcacbed602df70eae94826312e03">&#9670;&nbsp;</a></span>undef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::undef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an undef value of the given type. </p>
<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> skips stores that depend on undef values, so you can use this to mean "do not modify
this memory location". This is an escape hatch that can be used for several things:</p>
<p>You can define a reduction with no pure step, by setting the pure step to undef. Do this only if you're confident that the update steps are sufficient to correctly fill in the domain.</p>
<p>For a tuple-valued reduction, you can write an update step that only updates some tuple elements.</p>
<p>You can define single-stage pipeline that only has update steps, and depends on the values already in the output buffer.</p>
<p>Use this feature with great caution, as you can use it to load from uninitialized memory. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01321">undef()</a>.</p>

</div>
</div>
<a id="a4f29c5417077b940483e88cc9c1c74b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f29c5417077b940483e88cc9c1c74b2">&#9670;&nbsp;</a></span>undef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::undef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01321">1321</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">undef()</a>.</p>

</div>
</div>
<a id="a0c61f9a3eb7d89644951cf835ade09fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c61f9a3eb7d89644951cf835ade09fa">&#9670;&nbsp;</a></span>memoize_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::memoize_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control the values used in the memoization cache key for memoize. </p>
<p>Normally parameters and other external dependencies are automatically inferred and added to the cache key. The memoize_tag operator allows computing one expression and using either the computed value, or one or more other expressions in the cache key instead of the parameter dependencies of the computation. The single argument version is completely safe in that the cache key will use the actual computed value &ndash; it is difficult or imposible to produce erroneous caching this way. The more-than-one argument version allows generating cache keys that do not uniquely identify the computation and thus can result in caching errors.</p>
<p>A potential use for the single argument version is to handle a floating-point parameter that is quantized to a small integer. Mutliple values of the float will produce the same integer and moving the caching to using the integer for the key is more efficient.</p>
<p>The main use for the more-than-one argument version is to provide cache key information for Handles and ImageParams, which otherwise are not allowed inside compute_cached operations. E.g. when passing a group of parameters to an external array function via a Handle, memoize_tag can be used to isolate the actual values used by that computation. If an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> is a constant image with a persistent digest, memoize_tag can be used to key computations using that image on the digest. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01353">1353</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a082d3bda0d60128ae127d0879e7e38c9">Halide::Internal::memoize_tag_helper()</a>.</p>

</div>
</div>
<a id="afbf18e1b8bab056f8f8e8f1af8cbd764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf18e1b8bab056f8f8e8f1af8cbd764">&#9670;&nbsp;</a></span>likely()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::likely </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g. </p>
<p>a boundary condition). When <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> encounters likely intrinsics, it splits the containing loop body into three, and tries to simplify down all conditions that lead to the likely. For example, given the expression: select(x &lt; 1, bar, x &gt; 10, bar, likely(foo)), <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> will split the loop over x into portions where x &lt; 1, 1 &lt;= x &lt;= 10, and x &gt; 10.</p>
<p>You're unlikely to want to call this directly. You probably want to use the boundary condition helpers in the <a class="el" href="namespace_halide_1_1_boundary_conditions.html" title="namespace to hold functions for imposing boundary conditions on Halide Funcs.">BoundaryConditions</a> namespace instead. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="acc3a484f14e9bdf4c7b4e16d74fe11ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3a484f14e9bdf4c7b4e16d74fe11ab">&#9670;&nbsp;</a></span>likely_if_innermost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::likely_if_innermost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a57a635db3b781aded60c79533001b9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a635db3b781aded60c79533001b9e1">&#9670;&nbsp;</a></span>saturating_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::saturating_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast an expression to the halide type corresponding to the C++ type T. </p>
<p>As part of the cast, clamp to the minimum and maximum values of the result type. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01382">1382</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_concise_casts_8h_source.html#l00083">Halide::ConciseCasts::i16_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00093">Halide::ConciseCasts::i32_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00103">Halide::ConciseCasts::i64_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00073">Halide::ConciseCasts::i8_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00088">Halide::ConciseCasts::u16_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00098">Halide::ConciseCasts::u32_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00108">Halide::ConciseCasts::u64_sat()</a>, and <a class="el" href="_concise_casts_8h_source.html#l00078">Halide::ConciseCasts::u8_sat()</a>.</p>

</div>
</div>
<a id="abe60c27f54efe535f84d7f94ce61c053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe60c27f54efe535f84d7f94ce61c053">&#9670;&nbsp;</a></span>saturating_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::saturating_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast an expression to a new type, clamping to the minimum and maximum values of the result type. </p>

</div>
</div>
<a id="ab2ccca78986958e405d34f08f41a103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ccca78986958e405d34f08f41a103a">&#9670;&nbsp;</a></span>strict_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::strict_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a best effort attempt to preserve IEEE floating-point semantics in evaluating an expression. </p>
<p>May not be implemented for all backends. (E.g. it is difficult to do this for C++ code generation as it depends on the compiler flags used to compile the generated code. </p>

</div>
</div>
<a id="a5f11f05c5df67082747354f264d30f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f11f05c5df67082747354f264d30f17">&#9670;&nbsp;</a></span>unsafe_promise_clamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::unsafe_promise_clamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that promises another <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> is clamped but do not generate code to check the assertion or modify the value. </p>
<p>No attempt is made to prove the bound at compile time. (If it is proved false as a result of something else, an error might be generated, but it is also possible the compiler will crash.) The promised bound is used in bounds inference so it will allow satisfying bounds checks as well as possibly aiding optimization.</p>
<p>unsafe_promise_clamped returns its first argument, the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> 'value'</p>
<p>This is a very easy way to make <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> generate erroneous code if the bound promises is not kept. Use sparingly when there is no other way to convey the information to the compiler and it is required for a valuable optimization.</p>
<p>Unsafe promises can be checked by turning on <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa067b0eb1f99b6ad38c8d8489458bd547">Target::CheckUnsafePromises</a>. This is intended for debugging only. </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="aa0498c6cada8da13d05bf285a813d16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0498c6cada8da13d05bf285a813d16d">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::scatter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatter and gather are used for update definition which must store multiple values to distinct locations at the same time. </p>
<p>The multiple expressions on the right-hand-side are bundled together into a "gather", which must match a "scatter" the the same number of arguments on the left-hand-size. For example, to store the values 1 and 2 to the locations (x, y, 3) and (x, y, 4), respectively:</p>
<div class="fragment"><div class="line">f(x, y, <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(3, 4)) = <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(1, 2);</div>
<div class="ttc" id="anamespace_halide_html_a435458ed41a7427361761df8b62fc047"><div class="ttname"><a href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">Halide::gather</a></div><div class="ttdeci">Expr gather(const std::vector&lt; Expr &gt; &amp;args)</div></div>
<div class="ttc" id="anamespace_halide_html_aa0498c6cada8da13d05bf285a813d16d"><div class="ttname"><a href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">Halide::scatter</a></div><div class="ttdeci">Expr scatter(const std::vector&lt; Expr &gt; &amp;args)</div><div class="ttdoc">Scatter and gather are used for update definition which must store multiple values to distinct locati...</div></div>
</div><!-- fragment --><p>The result of gather or scatter can be treated as an expression. Any containing operations on it can be assumed to distribute over the elements. If two gather expressions are combined with an arithmetic operator (e.g. added), they combine element-wise. The following example stores the values 2 * x, 2 * y, and 2 * c to the locations (x + 1, y, c), (x, y + 3, c), and (x, y, c + 2) respectively:</p>
<div class="fragment"><div class="line">f(x + <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(1, 0, 0), y + <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(0, 3, 0), c + <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(0, 0, 2)) = 2 * <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(x, y, c);</div>
</div><!-- fragment --><p>Repeated values in the scatter cause multiple stores to the same location. The stores happen in order from left to right, so the rightmost value wins. The following code is equivalent to f(x) = 5</p>
<div class="fragment"><div class="line">f(<a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(x, x)) = <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(3, 5);</div>
</div><!-- fragment --><p>Gathers are most useful for algorithms which require in-place swapping or permutation of multiple elements, or other kinds of in-place mutations that require loading multiple inputs, doing some operations to them jointly, then storing them again. The following update definition swaps the values of f at locations 3 and 5 if an input parameter p is true:</p>
<div class="fragment"><div class="line">f(<a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(3, 5)) = f(<a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(p, <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(5, 3), <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(3, 5)));</div>
<div class="ttc" id="anamespace_halide_html_a9d6371892ae38e7eb681fd3f23945b06"><div class="ttname"><a href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a></div><div class="ttdeci">Expr select(Expr condition, Expr true_value, Expr false_value)</div><div class="ttdoc">Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...</div></div>
</div><!-- fragment --><p>For more examples of the use of scatter and gather, see test/correctness/multiple_scatter.cpp</p>
<p>It is not currently possible to use scatter and gather to write an update definition in which the <em>number</em> of values loaded or stored varies, as the size of the scatter/gather packet must be fixed a compile-time. A workaround is to make the unwanted extra operations a redundant copy of the last operation, which will be dead-code-eliminated by the compiler. For example, the following update definition swaps the values at locations 3 and 5 when the parameter p is true, and rotates the values at locations 1, 2, and 3 when it is false. The load from 3 and store to 5 will be redundantly repeated:</p>
<div class="fragment"><div class="line">f(<a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(p, <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(3, 5, 5), <a class="code" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter</a>(1, 2, 3))) = f(<a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a>(p, <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(5, 3, 3), <a class="code" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather</a>(2, 3, 1)));</div>
</div><!-- fragment --><p>Note that in the p == true case, we redudantly load from 3 and write to 5 twice. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01505">scatter()</a>.</p>

</div>
</div>
<a id="a435458ed41a7427361761df8b62fc047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435458ed41a7427361761df8b62fc047">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::gather </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01510">gather()</a>.</p>

</div>
</div>
<a id="a035edd08e7ece3238ce2fa5ede9d8eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035edd08e7ece3238ce2fa5ede9d8eb7">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::scatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01505">1505</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">scatter()</a>.</p>

</div>
</div>
<a id="a7e82c6354cdd3a95aa207291ca15522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e82c6354cdd3a95aa207291ca15522b">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::gather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01510">1510</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">gather()</a>.</p>

</div>
</div>
<a id="a2a6246c45e7f5c10b2c8182407d5ba17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6246c45e7f5c10b2c8182407d5ba17">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide device api type in human-readable form. </p>

</div>
</div>
<a id="a9d6f8beae5821f95bbba90792d937970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6f8beae5821f95bbba90792d937970">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide memory type in human-readable form. </p>

</div>
</div>
<a id="a9776f81e1a9f3bb14ae9c75aec1f0965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9776f81e1a9f3bb14ae9c75aec1f0965">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide tail strategy in human-readable form. </p>

</div>
</div>
<a id="afa3765573080d05859d10c3ca8c83e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3765573080d05859d10c3ca8c83e18">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a> in human-readable form. </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="ad059dd67c80872feb005e9d52c3a15d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad059dd67c80872feb005e9d52c3a15d1">&#9670;&nbsp;</a></span>lambda() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a zero-dimensional halide function that returns the given expression. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00070">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a id="a6582ef6cc86eb071f7805a56aca29b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ef6cc86eb071f7805a56aca29b03">&#9670;&nbsp;</a></span>lambda() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 1-D halide function in the first argument that returns the second argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> arguments contains a placeholder ("_"). </p>

</div>
</div>
<a id="af7585838cf49ace5557096df29377510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7585838cf49ace5557096df29377510">&#9670;&nbsp;</a></span>lambda() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 2-D halide function in the first two arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> arguments contains a placeholder ("_"). </p>

</div>
</div>
<a id="a62749bb94be1fd67800ab967c000f3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62749bb94be1fd67800ab967c000f3ad">&#9670;&nbsp;</a></span>lambda() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 3-D halide function in the first three arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> arguments contains a placeholder ("_"). </p>

</div>
</div>
<a id="a992c3a587f783919c6a0ac1dd9a132fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992c3a587f783919c6a0ac1dd9a132fe">&#9670;&nbsp;</a></span>lambda() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 4-D halide function in the first four arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> arguments contains a placeholder ("_"). </p>

</div>
</div>
<a id="a0ca087d4cae6b284a1c40caecdd5361a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca087d4cae6b284a1c40caecdd5361a">&#9670;&nbsp;</a></span>lambda() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 5-D halide function in the first five arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> arguments contains a placeholder ("_"). </p>

</div>
</div>
<a id="a50ab8a65be814772d7be2b7a724fd125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ab8a65be814772d7be2b7a724fd125">&#9670;&nbsp;</a></span>compile_module_to_llvm_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::compile_module_to_llvm_module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an LLVM module. </p>

</div>
</div>
<a id="ac6e16a74bdfa8d1b76a27bd67398ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e16a74bdfa8d1b76a27bd67398ec48">&#9670;&nbsp;</a></span>make_raw_fd_ostream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::raw_fd_ostream&gt; Halide::make_raw_fd_ostream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an llvm output stream for writing to files. </p>

</div>
</div>
<a id="aa4edc7d7f9c03823de1140f647541ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4edc7d7f9c03823de1140f647541ed8">&#9670;&nbsp;</a></span>compile_llvm_module_to_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_llvm_module_to_object </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to native targets (objects, native assembly). </p>

</div>
</div>
<a id="a9675efb52f754f47b531e86547dcc669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9675efb52f754f47b531e86547dcc669">&#9670;&nbsp;</a></span>compile_llvm_module_to_assembly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_llvm_module_to_assembly </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab518840a992e5d9f7aa93a85d9d8054d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab518840a992e5d9f7aa93a85d9d8054d">&#9670;&nbsp;</a></span>compile_llvm_module_to_llvm_bitcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_llvm_module_to_llvm_bitcode </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to LLVM targets (bitcode, LLVM assembly). </p>

</div>
</div>
<a id="a69b4c504c70bbdde213d0f787c721f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b4c504c70bbdde213d0f787c721f20">&#9670;&nbsp;</a></span>compile_llvm_module_to_llvm_assembly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_llvm_module_to_llvm_assembly </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Internal::LLVMOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b55d90043852c79eb873c1dec3590b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b55d90043852c79eb873c1dec3590b">&#9670;&nbsp;</a></span>create_static_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::create_static_library </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dst_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the list of src_files into dst_file, using the appropriate static library format for the given target (e.g., .a or .lib). </p>
<p>If deterministic is true, emit 0 for all GID/UID/timestamps, and 0644 for all modes (equivalent to the ar -D option). </p>

</div>
</div>
<a id="af69f589a059692f84a1a3d1fe8056df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69f589a059692f84a1a3d1fe8056df5">&#9670;&nbsp;</a></span>link_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_module.html">Module</a> Halide::link_modules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_module.html">Module</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a set of modules together into one module. </p>

</div>
</div>
<a id="aa4b41a54a453737dcdd34e6d1058353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b41a54a453737dcdd34e6d1058353f">&#9670;&nbsp;</a></span>compile_standalone_runtime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_standalone_runtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object file containing the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime for a given target. </p>
<p>For use with <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b">Target::NoRuntime</a>. Standalone runtimes are only compatible with pipelines compiled by the same build of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> used to call this function. </p>

</div>
</div>
<a id="a04de7316843ac7c1a0a0126228caab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04de7316843ac7c1a0a0126228caab32">&#9670;&nbsp;</a></span>compile_standalone_runtime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string&gt; Halide::compile_standalone_runtime </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object and/or static library file containing the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> runtime for a given target. </p>
<p>For use with <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b">Target::NoRuntime</a>. Standalone runtimes are only compatible with pipelines compiled by the same build of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> used to call this function. Return a map with just the actual outputs filled in (typically, <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4aa8cfde6331bd59eb2ac96f8911c4b666">Output::object</a> and/or <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a1c1bec5ce39d59c7ef87be64f7d41a9e">Output::static_library</a>). </p>

</div>
</div>
<a id="a7c901cdbf0e9c7ffac2226b078a579ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c901cdbf0e9c7ffac2226b078a579ae">&#9670;&nbsp;</a></span>compile_multitarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::compile_multitarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>suffixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#afe643966574f0ad69cad7f936c086740">ModuleFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>module_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a6e2a7a400cd68d41f2868eebb762c32e">CompilerLoggerFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>compiler_logger_factory</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada8877b8b863a6b16d6ff13e196ec457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8877b8b863a6b16d6ff13e196ec457">&#9670;&nbsp;</a></span>user_context_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::user_context_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> corresponding to the user context passed to the function (if any). </p>
<p>It is rare that this function is necessary (e.g. to pass the user context to an extern function written in C). </p>

<p class="definition">Definition at line <a class="el" href="_param_8h_source.html#l00295">295</a> of file <a class="el" href="_param_8h_source.html">Param.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00523">Handle()</a>, and <a class="el" href="_i_r_8h_source.html#l00689">Halide::Internal::Variable::make()</a>.</p>

</div>
</div>
<a id="a4a59ae3e07905e1b92d87a1ec835b77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a59ae3e07905e1b92d87a1ec835b77f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in a human-readable form. </p>

</div>
</div>
<a id="a190e59daf23cf2899dd676749a8742cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190e59daf23cf2899dd676749a8742cc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> in a human-readable form. </p>

</div>
</div>
<a id="a0ae94266acfeba1bce3298e333ba4b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae94266acfeba1bce3298e333ba4b8c">&#9670;&nbsp;</a></span>get_host_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_host_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target corresponding to the host machine. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a2">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00065">Halide::SimdOpCheckTest::can_run_code()</a>.</p>

</div>
</div>
<a id="ab25236e75d4d73bee045028da680215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25236e75d4d73bee045028da680215d">&#9670;&nbsp;</a></span>get_target_from_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_target_from_environment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> will use. </p>
<p>If HL_TARGET is set it uses that. Otherwise calls <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c">get_host_target</a> </p>

</div>
</div>
<a id="a9d2cf046902155db63e83374f23a47b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2cf046902155db63e83374f23a47b5">&#9670;&nbsp;</a></span>get_jit_target_from_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_jit_target_from_environment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target that <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> will use for jit-compilation. </p>
<p>If HL_JIT_TARGET is set it uses that. Otherwise calls <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c">get_host_target</a>. Throws an error if the architecture, bit width, and OS of the target do not match the host target, so this is only useful for controlling the feature set. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02510">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a id="a8ab19de8fa28eb2396a0b8d40c338491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab19de8fa28eb2396a0b8d40c338491">&#9670;&nbsp;</a></span>target_feature_for_device_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a> Halide::target_feature_for_device_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> feature corresponding to a DeviceAPI. </p>
<p>For device apis that do not correspond to any single target feature, returns <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">Target::FeatureEnd</a> </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<a id="a70a0c034814a65d55bb848fe9c96653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a0c034814a65d55bb848fe9c96653b">&#9670;&nbsp;</a></span>Int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing a signed integer type. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a1">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00498">498</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00277">Halide::Type::Int</a>.</p>

<p class="reference">Referenced by <a class="el" href="_concise_casts_8h_source.html#l00043">Halide::ConciseCasts::i16()</a>, <a class="el" href="_concise_casts_8h_source.html#l00083">Halide::ConciseCasts::i16_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00038">Halide::ConciseCasts::i32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00093">Halide::ConciseCasts::i32_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00033">Halide::ConciseCasts::i64()</a>, <a class="el" href="_concise_casts_8h_source.html#l00103">Halide::ConciseCasts::i64_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00048">Halide::ConciseCasts::i8()</a>, <a class="el" href="_concise_casts_8h_source.html#l00073">Halide::ConciseCasts::i8_sat()</a>, and <a class="el" href="_generator_8h_source.html#l02949">Halide::NamesInterface::Int()</a>.</p>

</div>
</div>
<a id="a0eb5f455b5c4bce0c54575bc67bf9599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb5f455b5c4bce0c54575bc67bf9599">&#9670;&nbsp;</a></span>UInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::UInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing an unsigned integer type. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a0">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00503">503</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00278">Halide::Type::UInt</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_8h_source.html#l00518">Bool()</a>, <a class="el" href="_concise_casts_8h_source.html#l00063">Halide::ConciseCasts::u16()</a>, <a class="el" href="_concise_casts_8h_source.html#l00088">Halide::ConciseCasts::u16_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00058">Halide::ConciseCasts::u32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00098">Halide::ConciseCasts::u32_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00053">Halide::ConciseCasts::u64()</a>, <a class="el" href="_concise_casts_8h_source.html#l00108">Halide::ConciseCasts::u64_sat()</a>, <a class="el" href="_concise_casts_8h_source.html#l00068">Halide::ConciseCasts::u8()</a>, <a class="el" href="_concise_casts_8h_source.html#l00078">Halide::ConciseCasts::u8_sat()</a>, and <a class="el" href="_generator_8h_source.html#l02952">Halide::NamesInterface::UInt()</a>.</p>

</div>
</div>
<a id="a11df91175e8ac20ce33379c178e8c7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11df91175e8ac20ce33379c178e8c7bc">&#9670;&nbsp;</a></span>Float()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Float </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a floating-point type. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a2">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00508">508</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00279">Halide::Type::Float</a>.</p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00164">Halide::SimdOpCheckTest::check_one()</a>, <a class="el" href="_concise_casts_8h_source.html#l00023">Halide::ConciseCasts::f32()</a>, <a class="el" href="_concise_casts_8h_source.html#l00018">Halide::ConciseCasts::f64()</a>, and <a class="el" href="_generator_8h_source.html#l02946">Halide::NamesInterface::Float()</a>.</p>

</div>
</div>
<a id="a0e0f7fe222498c37bde1eaa2c771fb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7fe222498c37bde1eaa2c771fb0c">&#9670;&nbsp;</a></span>BFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::BFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a floating-point type in the bfloat format. </p>
<p>Only 16-bit currently supported. </p>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00513">513</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00280">Halide::Type::BFloat</a>.</p>

<p class="reference">Referenced by <a class="el" href="_concise_casts_8h_source.html#l00028">Halide::ConciseCasts::bf16()</a>.</p>

</div>
</div>
<a id="ad26cb40c3218a0e075879e44374a4d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26cb40c3218a0e075879e44374a4d9d">&#9670;&nbsp;</a></span>Bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Bool </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a boolean type. </p>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00518">518</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00503">UInt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l02943">Halide::NamesInterface::Bool()</a>.</p>

</div>
</div>
<a id="a92e876323440c13edf4fa63112050c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e876323440c13edf4fa63112050c8d">&#9670;&nbsp;</a></span>Handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Handle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__handle__cplusplus__type.html">halide_handle_cplusplus_type</a> *&#160;</td>
          <td class="paramname"><em>handle_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a handle type. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a3">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00523">523</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00281">Halide::Type::Handle</a>.</p>

<p class="reference">Referenced by <a class="el" href="_param_8h_source.html#l00295">user_context_value()</a>.</p>

</div>
</div>
<a id="a230bbc98235cdeaea250aa9ab19f3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230bbc98235cdeaea250aa9ab19f3312">&#9670;&nbsp;</a></span>type_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::type_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the halide equivalent of a C type. </p>

<p class="definition">Definition at line <a class="el" href="_type_8h_source.html#l00529">529</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<a id="a0834f79e4ba8398f31f2512cd4949ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0834f79e4ba8398f31f2512cd4949ab3">&#9670;&nbsp;</a></span>type_to_c_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::type_to_c_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c_plus_plus</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> type to a C++ type. </p>

</div>
</div>
<a id="abdb3bac86d5020a2fc5c0fad5eba8592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb3bac86d5020a2fc5c0fad5eba8592">&#9670;&nbsp;</a></span>load_plugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::load_plugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lib_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a plugin in the form of a dynamic library (e.g. </p>
<p>for custom autoschedulers). If the string doesn't contain any . characters, the proper prefix and/or suffix for the platform will be added:</p>
<p>foo -&gt; libfoo.so (Linux/OSX/etc &ndash; note that .dylib is not supported) foo -&gt; foo.dll (Windows)</p>
<p>otherwise, it is assumed to be an appropriate pathname.</p>
<p>Any error in loading will assert-fail. </p>

<p class="reference">References <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Internal</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aab7e8f5756fe34d428d6c70095cdcf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7e8f5756fe34d428d6c70095cdcf8b">&#9670;&nbsp;</a></span>head1_channels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::head1_channels = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00007">7</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="aa373ab31181627dc3ed16ac676e561a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa373ab31181627dc3ed16ac676e561a8">&#9670;&nbsp;</a></span>head1_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::head1_w = 40</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00007">7</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="aee8790329f3be3d6c675a7868c944311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8790329f3be3d6c675a7868c944311">&#9670;&nbsp;</a></span>head1_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::head1_h = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00007">7</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="a93bf8c7312090d7f312590aec7192719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bf8c7312090d7f312590aec7192719">&#9670;&nbsp;</a></span>head2_channels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::head2_channels = 24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00008">8</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="a1660f1a4cc56d0271d2942ce9437ec8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1660f1a4cc56d0271d2942ce9437ec8c">&#9670;&nbsp;</a></span>head2_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::head2_w = 39</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00008">8</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="abde902a9d2b5fae2afad7f7b7edb1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde902a9d2b5fae2afad7f7b7edb1c9c">&#9670;&nbsp;</a></span>conv1_channels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Halide::conv1_channels = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_network_size_8h_source.html#l00009">9</a> of file <a class="el" href="_network_size_8h_source.html">NetworkSize.h</a>.</p>

</div>
</div>
<a id="abeae4f594180635f1a0a60c0dac5fe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeae4f594180635f1a0a60c0dac5fe72">&#9670;&nbsp;</a></span>all_device_apis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> Halide::all_device_apis[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<a class="code" href="namespace_message.html#ac596fe2a096add77b8b174a80c897b51a824daf8c4b37888639211f3b023c526e">DeviceAPI::None</a>,</div>
<div class="line">                                     DeviceAPI::Host,</div>
<div class="line">                                     DeviceAPI::Default_GPU,</div>
<div class="line">                                     DeviceAPI::CUDA,</div>
<div class="line">                                     DeviceAPI::OpenCL,</div>
<div class="line">                                     DeviceAPI::OpenGLCompute,</div>
<div class="line">                                     DeviceAPI::Metal,</div>
<div class="line">                                     DeviceAPI::Hexagon,</div>
<div class="line">                                     DeviceAPI::HexagonDma,</div>
<div class="line">                                     DeviceAPI::D3D12Compute}</div>
<div class="ttc" id="anamespace_message_html_ac596fe2a096add77b8b174a80c897b51a824daf8c4b37888639211f3b023c526e"><div class="ttname"><a href="namespace_message.html#ac596fe2a096add77b8b174a80c897b51a824daf8c4b37888639211f3b023c526e">Message::None</a></div><div class="ttdeci">@ None</div><div class="ttdef"><b>Definition:</b> <a href="sim__protocol_8h_source.html#l00006">sim_protocol.h:6</a></div></div>
</div><!-- fragment -->
<p>An array containing all the device apis. </p>
<p>Useful for iterating through them. </p>

<p class="definition">Definition at line <a class="el" href="_device_a_p_i_8h_source.html#l00030">30</a> of file <a class="el" href="_device_a_p_i_8h_source.html">DeviceAPI.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
