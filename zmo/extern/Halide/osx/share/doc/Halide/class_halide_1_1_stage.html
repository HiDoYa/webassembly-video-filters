<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Stage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_halide_1_1_stage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_stage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Stage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  
 <a href="class_halide_1_1_stage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91222724ee6ff9f4d01dcb4f836d7627"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a91222724ee6ff9f4d01dcb4f836d7627">Stage</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> f, <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a> d, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> stage_index)</td></tr>
<tr class="separator:a91222724ee6ff9f4d01dcb4f836d7627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3c9b2dcfcf060e53c38a6c99196312"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aac3c9b2dcfcf060e53c38a6c99196312">get_schedule</a> () const</td></tr>
<tr class="memdesc:aac3c9b2dcfcf060e53c38a6c99196312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>.  <a href="class_halide_1_1_stage.html#aac3c9b2dcfcf060e53c38a6c99196312">More...</a><br /></td></tr>
<tr class="separator:aac3c9b2dcfcf060e53c38a6c99196312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae73b461d876d4d921474d5042dad65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aeae73b461d876d4d921474d5042dad65">dump_argument_list</a> () const</td></tr>
<tr class="memdesc:aeae73b461d876d4d921474d5042dad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing the current var list taking into account all the splits, reorders, and tiles.  <a href="class_halide_1_1_stage.html#aeae73b461d876d4d921474d5042dad65">More...</a><br /></td></tr>
<tr class="separator:aeae73b461d876d4d921474d5042dad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075401098fc0eb3fa260bbb93a21e80b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a075401098fc0eb3fa260bbb93a21e80b">name</a> () const</td></tr>
<tr class="memdesc:a075401098fc0eb3fa260bbb93a21e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this stage, e.g.  <a href="class_halide_1_1_stage.html#a075401098fc0eb3fa260bbb93a21e80b">More...</a><br /></td></tr>
<tr class="separator:a075401098fc0eb3fa260bbb93a21e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7936287327b4627008fc723cb42565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565">rfactor</a> (std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&gt; preserved)</td></tr>
<tr class="memdesc:a9a7936287327b4627008fc723cb42565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling <a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results.  <a href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565">More...</a><br /></td></tr>
<tr class="separator:a9a7936287327b4627008fc723cb42565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a2ad5f03630fb3fd72a3ab0b0563502cc">rfactor</a> (const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;r, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;v)</td></tr>
<tr class="separator:a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a2ae25a009d6a2d52cb407a25f0a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a82a2ae25a009d6a2d52cb407a25f0a5b">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt;&gt; &amp;align)</td></tr>
<tr class="memdesc:a82a2ae25a009d6a2d52cb407a25f0a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <a href="class_halide_1_1_stage.html#a82a2ae25a009d6a2d52cb407a25f0a5b">More...</a><br /></td></tr>
<tr class="separator:a82a2ae25a009d6a2d52cb407a25f0a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2f0765c15be29838716e05bf1fb982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a4c2f0765c15be29838716e05bf1fb982">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a4c2f0765c15be29838716e05bf1fb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba830a3b12b42b41b27f6ce40eafd56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aba830a3b12b42b41b27f6ce40eafd56e">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt;&gt; &amp;align)</td></tr>
<tr class="separator:aba830a3b12b42b41b27f6ce40eafd56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353ef98b0f00d6f0e5dac7d00f3e70f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a353ef98b0f00d6f0e5dac7d00f3e70f8">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a353ef98b0f00d6f0e5dac7d00f3e70f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913f861d2503d5e5064986ec182058c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a8913f861d2503d5e5064986ec182058c">split</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:a8913f861d2503d5e5064986ec182058c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this stage is traversed.  <a href="class_halide_1_1_stage.html#a8913f861d2503d5e5064986ec182058c">More...</a><br /></td></tr>
<tr class="separator:a8913f861d2503d5e5064986ec182058c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e29492266ca6c310199a0ba1b0c2c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a8e29492266ca6c310199a0ba1b0c2c41">fuse</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;fused)</td></tr>
<tr class="separator:a8e29492266ca6c310199a0ba1b0c2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bfef1fe10b032d1de620d1a1cd5595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a58bfef1fe10b032d1de620d1a1cd5595">serial</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a58bfef1fe10b032d1de620d1a1cd5595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a20ebb93c034853cff3b71923abf21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a54a20ebb93c034853cff3b71923abf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f0b592c62bbee9f3f49656a155609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a3c5f0b592c62bbee9f3f49656a155609">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a3c5f0b592c62bbee9f3f49656a155609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542316d98c5b1712b257fd5590feb65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a542316d98c5b1712b257fd5590feb65c">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a542316d98c5b1712b257fd5590feb65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58b64fe09f4661655bbbee9967f1d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aa58b64fe09f4661655bbbee9967f1d08">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;task_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:aa58b64fe09f4661655bbbee9967f1d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d9a594f357eecdd21cf50c0f3d974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a930d9a594f357eecdd21cf50c0f3d974">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a930d9a594f357eecdd21cf50c0f3d974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace303100816b64335dc83ba27847e220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ace303100816b64335dc83ba27847e220">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:ace303100816b64335dc83ba27847e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864aefe1080e5fca80ac6adf52ed81a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a864aefe1080e5fca80ac6adf52ed81a0">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a864aefe1080e5fca80ac6adf52ed81a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba48ef5a0ea11558791e7647f713175c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aba48ef5a0ea11558791e7647f713175c">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:aba48ef5a0ea11558791e7647f713175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a4515e3c5d7a64816745227dbd6576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a65a4515e3c5d7a64816745227dbd6576">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;tails)</td></tr>
<tr class="separator:a65a4515e3c5d7a64816745227dbd6576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144dcc2a136f8710a63deb2ec450fcbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a144dcc2a136f8710a63deb2ec450fcbd">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a144dcc2a136f8710a63deb2ec450fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999ec25e6ecff8b5baac901e8a2ef6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab999ec25e6ecff8b5baac901e8a2ef6e">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:ab999ec25e6ecff8b5baac901e8a2ef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5287af97a9cc189e2c4b0ee902664df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab5287af97a9cc189e2c4b0ee902664df">reorder</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="separator:ab5287af97a9cc189e2c4b0ee902664df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b2b511c53ee05f1dad5880e9705837"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a17b2b511c53ee05f1dad5880e9705837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a17b2b511c53ee05f1dad5880e9705837">reorder</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a17b2b511c53ee05f1dad5880e9705837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a14b3cbe0ee18c49ce592ed42c5ef42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a0a14b3cbe0ee18c49ce592ed42c5ef42">rename</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old_name, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;new_name)</td></tr>
<tr class="separator:a0a14b3cbe0ee18c49ce592ed42c5ef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a7d8e12da382c2be8cfd512de0b5ddb36">specialize</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;condition)</td></tr>
<tr class="separator:a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99d85e44a0ea26a885216a6d722019c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab99d85e44a0ea26a885216a6d722019c">specialize_fail</a> (const std::string &amp;message)</td></tr>
<tr class="separator:ab99d85e44a0ea26a885216a6d722019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc5c05a0cb888d0285f478c84852d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#adcc5c05a0cb888d0285f478c84852d5b">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:adcc5c05a0cb888d0285f478c84852d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da38352750be6ba5c4864f7d913dc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a0da38352750be6ba5c4864f7d913dc5f">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a0da38352750be6ba5c4864f7d913dc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e80da8d383b17c21a976c1403fb3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab9e80da8d383b17c21a976c1403fb3f8">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ab9e80da8d383b17c21a976c1403fb3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae300f9cd0344c82615b920ec0c6059b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ae300f9cd0344c82615b920ec0c6059b7">gpu_lanes</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ae300f9cd0344c82615b920ec0c6059b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc29c71614cf2cdaafddfb2599d4b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a3dc29c71614cf2cdaafddfb2599d4b69">gpu_single_thread</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a3dc29c71614cf2cdaafddfb2599d4b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b3e4e509dcd5fa865ba05b2c9fd892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab7b3e4e509dcd5fa865ba05b2c9fd892">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ab7b3e4e509dcd5fa865ba05b2c9fd892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df65a56291dbc4edb2ebe359777b7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab7df65a56291dbc4edb2ebe359777b7f">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ab7df65a56291dbc4edb2ebe359777b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b18139a04675a2dc642e73b614e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aab2b18139a04675a2dc642e73b614e8c">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aab2b18139a04675a2dc642e73b614e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca138c9aa879cf72f64465b689ce9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a1ca138c9aa879cf72f64465b689ce9a8">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1ca138c9aa879cf72f64465b689ce9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124339212273ac6a3e057fed4ec56fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a124339212273ac6a3e057fed4ec56fc9">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a124339212273ac6a3e057fed4ec56fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12208751766b0eb44810fe5dab82979e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a12208751766b0eb44810fe5dab82979e">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a12208751766b0eb44810fe5dab82979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe4246877d8a18e28b358e2322b5d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5fe4246877d8a18e28b358e2322b5d83">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a5fe4246877d8a18e28b358e2322b5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b00a966ebd25bc78ae206a38bd806b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a16b00a966ebd25bc78ae206a38bd806b">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a16b00a966ebd25bc78ae206a38bd806b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f35675be7b49f744de6ca18c219bdce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a1f35675be7b49f744de6ca18c219bdce">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1f35675be7b49f744de6ca18c219bdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d583a373220f7038baf062002b6f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ae8d583a373220f7038baf062002b6f3d">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ae8d583a373220f7038baf062002b6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d82f35482d82b8c81a17c61038adb97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5d82f35482d82b8c81a17c61038adb97">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bz, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a5d82f35482d82b8c81a17c61038adb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1f8f50cb9a5d086fbbe1bd31ee98d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aad1f8f50cb9a5d086fbbe1bd31ee98d9">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aad1f8f50cb9a5d086fbbe1bd31ee98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5809902416dd168d87cca1a14dd63e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5809902416dd168d87cca1a14dd63e24">allow_race_conditions</a> ()</td></tr>
<tr class="separator:a5809902416dd168d87cca1a14dd63e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fe5da134e1b247c8006bf952fb4a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad3fe5da134e1b247c8006bf952fb4a4c">atomic</a> (bool override_associativity_test=false)</td></tr>
<tr class="separator:ad3fe5da134e1b247c8006bf952fb4a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d8ad28c191b7f55aa3c42c4564cfff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a27d8ad28c191b7f55aa3c42c4564cfff">hexagon</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x=<a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>())</td></tr>
<tr class="separator:a27d8ad28c191b7f55aa3c42c4564cfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22728a4575073953687d1441518baa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad22728a4575073953687d1441518baa0">prefetch</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:ad22728a4575073953687d1441518baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fc4ea55a0bd81adda930bac5789264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#af2fc4ea55a0bd81adda930bac5789264">prefetch</a> (const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Internal::Parameter</a> &amp;param, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:af2fc4ea55a0bd81adda930bac5789264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6064d90f15d906fa1f7e0ac85fb80acc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6064d90f15d906fa1f7e0ac85fb80acc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a6064d90f15d906fa1f7e0ac85fb80acc">prefetch</a> (const T &amp;image, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a6064d90f15d906fa1f7e0ac85fb80acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad8b47b05cd107a0fbc4f1b2991771fb6">source_location</a> () const</td></tr>
<tr class="memdesc:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the source file and line where this stage was defined by parsing the process's own debug symbols.  <a href="class_halide_1_1_stage.html#ad8b47b05cd107a0fbc4f1b2991771fb6">More...</a><br /></td></tr>
<tr class="separator:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>May be a pure or update definition. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00070">70</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91222724ee6ff9f4d01dcb4f836d7627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91222724ee6ff9f4d01dcb4f836d7627">&#9670;&nbsp;</a></span>Stage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Stage::Stage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>stage_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00094">94</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#abc3ce26269a8eb1c0b68be8a56e7feab">Halide::Internal::Definition::args()</a>, <a class="el" href="class_halide_1_1_internal_1_1_definition.html#add2ca6ed247cf025facda56bd82da44c">Halide::Internal::Definition::defined()</a>, <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>, <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a24c3c6738aef3d711adb4debdcf759bc">Halide::Internal::Definition::schedule()</a>, and <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html#a3133aa6819fb3fc6d2a0091f18814f80">Halide::Internal::StageSchedule::touched()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aac3c9b2dcfcf060e53c38a6c99196312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3c9b2dcfcf060e53c38a6c99196312">&#9670;&nbsp;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a>&amp; Halide::Stage::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>. </p>
<p>For introspection only: to modify schedule, use the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> interface. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00108">108</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a24c3c6738aef3d711adb4debdcf759bc">Halide::Internal::Definition::schedule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l02446">Halide::Func::get_schedule()</a>.</p>

</div>
</div>
<a id="aeae73b461d876d4d921474d5042dad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae73b461d876d4d921474d5042dad65">&#9670;&nbsp;</a></span>dump_argument_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::dump_argument_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string describing the current var list taking into account all the splits, reorders, and tiles. </p>

</div>
</div>
<a id="a075401098fc0eb3fa260bbb93a21e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075401098fc0eb3fa260bbb93a21e80b">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this stage, e.g. </p>
<p>"f.update(2)" </p>

</div>
</div>
<a id="a9a7936287327b4627008fc723cb42565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7936287327b4627008fc723cb42565">&#9670;&nbsp;</a></span>rfactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>preserved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling <a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results. </p>
<p>If called on a init/pure definition, this will throw an error. <a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> will automatically infer the associative reduction operator and identity of the operator. If it can't prove the operation is associative or if it cannot find an identity for that operator, this will throw an error. In addition, commutativity of the operator is required if <a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> is called on the inner dimension but excluding the outer dimensions.</p>
<p><a class="el" href="class_halide_1_1_stage.html#a9a7936287327b4627008fc723cb42565" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> takes as input 'preserved', which is a list of &lt;<a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>, <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>&gt; pairs. The rvars not listed in 'preserved' are removed from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and are lifted to the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The remaining rvars (the ones in 'preserved') are made pure in the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition inherits all scheduling directives (e.g. split,fuse, etc.) applied to the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition is the same as the original, although the RVars in 'preserved' are replaced by the new pure Vars. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition from innermost to outermost is the args' order of the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition followed by the new pure Vars.</p>
<p>The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> also inherits storage order from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with the new pure Vars added to the outermost.</p>
<p>For example, f.update(0).rfactor({{r.y, u}}) would rewrite a pipeline like this: </p><div class="fragment"><div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += g(r.x, r.y);</div>
</div><!-- fragment --><p> into a pipeline like this: </p><div class="fragment"><div class="line">f_intm(x, y, u) = 0;</div>
<div class="line">f_intm(x, y, u) += g(r.x, u);</div>
<div class="line"> </div>
<div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += f_intm(x, y, r.y);</div>
</div><!-- fragment --><p>This has a variety of uses. You can use it to split computation of an associative reduction: </p><div class="fragment"><div class="line">f(x, y) = 10;</div>
<div class="line">RDom r(0, 96);</div>
<div class="line">f(x, y) = <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), g(x, y, r.x));</div>
<div class="line">f.update(0).split(r.x, rxo, rxi, 8).reorder(y, x).parallel(x);</div>
<div class="line">f.update(0).rfactor({{rxo, u}}).compute_root().parallel(u).update(0).parallel(u);</div>
<div class="ttc" id="anamespace_halide_html_aea2c7f5fe6c79a49dcbb28951cf8405d"><div class="ttname"><a href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">Halide::max</a></div><div class="ttdeci">Expr max(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00581">Func.h:581</a></div></div>
</div><!-- fragment --><p>, which is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> x:</div>
<div class="line">      f_intm(x, y, u) = -inf</div>
<div class="line"><a class="code" href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <a class="code" href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">      <span class="keywordflow">for</span> rxi = 0 to 7:</div>
<div class="line">        f_intm(x, y, u) = <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_intm(x, y, u), g(8*u + rxi))</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) = 10</div>
<div class="line"><a class="code" href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> rxo = 0 to 11:</div>
<div class="line">      f(x, y) = <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), f_intm(x, y, rxo))</div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a54a20ebb93c034853cff3b71923abf21"><div class="ttname"><a href="class_halide_1_1_stage.html#a54a20ebb93c034853cff3b71923abf21">Halide::Stage::parallel</a></div><div class="ttdeci">Stage &amp; parallel(const VarOrRVar &amp;var)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ad5f03630fb3fd72a3ab0b0563502cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad5f03630fb3fd72a3ab0b0563502cc">&#9670;&nbsp;</a></span>rfactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a2ae25a009d6a2d52cb407a25f0a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a2ae25a009d6a2d52cb407a25f0a5b">&#9670;&nbsp;</a></span>compute_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&#160;</td>
          <td class="paramname"><em>loop_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>
<p>'this' stage will be computed AFTER 's' in the innermost fused dimension. There should not be any dependencies between those two fused stages. If either of the stages being fused is a stage of an extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, this will throw an error.</p>
<p>Note that the two stages that are fused together should have the same exact schedule from the outermost to the innermost fused dimension, and the stage we are calling compute_with on should not have specializations, e.g. f2.compute_with(f1, x) is allowed only if f2 has no specializations.</p>
<p>Also, if a producer is desired to be computed at the fused loop level, the function passed to the compute_at() needs to be the "parent". Consider the following code: </p><div class="fragment"><div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">f(x, y) += 5;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">g(x, y) += 10;</div>
<div class="line">f.compute_with(g, y);</div>
<div class="line">f.update().compute_with(g.update(), y);</div>
</div><!-- fragment --><p>To compute 'input' at the fused loop level at dimension y, we specify input.compute_at(g, y) instead of input.compute_at(f, y) since 'g' is the "parent" for this fused loop (i.e. 'g' is computed first before 'f' is computed). On the other hand, to compute 'input' at the innermost dimension of 'f', we specify input.compute_at(f, x) instead of input.compute_at(g, x) since the x dimension of 'f' is not fused (only the y dimension is).</p>
<p>Given the constraints, this has a variety of uses. Consider the following code: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">h(x, y) = f(x, y) + g(x, y);</div>
<div class="line">f.compute_root();</div>
<div class="line">g.compute_root();</div>
<div class="line">f.split(x, xo, xi, 8);</div>
<div class="line">g.split(x, xo, xi, 8);</div>
<div class="line">g.compute_with(f, xo);</div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> xo:</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      f(8*xo + xi) = (8*xo + xi) + y</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      g(8*xo + xi) = (8*xo + xi) - y</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    h(x, y) = f(x, y) + g(x, y)</div>
</div><!-- fragment --><p>The size of the dimensions of the stages computed_with do not have to match. Consider the following code where 'g' is half the size of 'f': </p><div class="fragment"><div class="line">Image&lt;int&gt; f_im(size, size), g_im(size/2, size/2);</div>
<div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">g(x, y) = input(2*x, 2*y);</div>
<div class="line">g.compute_with(f, y);</div>
<div class="line">input.compute_at(f, y);</div>
<div class="line">Pipeline({f, g}).realize({f_im, g_im});</div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y = 0 to size-1:</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    input(x, y) = x + y;</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    f(x, y) = input(x, y)</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size/2-1:</div>
<div class="line">    <span class="keywordflow">if</span> (y &lt; size/2-1):</div>
<div class="line">      g(x, y) = input(2*x, 2*y)</div>
</div><!-- fragment --><p>'align' specifies how the loop iteration of each dimension of the two stages being fused should be aligned in the fused loop nests (see LoopAlignStrategy for options). Consider the following loop nests: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = f_min_z to f_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = f_min_y to f_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      f(x, y, z) = x + y + z</div>
<div class="line"><span class="keywordflow">for</span> z = g_min_z to g_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = g_min_y to g_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g(x, y, z) = x - y - z</div>
</div><!-- fragment --><p>If no alignment strategy is specified, the following loop nest will be generated: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_z, g_min_z) to <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, g_max_z):</div>
<div class="line">  for y = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_y, g_min_y) to <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_y, g_max_y):</div>
<div class="line">    for x = f_min_x to f_max_x:</div>
<div class="line">      if (f_min_z &lt;= z &lt;= f_max_z):</div>
<div class="line">        if (f_min_y &lt;= y &lt;= f_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    for x = g_min_x to g_max_x:</div>
<div class="line">      if (g_min_z &lt;= z &lt;= g_max_z):</div>
<div class="line">        if (g_min_y &lt;= y &lt;= g_max_y):</div>
<div class="line">          g(x, y, z) = x - y - z</div>
<div class="ttc" id="anamespace_halide_html_a842daf6fbd0f87ec9ea8336cb0cdd23e"><div class="ttname"><a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">Halide::min</a></div><div class="ttdeci">Expr min(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdoc">Explicit overloads of min and max for FuncRef.</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00578">Func.h:578</a></div></div>
</div><!-- fragment --><p>Instead, these alignment strategies: </p><div class="fragment"><div class="line">g.compute_with(f, y, {{z, <a class="code" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">LoopAlignStrategy::AlignStart</a>}, {y, <a class="code" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">LoopAlignStrategy::AlignEnd</a>}});</div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">Halide::LoopAlignStrategy::AlignEnd</a></div><div class="ttdeci">@ AlignEnd</div><div class="ttdoc">Shift the end of the fused loops to align.</div></div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">Halide::LoopAlignStrategy::AlignStart</a></div><div class="ttdeci">@ AlignStart</div><div class="ttdoc">Shift the start of the fused loops to align.</div></div>
</div><!-- fragment --><p> will produce the following loop nest: </p><div class="fragment"><div class="line">f_loop_min_z = f_min_z</div>
<div class="line">f_loop_max_z = <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, (f_min_z - g_min_z) + g_max_z)</div>
<div class="line"><span class="keywordflow">for</span> z = f_min_z to f_loop_max_z:</div>
<div class="line">  f_loop_min_y = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_y, (f_max_y - g_max_y) + g_min_y)</div>
<div class="line">  f_loop_max_y = f_max_y</div>
<div class="line">  <span class="keywordflow">for</span> y = f_loop_min_y to f_loop_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      <span class="keywordflow">if</span> (f_loop_min_z &lt;= z &lt;= f_loop_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (f_loop_min_y &lt;= y &lt;= f_loop_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g_shift_z = g_min_z - f_loop_min_z</div>
<div class="line">      g_shift_y = g_max_y - f_loop_max_y</div>
<div class="line">      <span class="keywordflow">if</span> (g_min_z &lt;= (z + g_shift_z) &lt;= g_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (g_min_y &lt;= (y + g_shift_y) &lt;= g_max_y):</div>
<div class="line">          g(x, y + g_shift_y, z + g_shift_z) = x - (y + g_shift_y) - (z + g_shift_z)</div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b" title="Shift the start of the fused loops to align.">LoopAlignStrategy::AlignStart</a> on dimension z will shift the loop iteration of 'g' at dimension z so that its starting value matches that of 'f'. Likewise, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af" title="Shift the end of the fused loops to align.">LoopAlignStrategy::AlignEnd</a> on dimension y will shift the loop iteration of 'g' at dimension y so that its end value matches that of 'f'. </p>

</div>
</div>
<a id="a4c2f0765c15be29838716e05bf1fb982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2f0765c15be29838716e05bf1fb982">&#9670;&nbsp;</a></span>compute_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&#160;</td>
          <td class="paramname"><em>loop_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba830a3b12b42b41b27f6ce40eafd56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba830a3b12b42b41b27f6ce40eafd56e">&#9670;&nbsp;</a></span>compute_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a353ef98b0f00d6f0e5dac7d00f3e70f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353ef98b0f00d6f0e5dac7d00f3e70f8">&#9670;&nbsp;</a></span>compute_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8913f861d2503d5e5064986ec182058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913f861d2503d5e5064986ec182058c">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this stage is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> for the meanings. </p>

</div>
</div>
<a id="a8e29492266ca6c310199a0ba1b0c2c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e29492266ca6c310199a0ba1b0c2c41">&#9670;&nbsp;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>fused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58bfef1fe10b032d1de620d1a1cd5595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bfef1fe10b032d1de620d1a1cd5595">&#9670;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54a20ebb93c034853cff3b71923abf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a20ebb93c034853cff3b71923abf21">&#9670;&nbsp;</a></span>parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a3c5f0b592c62bbee9f3f49656a155609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5f0b592c62bbee9f3f49656a155609">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a542316d98c5b1712b257fd5590feb65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542316d98c5b1712b257fd5590feb65c">&#9670;&nbsp;</a></span>unroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa58b64fe09f4661655bbbee9967f1d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58b64fe09f4661655bbbee9967f1d08">&#9670;&nbsp;</a></span>parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>task_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930d9a594f357eecdd21cf50c0f3d974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d9a594f357eecdd21cf50c0f3d974">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace303100816b64335dc83ba27847e220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace303100816b64335dc83ba27847e220">&#9670;&nbsp;</a></span>unroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a864aefe1080e5fca80ac6adf52ed81a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864aefe1080e5fca80ac6adf52ed81a0">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>yfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba48ef5a0ea11558791e7647f713175c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba48ef5a0ea11558791e7647f713175c">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>yfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65a4515e3c5d7a64816745227dbd6576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a4515e3c5d7a64816745227dbd6576">&#9670;&nbsp;</a></span>tile() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a144dcc2a136f8710a63deb2ec450fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144dcc2a136f8710a63deb2ec450fcbd">&#9670;&nbsp;</a></span>tile() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab999ec25e6ecff8b5baac901e8a2ef6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab999ec25e6ecff8b5baac901e8a2ef6e">&#9670;&nbsp;</a></span>tile() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5287af97a9cc189e2c4b0ee902664df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5287af97a9cc189e2c4b0ee902664df">&#9670;&nbsp;</a></span>reorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00379">reorder()</a>.</p>

</div>
</div>
<a id="a17b2b511c53ee05f1dad5880e9705837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b2b511c53ee05f1dad5880e9705837">&#9670;&nbsp;</a></span>reorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt;<a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt;<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args...&gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&gt;::type Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00379">379</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_stage.html#ab5287af97a9cc189e2c4b0ee902664df">reorder()</a>.</p>

</div>
</div>
<a id="a0a14b3cbe0ee18c49ce592ed42c5ef42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a14b3cbe0ee18c49ce592ed42c5ef42">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d8e12da382c2be8cfd512de0b5ddb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e12da382c2be8cfd512de0b5ddb36">&#9670;&nbsp;</a></span>specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> Halide::Stage::specialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99d85e44a0ea26a885216a6d722019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99d85e44a0ea26a885216a6d722019c">&#9670;&nbsp;</a></span>specialize_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Stage::specialize_fail </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcc5c05a0cb888d0285f478c84852d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc5c05a0cb888d0285f478c84852d5b">&#9670;&nbsp;</a></span>gpu_threads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0da38352750be6ba5c4864f7d913dc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da38352750be6ba5c4864f7d913dc5f">&#9670;&nbsp;</a></span>gpu_threads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9e80da8d383b17c21a976c1403fb3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e80da8d383b17c21a976c1403fb3f8">&#9670;&nbsp;</a></span>gpu_threads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae300f9cd0344c82615b920ec0c6059b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae300f9cd0344c82615b920ec0c6059b7">&#9670;&nbsp;</a></span>gpu_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dc29c71614cf2cdaafddfb2599d4b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc29c71614cf2cdaafddfb2599d4b69">&#9670;&nbsp;</a></span>gpu_single_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_single_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7b3e4e509dcd5fa865ba05b2c9fd892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b3e4e509dcd5fa865ba05b2c9fd892">&#9670;&nbsp;</a></span>gpu_blocks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7df65a56291dbc4edb2ebe359777b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df65a56291dbc4edb2ebe359777b7f">&#9670;&nbsp;</a></span>gpu_blocks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab2b18139a04675a2dc642e73b614e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2b18139a04675a2dc642e73b614e8c">&#9670;&nbsp;</a></span>gpu_blocks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ca138c9aa879cf72f64465b689ce9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca138c9aa879cf72f64465b689ce9a8">&#9670;&nbsp;</a></span>gpu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a124339212273ac6a3e057fed4ec56fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124339212273ac6a3e057fed4ec56fc9">&#9670;&nbsp;</a></span>gpu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12208751766b0eb44810fe5dab82979e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12208751766b0eb44810fe5dab82979e">&#9670;&nbsp;</a></span>gpu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fe4246877d8a18e28b358e2322b5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe4246877d8a18e28b358e2322b5d83">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16b00a966ebd25bc78ae206a38bd806b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b00a966ebd25bc78ae206a38bd806b">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f35675be7b49f744de6ca18c219bdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f35675be7b49f744de6ca18c219bdce">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8d583a373220f7038baf062002b6f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d583a373220f7038baf062002b6f3d">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d82f35482d82b8c81a17c61038adb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d82f35482d82b8c81a17c61038adb97">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1f8f50cb9a5d086fbbe1bd31ee98d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1f8f50cb9a5d086fbbe1bd31ee98d9">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5809902416dd168d87cca1a14dd63e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5809902416dd168d87cca1a14dd63e24">&#9670;&nbsp;</a></span>allow_race_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3fe5da134e1b247c8006bf952fb4a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fe5da134e1b247c8006bf952fb4a4c">&#9670;&nbsp;</a></span>atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::atomic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override_associativity_test</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27d8ad28c191b7f55aa3c42c4564cfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d8ad28c191b7f55aa3c42c4564cfff">&#9670;&nbsp;</a></span>hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em> = <code><a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad22728a4575073953687d1441518baa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22728a4575073953687d1441518baa0">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00449">prefetch()</a>.</p>

</div>
</div>
<a id="af2fc4ea55a0bd81adda930bac5789264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fc4ea55a0bd81adda930bac5789264">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Internal::Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6064d90f15d906fa1f7e0ac85fb80acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6064d90f15d906fa1f7e0ac85fb80acc">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00449">449</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_stage.html#ad22728a4575073953687d1441518baa0">prefetch()</a>.</p>

</div>
</div>
<a id="ad8b47b05cd107a0fbc4f1b2991771fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b47b05cd107a0fbc4f1b2991771fb6">&#9670;&nbsp;</a></span>source_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::source_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to get the source file and line where this stage was defined by parsing the process's own debug symbols. </p>
<p>Returns an empty string if no debug symbols were found or the debug symbols were not understood. Works on OS X and Linux only. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/<a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_stage.html">Stage</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
