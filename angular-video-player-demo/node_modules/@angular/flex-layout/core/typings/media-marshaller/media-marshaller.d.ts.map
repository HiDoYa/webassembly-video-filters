{"version":3,"file":"media-marshaller.d.ts","sources":["media-marshaller.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA","sourcesContent":["import { Observable } from 'rxjs';\nimport { BreakPointRegistry } from '../breakpoints/break-point-registry';\nimport { MatchMedia } from '../match-media/match-media';\nimport { MediaChange } from '../media-change';\nimport { PrintHook } from './print-hook';\ndeclare type ClearCallback = () => void;\ndeclare type UpdateCallback = (val: any) => void;\nexport interface ElementMatcher {\n    element: HTMLElement;\n    key: string;\n    value: any;\n}\n/**\n * MediaMarshaller - register responsive values from directives and\n *                   trigger them based on media query events\n */\nexport declare class MediaMarshaller {\n    protected matchMedia: MatchMedia;\n    protected breakpoints: BreakPointRegistry;\n    protected hook: PrintHook;\n    private activatedBreakpoints;\n    private elementMap;\n    private elementKeyMap;\n    private watcherMap;\n    private updateMap;\n    private clearMap;\n    private subject;\n    get activatedAlias(): string;\n    constructor(matchMedia: MatchMedia, breakpoints: BreakPointRegistry, hook: PrintHook);\n    /**\n     * Update styles on breakpoint activates or deactivates\n     * @param mc\n     */\n    onMediaChange(mc: MediaChange): void;\n    /**\n     * initialize the marshaller with necessary elements for delegation on an element\n     * @param element\n     * @param key\n     * @param updateFn optional callback so that custom bp directives don't have to re-provide this\n     * @param clearFn optional callback so that custom bp directives don't have to re-provide this\n     * @param extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)\n     */\n    init(element: HTMLElement, key: string, updateFn?: UpdateCallback, clearFn?: ClearCallback, extraTriggers?: Observable<any>[]): void;\n    /**\n     * get the value for an element and key and optionally a given breakpoint\n     * @param element\n     * @param key\n     * @param bp\n     */\n    getValue(element: HTMLElement, key: string, bp?: string): any;\n    /**\n     * whether the element has values for a given key\n     * @param element\n     * @param key\n     */\n    hasValue(element: HTMLElement, key: string): boolean;\n    /**\n     * Set the value for an input on a directive\n     * @param element the element in question\n     * @param key the type of the directive (e.g. flex, layout-gap, etc)\n     * @param bp the breakpoint suffix (empty string = default)\n     * @param val the value for the breakpoint\n     */\n    setValue(element: HTMLElement, key: string, val: any, bp: string): void;\n    /** Track element value changes for a specific key */\n    trackValue(element: HTMLElement, key: string): Observable<ElementMatcher>;\n    /** update all styles for all elements on the current breakpoint */\n    updateStyles(): void;\n    /**\n     * clear the styles for a given element\n     * @param element\n     * @param key\n     */\n    clearElement(element: HTMLElement, key: string): void;\n    /**\n     * update a given element with the activated values for a given key\n     * @param element\n     * @param key\n     * @param value\n     */\n    updateElement(element: HTMLElement, key: string, value: any): void;\n    /**\n     * release all references to a given element\n     * @param element\n     */\n    releaseElement(element: HTMLElement): void;\n    /**\n     * trigger an update for a given element and key (e.g. layout)\n     * @param element\n     * @param key\n     */\n    triggerUpdate(element: HTMLElement, key?: string): void;\n    /** Cross-reference for HTMLElement with directive key */\n    private buildElementKeyMap;\n    /**\n     * Other triggers that should force style updates:\n     * - directionality\n     * - layout changes\n     * - mutationobserver updates\n     */\n    private watchExtraTriggers;\n    /** Breakpoint locator by mediaQuery */\n    private findByQuery;\n    /**\n     * get the fallback breakpoint for a given element, starting with the current breakpoint\n     * @param bpMap\n     * @param key\n     */\n    private getActivatedValues;\n    /**\n     * Watch for mediaQuery breakpoint activations\n     */\n    private observeActivations;\n}\nexport {};\n"]}