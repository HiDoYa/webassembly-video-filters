<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::IRMatcher Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_halide_1_1_internal_1_1_i_r_matcher.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal::IRMatcher Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An alternative template-metaprogramming approach to expression matching.  
<a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To save stack space, the matcher objects are largely stateless and immutable.  <a href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1enable__if__pattern.html">enable_if_pattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1bindings.html">bindings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">WildConstInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">WildConstUInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">WildConstFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">WildConst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Wild</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">IsMaxValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">IsMinValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae29c5f8f734b23806ea65f9480e68426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae29c5f8f734b23806ea65f9480e68426">make_const_special_expr</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:ae29c5f8f734b23806ea65f9480e68426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adbef33d9a64963f7e5a6b8bd1ddc6565">make_const_expr</a> (<a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a> val, <a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f95ba2ddda30f44c2c99900c0822f9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7f95ba2ddda30f44c2c99900c0822f9a">equal_helper</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;b) noexcept</td></tr>
<tr class="separator:a7f95ba2ddda30f44c2c99900c0822f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab6dff7268fca017db4bb871e9b0d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a72ab6dff7268fca017db4bb871e9b0d5">equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;b) noexcept</td></tr>
<tr class="separator:a72ab6dff7268fca017db4bb871e9b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d0eff39076f8e54e8e556b8e8d19ba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a00d0eff39076f8e54e8e556b8e8d19ba">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;e)</td></tr>
<tr class="separator:a00d0eff39076f8e54e8e556b8e8d19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af96344dee0a97d8a8fbb5be28b1e886c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">WildConstInt</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4d1bdbd1185ecb89a237a7530eeefe1c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">WildConstUInt</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873658452a3a78825f8d4cc6f97d7a02"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a873658452a3a78825f8d4cc6f97d7a02"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a873658452a3a78825f8d4cc6f97d7a02">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">WildConstFloat</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a873658452a3a78825f8d4cc6f97d7a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90c67a51701c0919c6c2b4e490240cd"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:ab90c67a51701c0919c6c2b4e490240cd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab90c67a51701c0919c6c2b4e490240cd">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">WildConst</a>&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:ab90c67a51701c0919c6c2b4e490240cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9221dbcdf25ffb974940eb4b797b8c78">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Wild</a>&lt; i &gt; &amp;op)</td></tr>
<tr class="separator:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd315ae5bcc2a043e21ba0ce7fc6604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4cd315ae5bcc2a043e21ba0ce7fc6604">unwrap</a> (<a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> t)</td></tr>
<tr class="separator:a4cd315ae5bcc2a043e21ba0ce7fc6604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag&gt; </td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a> (T t)</td></tr>
<tr class="separator:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b87b47d755caab685d8ced4a583822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a05b87b47d755caab685d8ced4a583822">pattern_arg</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> x)</td></tr>
<tr class="separator:a05b87b47d755caab685d8ced4a583822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573935a29e2841c774dab39b74f819cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a573935a29e2841c774dab39b74f819cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a573935a29e2841c774dab39b74f819cc">assert_is_lvalue_if_expr</a> ()</td></tr>
<tr class="separator:a573935a29e2841c774dab39b74f819cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21824f09098bb3ae41a9dabdbaaef06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae21824f09098bb3ae41a9dabdbaaef06">pattern_arg</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:ae21824f09098bb3ae41a9dabdbaaef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag, typename  = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, SpecificExpr&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3e53940f96fc63b025f2c4b5476b1d41">unwrap</a> (T t)</td></tr>
<tr class="separator:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f86d86e9d90046df54af6d5700657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a557f86d86e9d90046df54af6d5700657">unwrap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;e)</td></tr>
<tr class="separator:a557f86d86e9d90046df54af6d5700657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4c853ee261cfd31fd97bd2ce677bb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a91e4c853ee261cfd31fd97bd2ce677bb">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> &amp;op)</td></tr>
<tr class="separator:a91e4c853ee261cfd31fd97bd2ce677bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9d935203140ecdaa7c89c2f61a66371d">constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:a9d935203140ecdaa7c89c2f61a66371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af5823d477b61633b1b0607075dea6a5f">constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, double, double) noexcept</td></tr>
<tr class="separator:af5823d477b61633b1b0607075dea6a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85b1b1664ed0848b20ddbb235747ad"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8c85b1b1664ed0848b20ddbb235747ad">commutative</a> (<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> t)</td></tr>
<tr class="separator:a8c85b1b1664ed0848b20ddbb235747ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af61cdd5630b9f58581f7be27e747bf76">constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:af61cdd5630b9f58581f7be27e747bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5671074743a4d51f6d5470676fdd6f32">constant_fold_cmp_op</a> (double, double) noexcept</td></tr>
<tr class="separator:a5671074743a4d51f6d5470676fdd6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b827754f38c7395eef6ed55e86744f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a01b827754f38c7395eef6ed55e86744f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a01b827754f38c7395eef6ed55e86744f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a01b827754f38c7395eef6ed55e86744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae04fb6f843a9dec7cb8cce8d3b9e4179">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad634aa13ee1e4f8bf3cc7ffb76cc6527">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673efcbbd601474b50c94b948bdbabfb"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a673efcbbd601474b50c94b948bdbabfb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a673efcbbd601474b50c94b948bdbabfb">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a673efcbbd601474b50c94b948bdbabfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa2a8f9c7203794cc695bcd47bb0bc157">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab152d1e44d088c50c74079c4661fd84"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aab152d1e44d088c50c74079c4661fd84"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aab152d1e44d088c50c74079c4661fd84">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:aab152d1e44d088c50c74079c4661fd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39eeba4c9bd01e2128d06c5f174adba"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af39eeba4c9bd01e2128d06c5f174adba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af39eeba4c9bd01e2128d06c5f174adba">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:af39eeba4c9bd01e2128d06c5f174adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436f691c61c99d48cda1bbb7a16353ee"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a436f691c61c99d48cda1bbb7a16353ee"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a436f691c61c99d48cda1bbb7a16353ee">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a436f691c61c99d48cda1bbb7a16353ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5aa01c252c46b4f9ed044b3b54ea6a86">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab3eae0c97045cfb0af9107a71ae912f9">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a35bae2a19d3624dda0eb9fa89f5bee0c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57429fca1464dcda68e9eef990212b94"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a57429fca1464dcda68e9eef990212b94"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a57429fca1464dcda68e9eef990212b94">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a57429fca1464dcda68e9eef990212b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a972d8bb67d41187b0c20cf9cd84bbc2a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1807e136ef4a774cdf620167d92c8125"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1807e136ef4a774cdf620167d92c8125"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1807e136ef4a774cdf620167d92c8125">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a1807e136ef4a774cdf620167d92c8125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e75343df60924b4086f6c3f5b9d440"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a15e75343df60924b4086f6c3f5b9d440"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a15e75343df60924b4086f6c3f5b9d440">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a15e75343df60924b4086f6c3f5b9d440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22054e3eaa6b5261e2906094b9a2a687"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a22054e3eaa6b5261e2906094b9a2a687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a22054e3eaa6b5261e2906094b9a2a687">operator+</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a22054e3eaa6b5261e2906094b9a2a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337dc5abeb4b5ac7502c84b6726ec395"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a337dc5abeb4b5ac7502c84b6726ec395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a337dc5abeb4b5ac7502c84b6726ec395">add</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator+(a, b))</td></tr>
<tr class="separator:a337dc5abeb4b5ac7502c84b6726ec395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afbdd7fb7b36b2cf3b64bda5111d28b4e">constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad0a4cb65f0a03b2bd504543b36bd9817">constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a21fd876acceaa7d5ecf7c52ce3fb847b">constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87772ce7641a946fb08359b977ec067"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab87772ce7641a946fb08359b977ec067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab87772ce7641a946fb08359b977ec067">operator-</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:ab87772ce7641a946fb08359b977ec067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8f2519d95c8671e7dd3bfaf00b1df2b0">sub</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator-(a, b))</td></tr>
<tr class="separator:a8f2519d95c8671e7dd3bfaf00b1df2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5e9451c858ad2679ef5b735719ddd065">constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a5e9451c858ad2679ef5b735719ddd065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a31218a5a5b22ea9d423a526bf48b3197">constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a31218a5a5b22ea9d423a526bf48b3197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a160bccbd5b3260ff67658ea4d533952d">constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a160bccbd5b3260ff67658ea4d533952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d830440f107dc41a1716783e211503a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2d830440f107dc41a1716783e211503a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2d830440f107dc41a1716783e211503a">operator*</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a2d830440f107dc41a1716783e211503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40a9fbcfd2433ac643c9e2cb754b588d">mul</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator*(a, b))</td></tr>
<tr class="separator:a40a9fbcfd2433ac643c9e2cb754b588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa47740df91721e730d765b5472669f11">constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa47740df91721e730d765b5472669f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a41a6c8f1d6156f6cd65f9a5521909ac6">constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e49735a398b8127b96e4d5713e571f">constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e49735a398b8127b96e4d5713e571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45261747b321afc0e81b7d92c48aa574"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a45261747b321afc0e81b7d92c48aa574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a45261747b321afc0e81b7d92c48aa574">operator/</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a45261747b321afc0e81b7d92c48aa574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383cd228eb518f611dbd291a516ad802"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a383cd228eb518f611dbd291a516ad802"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a383cd228eb518f611dbd291a516ad802">div</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator/(a, b))</td></tr>
<tr class="separator:a383cd228eb518f611dbd291a516ad802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a183445e4d4dca061c05996652f2dac5b">constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a183445e4d4dca061c05996652f2dac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7a117db2cf577ff20571558dbe97bf7f">constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a7a117db2cf577ff20571558dbe97bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae4d8b67bef430b9df555bf291792614f">constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ae4d8b67bef430b9df555bf291792614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc1219661497d08a78d27e8750e11d0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5bc1219661497d08a78d27e8750e11d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5bc1219661497d08a78d27e8750e11d0">operator%</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a5bc1219661497d08a78d27e8750e11d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d085a252877ef3f8c139c13936075c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af6d085a252877ef3f8c139c13936075c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af6d085a252877ef3f8c139c13936075c">mod</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator%(a, b))</td></tr>
<tr class="separator:af6d085a252877ef3f8c139c13936075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a49bb7e262c2c8f83476f33fa96ab4411">constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac259ecbd0cbade6ea8b16a03992de682">constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac259ecbd0cbade6ea8b16a03992de682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#acb5ce93cc0835cb6d4c79f2aa366ae5d">constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d0f25c1cc3452f338fed00dbbc7006"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a13d0f25c1cc3452f338fed00dbbc7006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a13d0f25c1cc3452f338fed00dbbc7006">min</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a13d0f25c1cc3452f338fed00dbbc7006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9f49f4ff4022205c07838918fd036ec2">constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a9f49f4ff4022205c07838918fd036ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0ee047ac24b43b0ea19cdc26ae9177a0">constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e1f600078ba83441a1da2e360cc255">constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e1f600078ba83441a1da2e360cc255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac090f719272da825a4749e3feba0f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a40ac090f719272da825a4749e3feba0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40ac090f719272da825a4749e3feba0f">max</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a40ac090f719272da825a4749e3feba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a62dd8f17b989502f974f83eb229b318c">constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a62dd8f17b989502f974f83eb229b318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8986bb12c496cdc93b809e91f10613ad">constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a8986bb12c496cdc93b809e91f10613ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab312d3c67fa31a253ca57f6420879d5f">constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ab312d3c67fa31a253ca57f6420879d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833cce3a02abce0789516bf33049a4b0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a833cce3a02abce0789516bf33049a4b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a833cce3a02abce0789516bf33049a4b0">operator&lt;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a833cce3a02abce0789516bf33049a4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4330ae468f2bc8bf764b4dc78093778"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac4330ae468f2bc8bf764b4dc78093778"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac4330ae468f2bc8bf764b4dc78093778">lt</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&lt;(a, b))</td></tr>
<tr class="separator:ac4330ae468f2bc8bf764b4dc78093778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad59404f6a9be2edd1e7b087067186085">constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad59404f6a9be2edd1e7b087067186085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6f2f045c1fac015142c7849a2d0a6c0e">constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90fd57e139aae6bc2a749b7dd7a2fa5b">constant_fold_cmp_op&lt; LT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e553686bff1060ee43f34fd4802a23"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a51e553686bff1060ee43f34fd4802a23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a51e553686bff1060ee43f34fd4802a23">operator&gt;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a51e553686bff1060ee43f34fd4802a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ca018cc9aed19d368a2ee56c8592a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a274ca018cc9aed19d368a2ee56c8592a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a274ca018cc9aed19d368a2ee56c8592a">gt</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&gt;(a, b))</td></tr>
<tr class="separator:a274ca018cc9aed19d368a2ee56c8592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa21a7fd9d8ad2e8c69060a0ba114658c">constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b98496c33623a602cfc21154a2c5a4c">constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6b98496c33623a602cfc21154a2c5a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88710908fc5963e4b0f13cf21bc8d406">constant_fold_cmp_op&lt; GT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a88710908fc5963e4b0f13cf21bc8d406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1f25a85f3e64642ba824e9bd9c455ca3">operator&lt;=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a1f25a85f3e64642ba824e9bd9c455ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac250b793aa021eccd179c53908dda5c4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac250b793aa021eccd179c53908dda5c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac250b793aa021eccd179c53908dda5c4">le</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&lt;=(a, b))</td></tr>
<tr class="separator:ac250b793aa021eccd179c53908dda5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c526b5044511ee7ca7e9bcdcb1a69b6">constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac8d4471ac09a360f80dd78b853300053">constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac8d4471ac09a360f80dd78b853300053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a98d1b4920a766465287987573f8f6a13">constant_fold_cmp_op&lt; LE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a98d1b4920a766465287987573f8f6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a0be176f231cfdf8c62021bbda629"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7d7a0be176f231cfdf8c62021bbda629"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7d7a0be176f231cfdf8c62021bbda629">operator&gt;=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a7d7a0be176f231cfdf8c62021bbda629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea49e0a06ecc1246107091521cbb3926"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aea49e0a06ecc1246107091521cbb3926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aea49e0a06ecc1246107091521cbb3926">ge</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&gt;=(a, b))</td></tr>
<tr class="separator:aea49e0a06ecc1246107091521cbb3926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab0a6bc166b2fb647aa37ee405b103547">constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ab0a6bc166b2fb647aa37ee405b103547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0de7f8aad5e2da6f956f9793c17b05a2">constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae0615b3c844f1bbbdc91d406c38a702f">constant_fold_cmp_op&lt; GE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d4ab05211a0d72975207ee6e0e4c40"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af9d4ab05211a0d72975207ee6e0e4c40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af9d4ab05211a0d72975207ee6e0e4c40">operator==</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:af9d4ab05211a0d72975207ee6e0e4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda856931d657019ab52370ce9622ca9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:afda856931d657019ab52370ce9622ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afda856931d657019ab52370ce9622ca9">eq</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator==(a, b))</td></tr>
<tr class="separator:afda856931d657019ab52370ce9622ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae039e07269a504c112cccbbddad2abd5">constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ae039e07269a504c112cccbbddad2abd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a369eaca268feef6557e2a11f3d3d44f6">constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a369eaca268feef6557e2a11f3d3d44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a77a3fec822b82e4550f36edcd0f94395">constant_fold_cmp_op&lt; EQ &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a77a3fec822b82e4550f36edcd0f94395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7110bb296528fe0b4cd90b8a969fbf9c">operator!=</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a7110bb296528fe0b4cd90b8a969fbf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b366748fa8c12e792e3ede293bdcbc4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1b366748fa8c12e792e3ede293bdcbc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1b366748fa8c12e792e3ede293bdcbc4">ne</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>=(a, b))</td></tr>
<tr class="separator:a1b366748fa8c12e792e3ede293bdcbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af1d31793eaf2c9bb7b2091ed268032cd">constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88969b742de298fa4e89c1b7e0cd9507">constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a88969b742de298fa4e89c1b7e0cd9507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac761e19f9cf67ff92b92350cb2f6b113">constant_fold_cmp_op&lt; NE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b766949dea9fe12a94f607a279b4845"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6b766949dea9fe12a94f607a279b4845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b766949dea9fe12a94f607a279b4845">operator||</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a6b766949dea9fe12a94f607a279b4845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ef677a9266173fc51c21c0691a351"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a0f6ef677a9266173fc51c21c0691a351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0f6ef677a9266173fc51c21c0691a351">or_op</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator||(a, b))</td></tr>
<tr class="separator:a0f6ef677a9266173fc51c21c0691a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6e3a69d10dc265ce7af23472b244e7a">constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac9551d885c2e22f2a7452adad11b9088">constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac9551d885c2e22f2a7452adad11b9088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af673f00fb1b63e823eba6f706412faf3">constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:af673f00fb1b63e823eba6f706412faf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b27a055ef4f01ea720a5601cc8acb8"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a84b27a055ef4f01ea720a5601cc8acb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a84b27a055ef4f01ea720a5601cc8acb8">operator&amp;&amp;</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a84b27a055ef4f01ea720a5601cc8acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e8bc42d079dd5a396862161982a040"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a24e8bc42d079dd5a396862161982a040"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a24e8bc42d079dd5a396862161982a040">and_op</a> (A &amp;&amp;a, B &amp;&amp;b) -&gt; decltype(IRMatcher::operator&amp;&amp;(a, b))</td></tr>
<tr class="separator:a24e8bc42d079dd5a396862161982a040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4b5bef8af3af1585ae4d230d4096ea7e">constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6d7c3ee7ce56b6e53ed07ee537ad0ae0">constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90d065a5b95304e191321a47658e1da7">constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a90d065a5b95304e191321a47658e1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade15fc322252444c511ae6458ee2e898"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ade15fc322252444c511ae6458ee2e898">bitwise_or_reduce</a> ()</td></tr>
<tr class="separator:ade15fc322252444c511ae6458ee2e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f76d20c53e195277c279e315c97e75"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a86f76d20c53e195277c279e315c97e75"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a86f76d20c53e195277c279e315c97e75">bitwise_or_reduce</a> (<a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> first, Args... rest)</td></tr>
<tr class="separator:a86f76d20c53e195277c279e315c97e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a67fba2b048ff9dfde5b4fd084ae4a6de">and_reduce</a> ()</td></tr>
<tr class="separator:a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad156714bf9d1b4d9991b828dd4ae5b38">and_reduce</a> (bool first, Args... rest)</td></tr>
<tr class="separator:ad156714bf9d1b4d9991b828dd4ae5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeda156ac4dd5650fe120a1f0bae129e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aeeda156ac4dd5650fe120a1f0bae129e">const_min</a> (int a, int b)</td></tr>
<tr class="separator:aeeda156ac4dd5650fe120a1f0bae129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac25115ad072f9d082bcc9bfc4c83399c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; Args... &gt; &amp;op)</td></tr>
<tr class="separator:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1008f0c0246dd21c990ca1375513ef"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2c1008f0c0246dd21c990ca1375513ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c1008f0c0246dd21c990ca1375513ef">intrin</a> (<a class="el" href="struct_halide_1_1_internal_1_1_call.html#a3643a3e5cf73435e07215fca17949974">Call::IntrinsicOp</a> intrinsic_op, Args... args) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(args))... &gt;</td></tr>
<tr class="separator:a2c1008f0c0246dd21c990ca1375513ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55178af5e3b02b5255a94e0569a3408c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a55178af5e3b02b5255a94e0569a3408c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a55178af5e3b02b5255a94e0569a3408c">widening_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a55178af5e3b02b5255a94e0569a3408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce80d3e53d9314292ed9c4219486cbe"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6ce80d3e53d9314292ed9c4219486cbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6ce80d3e53d9314292ed9c4219486cbe">widening_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a6ce80d3e53d9314292ed9c4219486cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bd76459b363b4941109dc8737c5dba"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a48bd76459b363b4941109dc8737c5dba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a48bd76459b363b4941109dc8737c5dba">widening_mul</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a48bd76459b363b4941109dc8737c5dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f87c36110f9d7459d2cdd4ada22a557"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a3f87c36110f9d7459d2cdd4ada22a557"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3f87c36110f9d7459d2cdd4ada22a557">saturating_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a3f87c36110f9d7459d2cdd4ada22a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5a757e2b3168a4b06595410120e2b"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa3f5a757e2b3168a4b06595410120e2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa3f5a757e2b3168a4b06595410120e2b">saturating_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:aa3f5a757e2b3168a4b06595410120e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b22be350851606a059a0b62423e0c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a616b22be350851606a059a0b62423e0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a616b22be350851606a059a0b62423e0c">halving_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a616b22be350851606a059a0b62423e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264cecf50c3be3f61a5a74e6acae758"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa264cecf50c3be3f61a5a74e6acae758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa264cecf50c3be3f61a5a74e6acae758">halving_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:aa264cecf50c3be3f61a5a74e6acae758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32711f0db688217a84f12677e958a393"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a32711f0db688217a84f12677e958a393"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a32711f0db688217a84f12677e958a393">rounding_halving_add</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a32711f0db688217a84f12677e958a393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641aa947adc791b219a64405ff08467"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af641aa947adc791b219a64405ff08467"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af641aa947adc791b219a64405ff08467">rounding_halving_sub</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:af641aa947adc791b219a64405ff08467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d73347f758b37e84dd96b2fa524032"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a02d73347f758b37e84dd96b2fa524032"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a02d73347f758b37e84dd96b2fa524032">shift_left</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a02d73347f758b37e84dd96b2fa524032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03704bed4c099f03d477e9cbe6ecf96"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab03704bed4c099f03d477e9cbe6ecf96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab03704bed4c099f03d477e9cbe6ecf96">shift_right</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:ab03704bed4c099f03d477e9cbe6ecf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a849a0adf0cb90e57a54fcbc7e346"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a024a849a0adf0cb90e57a54fcbc7e346"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a024a849a0adf0cb90e57a54fcbc7e346">rounding_shift_left</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a024a849a0adf0cb90e57a54fcbc7e346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fb5637bd3165e3f741c207c0b8d175"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a32fb5637bd3165e3f741c207c0b8d175"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a32fb5637bd3165e3f741c207c0b8d175">rounding_shift_right</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt;</td></tr>
<tr class="separator:a32fb5637bd3165e3f741c207c0b8d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1221d76d53d37224ffeaf8e4e016044e"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a1221d76d53d37224ffeaf8e4e016044e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">operator!</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a1221d76d53d37224ffeaf8e4e016044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ababe61b897e02458abaa51ff96952"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a60ababe61b897e02458abaa51ff96952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a60ababe61b897e02458abaa51ff96952">not_op</a> (A &amp;&amp;a) -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>(a))</td></tr>
<tr class="separator:a60ababe61b897e02458abaa51ff96952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9ad9a3678ae50d42223cc2609be3edc0">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3423872962efc0a52a5acdb3b7def67"><td class="memTemplParams" colspan="2">template&lt;typename C , typename T , typename F &gt; </td></tr>
<tr class="memitem:aa3423872962efc0a52a5acdb3b7def67"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa3423872962efc0a52a5acdb3b7def67">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt; C, T, F &gt; &amp;op)</td></tr>
<tr class="separator:aa3423872962efc0a52a5acdb3b7def67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f94a63ffe179595c2f5479d053d3ba"><td class="memTemplParams" colspan="2">template&lt;typename C , typename T , typename F &gt; </td></tr>
<tr class="memitem:a99f94a63ffe179595c2f5479d053d3ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a99f94a63ffe179595c2f5479d053d3ba">select</a> (C &amp;&amp;c, T &amp;&amp;t, F &amp;&amp;f) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(t)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(f))&gt;</td></tr>
<tr class="separator:a99f94a63ffe179595c2f5479d053d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74066c23269bdeeb81ff66d53620278a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a74066c23269bdeeb81ff66d53620278a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a74066c23269bdeeb81ff66d53620278a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt; A, B &gt; &amp;op)</td></tr>
<tr class="separator:a74066c23269bdeeb81ff66d53620278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922c231b05db372ed6a96007a2d6a20"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a9922c231b05db372ed6a96007a2d6a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9922c231b05db372ed6a96007a2d6a20">broadcast</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes))&gt;</td></tr>
<tr class="separator:a9922c231b05db372ed6a96007a2d6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724ad26f2d5a2276ee7ef51cfd743a4b"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C &gt; </td></tr>
<tr class="memitem:a724ad26f2d5a2276ee7ef51cfd743a4b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a724ad26f2d5a2276ee7ef51cfd743a4b">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt; A, B, C &gt; &amp;op)</td></tr>
<tr class="separator:a724ad26f2d5a2276ee7ef51cfd743a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f2d238dfcffbd0c3451ef90232877"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C &gt; </td></tr>
<tr class="memitem:a431f2d238dfcffbd0c3451ef90232877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a431f2d238dfcffbd0c3451ef90232877">ramp</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c))&gt;</td></tr>
<tr class="separator:a431f2d238dfcffbd0c3451ef90232877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb9e9e2259676b29030d913d838758"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , VectorReduce::Operator reduce_op&gt; </td></tr>
<tr class="memitem:affcb9e9e2259676b29030d913d838758"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#affcb9e9e2259676b29030d913d838758">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; A, B, reduce_op &gt; &amp;op)</td></tr>
<tr class="separator:affcb9e9e2259676b29030d913d838758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6723cb8cab78dc4c8f379e3c83a8360">h_add</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a16ec0621eb057662b7f7d001dbd0da01">VectorReduce::Add</a> &gt;</td></tr>
<tr class="separator:ad6723cb8cab78dc4c8f379e3c83a8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6067256015c2d4afa44d97cb8eda1e6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad6067256015c2d4afa44d97cb8eda1e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6067256015c2d4afa44d97cb8eda1e6">h_min</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a0abcd93c020ca8bae3babbfc837e8f02">VectorReduce::Min</a> &gt;</td></tr>
<tr class="separator:ad6067256015c2d4afa44d97cb8eda1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921a69b5feab00a02588a95d2f450cb"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a9921a69b5feab00a02588a95d2f450cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9921a69b5feab00a02588a95d2f450cb">h_max</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27af60bd97c582326c966cc33190093b82d">VectorReduce::Max</a> &gt;</td></tr>
<tr class="separator:a9921a69b5feab00a02588a95d2f450cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27178171a8cfdc63ef6273eabe81ad93"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a27178171a8cfdc63ef6273eabe81ad93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a27178171a8cfdc63ef6273eabe81ad93">h_and</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a3507ab281fc9d4d92dd7ae852526fc23">VectorReduce::And</a> &gt;</td></tr>
<tr class="separator:a27178171a8cfdc63ef6273eabe81ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7f03a2bb65c45f200332b34be7a589"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a8c7f03a2bb65c45f200332b34be7a589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8c7f03a2bb65c45f200332b34be7a589">h_or</a> (A &amp;&amp;a, B lanes) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a79f25cf9b2e8a9b72cca870af08ed32b">VectorReduce::Or</a> &gt;</td></tr>
<tr class="separator:a8c7f03a2bb65c45f200332b34be7a589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af6144c2094a04fc0650b13e88c8cb0e7">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd99c19b0522f947c719b3995ffe70cb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:afd99c19b0522f947c719b3995ffe70cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afd99c19b0522f947c719b3995ffe70cb">operator-</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:afd99c19b0522f947c719b3995ffe70cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e62d8f98688b2d727534fbf22289f2c"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a1e62d8f98688b2d727534fbf22289f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e62d8f98688b2d727534fbf22289f2c">negate</a> (A &amp;&amp;a) -&gt; decltype(IRMatcher::operator-(a))</td></tr>
<tr class="separator:a1e62d8f98688b2d727534fbf22289f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcf314c678215e84e8af4eef15a6a21"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adbcf314c678215e84e8af4eef15a6a21"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adbcf314c678215e84e8af4eef15a6a21">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:adbcf314c678215e84e8af4eef15a6a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548d0224c06bd3698a5bc689a8c61fb6"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a548d0224c06bd3698a5bc689a8c61fb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a548d0224c06bd3698a5bc689a8c61fb6">cast</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a548d0224c06bd3698a5bc689a8c61fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c85092b9877e71685d7cf5e41ab31"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a606c85092b9877e71685d7cf5e41ab31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a606c85092b9877e71685d7cf5e41ab31">fold</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a606c85092b9877e71685d7cf5e41ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443d1c29beb1d2d9560984699366f67d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a443d1c29beb1d2d9560984699366f67d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a443d1c29beb1d2d9560984699366f67d">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a443d1c29beb1d2d9560984699366f67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54edd4eb65abe7517ce70567983e7b42"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a54edd4eb65abe7517ce70567983e7b42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54edd4eb65abe7517ce70567983e7b42">overflows</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a54edd4eb65abe7517ce70567983e7b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8af40420f92ca04ccdc2bd5ed78687fc">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0be969cbc9fde866414c2a7bd07648"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b0be969cbc9fde866414c2a7bd07648">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Overflow</a> &amp;op)</td></tr>
<tr class="separator:a6b0be969cbc9fde866414c2a7bd07648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28433cdc327c82a5cad11ca6e051ea75"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a28433cdc327c82a5cad11ca6e051ea75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a28433cdc327c82a5cad11ca6e051ea75">is_const</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a28433cdc327c82a5cad11ca6e051ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ecf97f86f365e0346423805eaf05a"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:abb2ecf97f86f365e0346423805eaf05a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abb2ecf97f86f365e0346423805eaf05a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:abb2ecf97f86f365e0346423805eaf05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9f4c30615143a322274dab09e1829c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:afc9f4c30615143a322274dab09e1829c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afc9f4c30615143a322274dab09e1829c">can_prove</a> (A &amp;&amp;a, Prover *p) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), Prover &gt;</td></tr>
<tr class="separator:afc9f4c30615143a322274dab09e1829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d02ed6452c98a876e00e56486f131c3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:a3d02ed6452c98a876e00e56486f131c3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3d02ed6452c98a876e00e56486f131c3">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt; A, Prover &gt; &amp;op)</td></tr>
<tr class="separator:a3d02ed6452c98a876e00e56486f131c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772465f4fe4374660084eea333ed6bc9"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a772465f4fe4374660084eea333ed6bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a772465f4fe4374660084eea333ed6bc9">is_float</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a772465f4fe4374660084eea333ed6bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f605385d281d571e62de8fd0a5f008"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a40f605385d281d571e62de8fd0a5f008"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40f605385d281d571e62de8fd0a5f008">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a40f605385d281d571e62de8fd0a5f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df3b22fe777586f70976c61ccb1209"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a14df3b22fe777586f70976c61ccb1209"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a14df3b22fe777586f70976c61ccb1209">is_int</a> (A &amp;&amp;a, int bits=0) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a14df3b22fe777586f70976c61ccb1209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314fa7fbb059cac25c8aa55249c16082"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a314fa7fbb059cac25c8aa55249c16082"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a314fa7fbb059cac25c8aa55249c16082">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a314fa7fbb059cac25c8aa55249c16082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab363d6d7c4dfb66dd0b24d0ad9235d1"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aab363d6d7c4dfb66dd0b24d0ad9235d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aab363d6d7c4dfb66dd0b24d0ad9235d1">is_uint</a> (A &amp;&amp;a, int bits=0) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:aab363d6d7c4dfb66dd0b24d0ad9235d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb708c84d454bda71c6652d7d6a578f2"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adb708c84d454bda71c6652d7d6a578f2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adb708c84d454bda71c6652d7d6a578f2">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:adb708c84d454bda71c6652d7d6a578f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0455ea7d220c198c585b7651e74f55"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5f0455ea7d220c198c585b7651e74f55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5f0455ea7d220c198c585b7651e74f55">is_scalar</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a5f0455ea7d220c198c585b7651e74f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222c889d7baed380d66d0d58c32a1714"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a222c889d7baed380d66d0d58c32a1714"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a222c889d7baed380d66d0d58c32a1714">is_max_value</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">IsMaxValue</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a222c889d7baed380d66d0d58c32a1714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f17def21287dbec4a6511400c023e56"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9f17def21287dbec4a6511400c023e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9f17def21287dbec4a6511400c023e56">is_min_value</a> (A &amp;&amp;a) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">IsMinValue</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt;</td></tr>
<tr class="separator:a9f17def21287dbec4a6511400c023e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf29e2fe3f26dce7eea989ea060baa7"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a4bf29e2fe3f26dce7eea989ea060baa7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4bf29e2fe3f26dce7eea989ea060baa7">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a4bf29e2fe3f26dce7eea989ea060baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                            std::decay&lt;After&gt;::type::foldable&gt;::type&gt; </td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa0f60c82d8daf8da2c27b3497c6c083f">fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, Predicate &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept</td></tr>
<tr class="separator:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;!(std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                              std::decay&lt;After&gt;::type::foldable)&gt;::type&gt; </td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a440cc0cc987c622f2361638a3d310170">fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, Predicate &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, int dummy=0) noexcept</td></tr>
<tr class="separator:a440cc0cc987c622f2361638a3d310170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a17c3af3849b20aa80caa9ceeb4d67b66">evaluate_predicate</a> (bool x, <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;) noexcept</td></tr>
<tr class="separator:a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplParams" colspan="2">template&lt;typename Pattern , typename  = typename enable_if_pattern&lt;Pattern&gt;::type&gt; </td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aef18091a070c6c3f362c6ca55e75c2db">evaluate_predicate</a> (Pattern p, <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;state)</td></tr>
<tr class="separator:aef18091a070c6c3f362c6ca55e75c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfea57650e9742f5aed422e6be5a58"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a02dfea57650e9742f5aed422e6be5a58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a02dfea57650e9742f5aed422e6be5a58">rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt;</td></tr>
<tr class="memdesc:a02dfea57650e9742f5aed422e6be5a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a02dfea57650e9742f5aed422e6be5a58">More...</a><br /></td></tr>
<tr class="separator:a02dfea57650e9742f5aed422e6be5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54abcfed7ab37a4c726020c119d0efff"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a54abcfed7ab37a4c726020c119d0efff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54abcfed7ab37a4c726020c119d0efff">rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt;</td></tr>
<tr class="separator:a54abcfed7ab37a4c726020c119d0efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4726f950a627f1361e2bdb1fb98a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aaeb4726f950a627f1361e2bdb1fb98a2">rewriter</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt;</td></tr>
<tr class="separator:aaeb4726f950a627f1361e2bdb1fb98a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54caa0633d17c57ea0df1aa5bdca3850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54caa0633d17c57ea0df1aa5bdca3850">rewriter</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e) noexcept -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt;</td></tr>
<tr class="separator:a54caa0633d17c57ea0df1aa5bdca3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6feb6895f4d41d350eda704b7e3cc4bc">max_wild</a> = 6</td></tr>
<tr class="separator:a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An alternative template-metaprogramming approach to expression matching. </p>
<p>Potentially more efficient. We lift the expression pattern into a type, and then use force-inlined functions to generate efficient matching and reconstruction code for any pattern. Pattern elements are either one of the classes in the namespace <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html" title="An alternative template-metaprogramming approach to expression matching.">IRMatcher</a>, or are non-null Exprs (represented as <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html" title="A base class for expression nodes.">BaseExprNode</a> &amp;).</p>
<p>Pattern elements that are fully specified by their pattern can be built into an expression using the make method. Some patterns, such as a broadcast that matches any number of lanes, don't have enough information to recreate an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae29c5f8f734b23806ea65f9480e68426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29c5f8f734b23806ea65f9480e68426">&#9670;&nbsp;</a></span>make_const_special_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::IRMatcher::make_const_special_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00145">145</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00446">halide_type_t::lanes</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee83b2e74ffd9ee144d046aebbf87cca">Halide::Internal::make_signed_integer_overflow()</a>, <a class="el" href="_i_r_match_8h_source.html#l00083">Halide::Internal::IRMatcher::MatcherState::signed_integer_overflow</a>, and <a class="el" href="_i_r_match_8h_source.html#l00084">Halide::Internal::IRMatcher::MatcherState::special_values_mask</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02130">Halide::Internal::IRMatcher::Overflow::make()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00156">make_const_expr()</a>.</p>

</div>
</div>
<a id="adbef33d9a64963f7e5a6b8bd1ddc6565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef33d9a64963f7e5a6b8bd1ddc6565">&#9670;&nbsp;</a></span>make_const_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::IRMatcher::make_const_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00156">156</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00437">halide_type_t::code</a>, <a class="el" href="_halide_runtime_8h_source.html#l01588">halide_scalar_value_t::f64</a>, <a class="el" href="_halide_runtime_8h_source.html#l00412">halide_type_bfloat</a>, <a class="el" href="_halide_runtime_8h_source.html#l00410">halide_type_float</a>, <a class="el" href="_halide_runtime_8h_source.html#l00408">halide_type_int</a>, <a class="el" href="_halide_runtime_8h_source.html#l00409">halide_type_uint</a>, <a class="el" href="_halide_runtime_8h_source.html#l01582">halide_scalar_value_t::i64</a>, <a class="el" href="_halide_runtime_8h_source.html#l00446">halide_type_t::lanes</a>, <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html#a57506d173c900722f549470628c81b30">Halide::Internal::Broadcast::make()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html#a5d65e8570db323b82e343fd335d68b84">Halide::Internal::FloatImm::make()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html#a2451b98e19066f46b59aa6d21af11758">Halide::Internal::IntImm::make()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html#a6b48aa70c280e609d1ca1646bd0e9096">Halide::Internal::UIntImm::make()</a>, <a class="el" href="_i_r_match_8h_source.html#l00145">make_const_special_expr()</a>, <a class="el" href="_i_r_match_8h_source.html#l00084">Halide::Internal::IRMatcher::MatcherState::special_values_mask</a>, <a class="el" href="structhalide__scalar__value__t.html#a9c0e03e5918800866c4d2e31e467105b">halide_scalar_value_t::u</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01586">halide_scalar_value_t::u64</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">fuzz_test_rule()</a>, <a class="el" href="_i_r_match_8h_source.html#l00275">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;::make()</a>, <a class="el" href="_i_r_match_8h_source.html#l00328">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;::make()</a>, <a class="el" href="_i_r_match_8h_source.html#l00381">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;::make()</a>, <a class="el" href="_i_r_match_8h_source.html#l00439">Halide::Internal::IRMatcher::WildConst&lt; i &gt;::make()</a>, and <a class="el" href="_i_r_match_8h_source.html#l02030">Halide::Internal::IRMatcher::Fold&lt; A &gt;::make()</a>.</p>

</div>
</div>
<a id="a7f95ba2ddda30f44c2c99900c0822f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f95ba2ddda30f44c2c99900c0822f9a">&#9670;&nbsp;</a></span>equal_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::IRMatcher::equal_helper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00191">equal()</a>.</p>

</div>
</div>
<a id="a72ab6dff7268fca017db4bb871e9b0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ab6dff7268fca017db4bb871e9b0d5">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::IRMatcher::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00191">191</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7f95ba2ddda30f44c2c99900c0822f9a">equal_helper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00213">Halide::Internal::IRMatcher::SpecificExpr::match()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00472">Halide::Internal::IRMatcher::Wild&lt; i &gt;::match()</a>.</p>

</div>
</div>
<a id="a00d0eff39076f8e54e8e556b8e8d19ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d0eff39076f8e54e8e556b8e8d19ba">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/39]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00225">225</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00210">Halide::Internal::IRMatcher::SpecificExpr::expr</a>.</p>

</div>
</div>
<a id="af96344dee0a97d8a8fbb5be28b1e886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96344dee0a97d8a8fbb5be28b1e886c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">WildConstInt</a>&lt; i &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00291">291</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a4d1bdbd1185ecb89a237a7530eeefe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1bdbd1185ecb89a237a7530eeefe1c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">WildConstUInt</a>&lt; i &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00344">344</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a873658452a3a78825f8d4cc6f97d7a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873658452a3a78825f8d4cc6f97d7a02">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">WildConstFloat</a>&lt; i &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00397">397</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ab90c67a51701c0919c6c2b4e490240cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90c67a51701c0919c6c2b4e490240cd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">WildConst</a>&lt; i &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00455">455</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a9221dbcdf25ffb974940eb4b797b8c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9221dbcdf25ffb974940eb4b797b8c78">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Wild</a>&lt; i &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00512">512</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a4cd315ae5bcc2a043e21ba0ce7fc6604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd315ae5bcc2a043e21ba0ce7fc6604">&#9670;&nbsp;</a></span>unwrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::IRMatcher::unwrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00590">590</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00521">Halide::Internal::IRMatcher::IntLiteral::v</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00686">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01699">Halide::Internal::IRMatcher::BroadcastOp&lt; A, B &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01994">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l00796">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01570">Halide::Internal::IRMatcher::NotOp&lt; A &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01774">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01632">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01836">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, B, reduce_op &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l01913">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::match()</a>, and <a class="el" href="_i_r_match_8h_source.html#l02639">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>.</p>

</div>
</div>
<a id="a04098851fbbe2fcc79ea1cf70344d4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04098851fbbe2fcc79ea1cf70344d4f3">&#9670;&nbsp;</a></span>pattern_arg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T Halide::Internal::IRMatcher::pattern_arg </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00598">598</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01739">broadcast()</a>, <a class="el" href="_i_r_match_8h_source.html#l02213">can_prove()</a>, <a class="el" href="_i_r_match_8h_source.html#l02013">cast()</a>, <a class="el" href="_i_r_match_8h_source.html#l02062">fold()</a>, <a class="el" href="_i_r_match_8h_source.html#l01861">h_add()</a>, <a class="el" href="_i_r_match_8h_source.html#l01879">h_and()</a>, <a class="el" href="_i_r_match_8h_source.html#l01873">h_max()</a>, <a class="el" href="_i_r_match_8h_source.html#l01867">h_min()</a>, <a class="el" href="_i_r_match_8h_source.html#l01885">h_or()</a>, <a class="el" href="_i_r_match_8h_source.html#l01517">halving_add()</a>, <a class="el" href="_i_r_match_8h_source.html#l01521">halving_sub()</a>, <a class="el" href="_i_r_match_8h_source.html#l01492">intrin()</a>, <a class="el" href="_i_r_match_8h_source.html#l02175">is_const()</a>, <a class="el" href="_i_r_match_8h_source.html#l02250">is_float()</a>, <a class="el" href="_i_r_match_8h_source.html#l02288">is_int()</a>, <a class="el" href="_i_r_match_8h_source.html#l02406">is_max_value()</a>, <a class="el" href="_i_r_match_8h_source.html#l02443">is_min_value()</a>, <a class="el" href="_i_r_match_8h_source.html#l02371">is_scalar()</a>, <a class="el" href="_i_r_match_8h_source.html#l02330">is_uint()</a>, <a class="el" href="_i_r_match_8h_source.html#l01129">max()</a>, <a class="el" href="_i_r_match_8h_source.html#l01107">min()</a>, <a class="el" href="_i_r_match_8h_source.html#l01590">operator!()</a>, <a class="el" href="_i_r_match_8h_source.html#l01276">operator!=()</a>, <a class="el" href="_i_r_match_8h_source.html#l01078">operator%()</a>, <a class="el" href="_i_r_match_8h_source.html#l01327">operator&amp;&amp;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01018">operator*()</a>, <a class="el" href="_i_r_match_8h_source.html#l00952">operator+()</a>, <a class="el" href="_i_r_match_8h_source.html#l00985">operator-()</a>, <a class="el" href="_i_r_match_8h_source.html#l01051">operator/()</a>, <a class="el" href="_i_r_match_8h_source.html#l01151">operator&lt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01201">operator&lt;=()</a>, <a class="el" href="_i_r_match_8h_source.html#l01251">operator==()</a>, <a class="el" href="_i_r_match_8h_source.html#l01176">operator&gt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l01226">operator&gt;=()</a>, <a class="el" href="_i_r_match_8h_source.html#l01301">operator||()</a>, <a class="el" href="_i_r_match_8h_source.html#l02099">overflows()</a>, <a class="el" href="_i_r_match_8h_source.html#l01803">ramp()</a>, <a class="el" href="_i_r_match_8h_source.html#l02798">rewriter()</a>, <a class="el" href="_i_r_match_8h_source.html#l01525">rounding_halving_add()</a>, <a class="el" href="_i_r_match_8h_source.html#l01529">rounding_halving_sub()</a>, <a class="el" href="_i_r_match_8h_source.html#l01541">rounding_shift_left()</a>, <a class="el" href="_i_r_match_8h_source.html#l01545">rounding_shift_right()</a>, <a class="el" href="_i_r_match_8h_source.html#l01509">saturating_add()</a>, <a class="el" href="_i_r_match_8h_source.html#l01513">saturating_sub()</a>, <a class="el" href="_i_r_match_8h_source.html#l01666">select()</a>, <a class="el" href="_i_r_match_8h_source.html#l01533">shift_left()</a>, <a class="el" href="_i_r_match_8h_source.html#l01537">shift_right()</a>, <a class="el" href="_i_r_match_8h_source.html#l01497">widening_add()</a>, <a class="el" href="_i_r_match_8h_source.html#l01505">widening_mul()</a>, and <a class="el" href="_i_r_match_8h_source.html#l01501">widening_sub()</a>.</p>

</div>
</div>
<a id="a05b87b47d755caab685d8ced4a583822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b87b47d755caab685d8ced4a583822">&#9670;&nbsp;</a></span>pattern_arg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> Halide::Internal::IRMatcher::pattern_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00602">602</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a573935a29e2841c774dab39b74f819cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573935a29e2841c774dab39b74f819cc">&#9670;&nbsp;</a></span>assert_is_lvalue_if_expr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void Halide::Internal::IRMatcher::assert_is_lvalue_if_expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00607">607</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ae21824f09098bb3ae41a9dabdbaaef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21824f09098bb3ae41a9dabdbaaef06">&#9670;&nbsp;</a></span>pattern_arg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> Halide::Internal::IRMatcher::pattern_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00612">612</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_8h_source.html#l00314">Halide::Expr::get()</a>.</p>

</div>
</div>
<a id="a3e53940f96fc63b025f2c4b5476b1d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e53940f96fc63b025f2c4b5476b1d41">&#9670;&nbsp;</a></span>unwrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag, typename  = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, SpecificExpr&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T Halide::Internal::IRMatcher::unwrap </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00623">623</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a557f86d86e9d90046df54af6d5700657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557f86d86e9d90046df54af6d5700657">&#9670;&nbsp;</a></span>unwrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a>&amp; Halide::Internal::IRMatcher::unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">SpecificExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00628">628</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00210">Halide::Internal::IRMatcher::SpecificExpr::expr</a>.</p>

</div>
</div>
<a id="a91e4c853ee261cfd31fd97bd2ce677bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4c853ee261cfd31fd97bd2ce677bb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/39]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_int_literal.html">IntLiteral</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00632">632</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00521">Halide::Internal::IRMatcher::IntLiteral::v</a>.</p>

</div>
</div>
<a id="ae02c255ad5cbd923bb80d831dcb29a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02c255ad5cbd923bb80d831dcb29a9f">&#9670;&nbsp;</a></span>constant_fold_bin_op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::IRMatcher::constant_fold_bin_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d935203140ecdaa7c89c2f61a66371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d935203140ecdaa7c89c2f61a66371d">&#9670;&nbsp;</a></span>constant_fold_bin_op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::IRMatcher::constant_fold_bin_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5823d477b61633b1b0607075dea6a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5823d477b61633b1b0607075dea6a5f">&#9670;&nbsp;</a></span>constant_fold_bin_op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Halide::Internal::IRMatcher::constant_fold_bin_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c85b1b1664ed0848b20ddbb235747ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c85b1b1664ed0848b20ddbb235747ad">&#9670;&nbsp;</a></span>commutative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Halide::Internal::IRMatcher::commutative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00646">646</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9">Halide::Internal::Add</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b">Halide::Internal::And</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47">Halide::Internal::EQ</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233">Halide::Internal::Max</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2">Halide::Internal::Min</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2">Halide::Internal::Mul</a>, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0">Halide::Internal::NE</a>, and <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c">Halide::Internal::Or</a>.</p>

</div>
</div>
<a id="a1e96dcc65e8cb2a61d81b286441a6dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e96dcc65e8cb2a61d81b286441a6dc5">&#9670;&nbsp;</a></span>constant_fold_cmp_op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::IRMatcher::constant_fold_cmp_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af61cdd5630b9f58581f7be27e747bf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61cdd5630b9f58581f7be27e747bf76">&#9670;&nbsp;</a></span>constant_fold_cmp_op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::IRMatcher::constant_fold_cmp_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5671074743a4d51f6d5470676fdd6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5671074743a4d51f6d5470676fdd6f32">&#9670;&nbsp;</a></span>constant_fold_cmp_op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> Halide::Internal::IRMatcher::constant_fold_cmp_op </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01b827754f38c7395eef6ed55e86744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b827754f38c7395eef6ed55e86744f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00862">862</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="ae04fb6f843a9dec7cb8cce8d3b9e4179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04fb6f843a9dec7cb8cce8d3b9e4179">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00868">868</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="ad634aa13ee1e4f8bf3cc7ffb76cc6527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad634aa13ee1e4f8bf3cc7ffb76cc6527">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00874">874</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a673efcbbd601474b50c94b948bdbabfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673efcbbd601474b50c94b948bdbabfb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00880">880</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="aa2a8f9c7203794cc695bcd47bb0bc157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a8f9c7203794cc695bcd47bb0bc157">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00886">886</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="aab152d1e44d088c50c74079c4661fd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab152d1e44d088c50c74079c4661fd84">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00892">892</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="af39eeba4c9bd01e2128d06c5f174adba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39eeba4c9bd01e2128d06c5f174adba">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00898">898</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a436f691c61c99d48cda1bbb7a16353ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436f691c61c99d48cda1bbb7a16353ee">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00904">904</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a5aa01c252c46b4f9ed044b3b54ea6a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa01c252c46b4f9ed044b3b54ea6a86">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00910">910</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="ab3eae0c97045cfb0af9107a71ae912f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eae0c97045cfb0af9107a71ae912f9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00916">916</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a35bae2a19d3624dda0eb9fa89f5bee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bae2a19d3624dda0eb9fa89f5bee0c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00922">922</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a57429fca1464dcda68e9eef990212b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57429fca1464dcda68e9eef990212b94">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00928">928</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a972d8bb67d41187b0c20cf9cd84bbc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972d8bb67d41187b0c20cf9cd84bbc2a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00934">934</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a1807e136ef4a774cdf620167d92c8125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1807e136ef4a774cdf620167d92c8125">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00940">940</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00772">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00773">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a15e75343df60924b4086f6c3f5b9d440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e75343df60924b4086f6c3f5b9d440">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00946">946</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00661">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l00662">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::b</a>.</p>

</div>
</div>
<a id="a22054e3eaa6b5261e2906094b9a2a687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22054e3eaa6b5261e2906094b9a2a687">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator+ </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00952">952</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00959">add()</a>.</p>

</div>
</div>
<a id="a337dc5abeb4b5ac7502c84b6726ec395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337dc5abeb4b5ac7502c84b6726ec395">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator+(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00959">959</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00952">operator+()</a>.</p>

</div>
</div>
<a id="afbdd7fb7b36b2cf3b64bda5111d28b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdd7fb7b36b2cf3b64bda5111d28b4e">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Add &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00966">966</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">Halide::Internal::add_would_overflow()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00083">Halide::Internal::IRMatcher::MatcherState::signed_integer_overflow</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">fuzz_test_rule()</a>.</p>

</div>
</div>
<a id="ad0a4cb65f0a03b2bd504543b36bd9817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a4cb65f0a03b2bd504543b36bd9817">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Add &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00974">974</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a21fd876acceaa7d5ecf7c52ce3fb847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fd876acceaa7d5ecf7c52ce3fb847b">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Add &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00980">980</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ab87772ce7641a946fb08359b977ec067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87772ce7641a946fb08359b977ec067">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator- </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00985">985</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01967">negate()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00992">sub()</a>.</p>

</div>
</div>
<a id="a8f2519d95c8671e7dd3bfaf00b1df2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2519d95c8671e7dd3bfaf00b1df2b0">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::sub </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator-(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00992">992</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00985">operator-()</a>.</p>

</div>
</div>
<a id="a5e9451c858ad2679ef5b735719ddd065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9451c858ad2679ef5b735719ddd065">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Sub &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00999">999</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00083">Halide::Internal::IRMatcher::MatcherState::signed_integer_overflow</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">Halide::Internal::sub_would_overflow()</a>.</p>

</div>
</div>
<a id="a31218a5a5b22ea9d423a526bf48b3197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31218a5a5b22ea9d423a526bf48b3197">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Sub &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01007">1007</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a160bccbd5b3260ff67658ea4d533952d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160bccbd5b3260ff67658ea4d533952d">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Sub &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01013">1013</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a2d830440f107dc41a1716783e211503a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d830440f107dc41a1716783e211503a">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator* </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01018">1018</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01025">mul()</a>.</p>

</div>
</div>
<a id="a40a9fbcfd2433ac643c9e2cb754b588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9fbcfd2433ac643c9e2cb754b588d">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::mul </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator*(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01025">1025</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01018">operator*()</a>.</p>

</div>
</div>
<a id="aa47740df91721e730d765b5472669f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47740df91721e730d765b5472669f11">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mul &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01032">1032</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">Halide::Internal::mul_would_overflow()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00083">Halide::Internal::IRMatcher::MatcherState::signed_integer_overflow</a>.</p>

</div>
</div>
<a id="a41a6c8f1d6156f6cd65f9a5521909ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a6c8f1d6156f6cd65f9a5521909ac6">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mul &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01040">1040</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a78e49735a398b8127b96e4d5713e571f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e49735a398b8127b96e4d5713e571f">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mul &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01046">1046</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a45261747b321afc0e81b7d92c48aa574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45261747b321afc0e81b7d92c48aa574">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator/ </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01051">1051</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01058">div()</a>.</p>

</div>
</div>
<a id="a383cd228eb518f611dbd291a516ad802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383cd228eb518f611dbd291a516ad802">&#9670;&nbsp;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::div </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator/(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01058">1058</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01051">operator/()</a>.</p>

</div>
</div>
<a id="a183445e4d4dca061c05996652f2dac5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183445e4d4dca061c05996652f2dac5b">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Div &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01063">1063</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00257">Halide::Internal::div_imp()</a>.</p>

</div>
</div>
<a id="a7a117db2cf577ff20571558dbe97bf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a117db2cf577ff20571558dbe97bf7f">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Div &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01068">1068</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00257">Halide::Internal::div_imp()</a>.</p>

</div>
</div>
<a id="ae4d8b67bef430b9df555bf291792614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d8b67bef430b9df555bf291792614f">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Div &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01073">1073</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00257">Halide::Internal::div_imp()</a>.</p>

</div>
</div>
<a id="a5bc1219661497d08a78d27e8750e11d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc1219661497d08a78d27e8750e11d0">&#9670;&nbsp;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator% </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01078">1078</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01085">mod()</a>.</p>

</div>
</div>
<a id="af6d085a252877ef3f8c139c13936075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d085a252877ef3f8c139c13936075c">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::mod </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator%(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01085">1085</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01078">operator%()</a>.</p>

<p class="reference">Referenced by <a class="el" href="gpu__context__common_8h_source.html#l00178">Halide::Internal::GPUCompilationCache&lt; ContextT, ModuleStateT &gt;::kernel_state_setup()</a>, and <a class="el" href="gpu__context__common_8h_source.html#l00211">Halide::Internal::GPUCompilationCache&lt; ContextT, ModuleStateT &gt;::release_hold()</a>.</p>

</div>
</div>
<a id="a49bb7e262c2c8f83476f33fa96ab4411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bb7e262c2c8f83476f33fa96ab4411">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mod &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01092">1092</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00236">Halide::Internal::mod_imp()</a>.</p>

</div>
</div>
<a id="ac259ecbd0cbade6ea8b16a03992de682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac259ecbd0cbade6ea8b16a03992de682">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mod &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01097">1097</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00236">Halide::Internal::mod_imp()</a>.</p>

</div>
</div>
<a id="acb5ce93cc0835cb6d4c79f2aa366ae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5ce93cc0835cb6d4c79f2aa366ae5d">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Mod &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01102">1102</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00236">Halide::Internal::mod_imp()</a>.</p>

</div>
</div>
<a id="a13d0f25c1cc3452f338fed00dbbc7006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d0f25c1cc3452f338fed00dbbc7006">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::min </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01107">1107</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01114">constant_fold_bin_op&lt; Min &gt;()</a>.</p>

</div>
</div>
<a id="a9f49f4ff4022205c07838918fd036ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f49f4ff4022205c07838918fd036ec2">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Min &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01114">1114</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01107">min()</a>.</p>

</div>
</div>
<a id="a0ee047ac24b43b0ea19cdc26ae9177a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee047ac24b43b0ea19cdc26ae9177a0">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Min &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01119">1119</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01107">min()</a>.</p>

</div>
</div>
<a id="a78e1f600078ba83441a1da2e360cc255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e1f600078ba83441a1da2e360cc255">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Min &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01124">1124</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01107">min()</a>.</p>

</div>
</div>
<a id="a40ac090f719272da825a4749e3feba0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ac090f719272da825a4749e3feba0f">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::max </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01129">1129</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01136">constant_fold_bin_op&lt; Max &gt;()</a>.</p>

</div>
</div>
<a id="a62dd8f17b989502f974f83eb229b318c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62dd8f17b989502f974f83eb229b318c">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Max &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01136">1136</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01129">max()</a>.</p>

</div>
</div>
<a id="a8986bb12c496cdc93b809e91f10613ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8986bb12c496cdc93b809e91f10613ad">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Max &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01141">1141</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01129">max()</a>.</p>

</div>
</div>
<a id="ab312d3c67fa31a253ca57f6420879d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab312d3c67fa31a253ca57f6420879d5f">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Max &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01146">1146</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01129">max()</a>.</p>

</div>
</div>
<a id="a833cce3a02abce0789516bf33049a4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833cce3a02abce0789516bf33049a4b0">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01151">1151</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01156">lt()</a>.</p>

</div>
</div>
<a id="ac4330ae468f2bc8bf764b4dc78093778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4330ae468f2bc8bf764b4dc78093778">&#9670;&nbsp;</a></span>lt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::lt </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator&lt;(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01156">1156</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01151">operator&lt;()</a>.</p>

</div>
</div>
<a id="ad59404f6a9be2edd1e7b087067186085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59404f6a9be2edd1e7b087067186085">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LT &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01161">1161</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a6f2f045c1fac015142c7849a2d0a6c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2f045c1fac015142c7849a2d0a6c0e">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LT &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01166">1166</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a90fd57e139aae6bc2a749b7dd7a2fa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fd57e139aae6bc2a749b7dd7a2fa5b">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LT &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01171">1171</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a51e553686bff1060ee43f34fd4802a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e553686bff1060ee43f34fd4802a23">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01176">1176</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01181">gt()</a>.</p>

</div>
</div>
<a id="a274ca018cc9aed19d368a2ee56c8592a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ca018cc9aed19d368a2ee56c8592a">&#9670;&nbsp;</a></span>gt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::gt </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator&gt;(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01181">1181</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01176">operator&gt;()</a>.</p>

</div>
</div>
<a id="aa21a7fd9d8ad2e8c69060a0ba114658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21a7fd9d8ad2e8c69060a0ba114658c">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GT &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01186">1186</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a6b98496c33623a602cfc21154a2c5a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b98496c33623a602cfc21154a2c5a4c">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GT &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01191">1191</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a88710908fc5963e4b0f13cf21bc8d406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88710908fc5963e4b0f13cf21bc8d406">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GT &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01196">1196</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a1f25a85f3e64642ba824e9bd9c455ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f25a85f3e64642ba824e9bd9c455ca3">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01201">1201</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01206">le()</a>.</p>

</div>
</div>
<a id="ac250b793aa021eccd179c53908dda5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac250b793aa021eccd179c53908dda5c4">&#9670;&nbsp;</a></span>le()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::le </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator&lt;=(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01206">1206</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01201">operator&lt;=()</a>.</p>

</div>
</div>
<a id="a2c526b5044511ee7ca7e9bcdcb1a69b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c526b5044511ee7ca7e9bcdcb1a69b6">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LE &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01211">1211</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ac8d4471ac09a360f80dd78b853300053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4471ac09a360f80dd78b853300053">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LE &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01216">1216</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a98d1b4920a766465287987573f8f6a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d1b4920a766465287987573f8f6a13">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; LE &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01221">1221</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a7d7a0be176f231cfdf8c62021bbda629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a0be176f231cfdf8c62021bbda629">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01226">1226</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01231">ge()</a>.</p>

</div>
</div>
<a id="aea49e0a06ecc1246107091521cbb3926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea49e0a06ecc1246107091521cbb3926">&#9670;&nbsp;</a></span>ge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::ge </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator&gt;=(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01231">1231</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01226">operator&gt;=()</a>.</p>

</div>
</div>
<a id="ab0a6bc166b2fb647aa37ee405b103547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a6bc166b2fb647aa37ee405b103547">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GE &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01236">1236</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a0de7f8aad5e2da6f956f9793c17b05a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7f8aad5e2da6f956f9793c17b05a2">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GE &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01241">1241</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ae0615b3c844f1bbbdc91d406c38a702f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0615b3c844f1bbbdc91d406c38a702f">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; GE &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01246">1246</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="af9d4ab05211a0d72975207ee6e0e4c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d4ab05211a0d72975207ee6e0e4c40">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator== </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01251">1251</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01256">eq()</a>.</p>

</div>
</div>
<a id="afda856931d657019ab52370ce9622ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda856931d657019ab52370ce9622ca9">&#9670;&nbsp;</a></span>eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::eq </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator==(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01256">1256</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01251">operator==()</a>.</p>

</div>
</div>
<a id="ae039e07269a504c112cccbbddad2abd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae039e07269a504c112cccbbddad2abd5">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; EQ &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01261">1261</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a369eaca268feef6557e2a11f3d3d44f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369eaca268feef6557e2a11f3d3d44f6">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; EQ &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01266">1266</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a77a3fec822b82e4550f36edcd0f94395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a3fec822b82e4550f36edcd0f94395">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; EQ &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01271">1271</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a7110bb296528fe0b4cd90b8a969fbf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7110bb296528fe0b4cd90b8a969fbf9c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">Halide::Internal::IRMatcher::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">CmpOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01276">1276</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01281">ne()</a>.</p>

</div>
</div>
<a id="a1b366748fa8c12e792e3ede293bdcbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b366748fa8c12e792e3ede293bdcbc4">&#9670;&nbsp;</a></span>ne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::ne </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>=(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01281">1281</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01276">operator!=()</a>.</p>

</div>
</div>
<a id="af1d31793eaf2c9bb7b2091ed268032cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d31793eaf2c9bb7b2091ed268032cd">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; NE &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01286">1286</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a88969b742de298fa4e89c1b7e0cd9507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88969b742de298fa4e89c1b7e0cd9507">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; NE &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01291">1291</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ac761e19f9cf67ff92b92350cb2f6b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac761e19f9cf67ff92b92350cb2f6b113">&#9670;&nbsp;</a></span>constant_fold_cmp_op&lt; NE &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01296">1296</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a6b766949dea9fe12a94f607a279b4845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b766949dea9fe12a94f607a279b4845">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator|| </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01301">1301</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01306">or_op()</a>.</p>

</div>
</div>
<a id="a0f6ef677a9266173fc51c21c0691a351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ef677a9266173fc51c21c0691a351">&#9670;&nbsp;</a></span>or_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::or_op </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator||(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01306">1306</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01301">operator||()</a>.</p>

</div>
</div>
<a id="ad6e3a69d10dc265ce7af23472b244e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e3a69d10dc265ce7af23472b244e7a">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Or &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01311">1311</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ac9551d885c2e22f2a7452adad11b9088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9551d885c2e22f2a7452adad11b9088">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Or &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01316">1316</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="af673f00fb1b63e823eba6f706412faf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af673f00fb1b63e823eba6f706412faf3">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; Or &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01321">1321</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a84b27a055ef4f01ea720a5601cc8acb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b27a055ef4f01ea720a5601cc8acb8">&#9670;&nbsp;</a></span>operator&amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">BinOp</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a>, decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01327">1327</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01332">and_op()</a>.</p>

</div>
</div>
<a id="a24e8bc42d079dd5a396862161982a040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e8bc42d079dd5a396862161982a040">&#9670;&nbsp;</a></span>and_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::and_op </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(IRMatcher::operator&amp;&amp;(a, b)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01332">1332</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01327">operator&amp;&amp;()</a>.</p>

</div>
</div>
<a id="a4b5bef8af3af1585ae4d230d4096ea7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5bef8af3af1585ae4d230d4096ea7e">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; And &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01337">1337</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a6d7c3ee7ce56b6e53ed07ee537ad0ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7c3ee7ce56b6e53ed07ee537ad0ae0">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; And &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01342">1342</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a90d065a5b95304e191321a47658e1da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d065a5b95304e191321a47658e1da7">&#9670;&nbsp;</a></span>constant_fold_bin_op&lt; And &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double <a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01347">1347</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="ade15fc322252444c511ae6458ee2e898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade15fc322252444c511ae6458ee2e898">&#9670;&nbsp;</a></span>bitwise_or_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> Halide::Internal::IRMatcher::bitwise_or_reduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01352">1352</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01357">bitwise_or_reduce()</a>.</p>

</div>
</div>
<a id="a86f76d20c53e195277c279e315c97e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f76d20c53e195277c279e315c97e75">&#9670;&nbsp;</a></span>bitwise_or_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> Halide::Internal::IRMatcher::bitwise_or_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01357">1357</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01352">bitwise_or_reduce()</a>.</p>

</div>
</div>
<a id="a67fba2b048ff9dfde5b4fd084ae4a6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fba2b048ff9dfde5b4fd084ae4a6de">&#9670;&nbsp;</a></span>and_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Halide::Internal::IRMatcher::and_reduce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01361">1361</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01366">and_reduce()</a>.</p>

</div>
</div>
<a id="ad156714bf9d1b4d9991b828dd4ae5b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad156714bf9d1b4d9991b828dd4ae5b38">&#9670;&nbsp;</a></span>and_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Halide::Internal::IRMatcher::and_reduce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01366">1366</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01361">and_reduce()</a>.</p>

</div>
</div>
<a id="aeeda156ac4dd5650fe120a1f0bae129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeda156ac4dd5650fe120a1f0bae129e">&#9670;&nbsp;</a></span>const_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Halide::Internal::IRMatcher::const_min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01371">1371</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="ac25115ad072f9d082bcc9bfc4c83399c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25115ad072f9d082bcc9bfc4c83399c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01484">1484</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01378">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::intrin</a>, and <a class="el" href="_i_r_match_8h_source.html#l01412">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::print_args()</a>.</p>

</div>
</div>
<a id="a2c1008f0c0246dd21c990ca1375513ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1008f0c0246dd21c990ca1375513ef">&#9670;&nbsp;</a></span>intrin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::intrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_call.html#a3643a3e5cf73435e07215fca17949974">Call::IntrinsicOp</a>&#160;</td>
          <td class="paramname"><em>intrinsic_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(args))...&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01492">1492</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a55178af5e3b02b5255a94e0569a3408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55178af5e3b02b5255a94e0569a3408c">&#9670;&nbsp;</a></span>widening_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::widening_add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01497">1497</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00558">Halide::Internal::Call::widening_add</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a6ce80d3e53d9314292ed9c4219486cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce80d3e53d9314292ed9c4219486cbe">&#9670;&nbsp;</a></span>widening_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::widening_sub </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01501">1501</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00562">Halide::Internal::Call::widening_sub</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a48bd76459b363b4941109dc8737c5dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bd76459b363b4941109dc8737c5dba">&#9670;&nbsp;</a></span>widening_mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::widening_mul </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01505">1505</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00559">Halide::Internal::Call::widening_mul</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a3f87c36110f9d7459d2cdd4ada22a557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f87c36110f9d7459d2cdd4ada22a557">&#9670;&nbsp;</a></span>saturating_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::saturating_add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01509">1509</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00545">Halide::Internal::Call::saturating_add</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="aa3f5a757e2b3168a4b06595410120e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f5a757e2b3168a4b06595410120e2b">&#9670;&nbsp;</a></span>saturating_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::saturating_sub </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01513">1513</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00546">Halide::Internal::Call::saturating_sub</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a616b22be350851606a059a0b62423e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616b22be350851606a059a0b62423e0c">&#9670;&nbsp;</a></span>halving_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::halving_add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01517">1517</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_8h_source.html#l00513">Halide::Internal::Call::halving_add</a>, and <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="aa264cecf50c3be3f61a5a74e6acae758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa264cecf50c3be3f61a5a74e6acae758">&#9670;&nbsp;</a></span>halving_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::halving_sub </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01521">1521</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_8h_source.html#l00514">Halide::Internal::Call::halving_sub</a>, and <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a32711f0db688217a84f12677e958a393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32711f0db688217a84f12677e958a393">&#9670;&nbsp;</a></span>rounding_halving_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::rounding_halving_add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01525">1525</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00541">Halide::Internal::Call::rounding_halving_add</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="af641aa947adc791b219a64405ff08467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641aa947adc791b219a64405ff08467">&#9670;&nbsp;</a></span>rounding_halving_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::rounding_halving_sub </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01529">1529</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00542">Halide::Internal::Call::rounding_halving_sub</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a02d73347f758b37e84dd96b2fa524032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d73347f758b37e84dd96b2fa524032">&#9670;&nbsp;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::shift_left </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01533">1533</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00549">Halide::Internal::Call::shift_left</a>.</p>

</div>
</div>
<a id="ab03704bed4c099f03d477e9cbe6ecf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03704bed4c099f03d477e9cbe6ecf96">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::shift_right </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01537">1537</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00550">Halide::Internal::Call::shift_right</a>.</p>

</div>
</div>
<a id="a024a849a0adf0cb90e57a54fcbc7e346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a849a0adf0cb90e57a54fcbc7e346">&#9670;&nbsp;</a></span>rounding_shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::rounding_shift_left </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01541">1541</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00543">Halide::Internal::Call::rounding_shift_left</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a32fb5637bd3165e3f741c207c0b8d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fb5637bd3165e3f741c207c0b8d175">&#9670;&nbsp;</a></span>rounding_shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::IRMatcher::rounding_shift_right </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Intrin</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01545">1545</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>, and <a class="el" href="_i_r_8h_source.html#l00544">Halide::Internal::Call::rounding_shift_right</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01430">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::make()</a>.</p>

</div>
</div>
<a id="a1221d76d53d37224ffeaf8e4e016044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1221d76d53d37224ffeaf8e4e016044e">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator! </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01590">1590</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01596">not_op()</a>.</p>

</div>
</div>
<a id="a60ababe61b897e02458abaa51ff96952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ababe61b897e02458abaa51ff96952">&#9670;&nbsp;</a></span>not_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::not_op </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1221d76d53d37224ffeaf8e4e016044e">IRMatcher::operator!</a>(a)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01596">1596</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01590">operator!()</a>.</p>

</div>
</div>
<a id="a9ad9a3678ae50d42223cc2609be3edc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad9a3678ae50d42223cc2609be3edc0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">NotOp</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01602">1602</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01552">Halide::Internal::IRMatcher::NotOp&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="aa3423872962efc0a52a5acdb3b7def67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3423872962efc0a52a5acdb3b7def67">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[25/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt; C, T, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01660">1660</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01610">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::c</a>, <a class="el" href="_i_r_match_8h_source.html#l01612">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::f</a>, and <a class="el" href="_i_r_match_8h_source.html#l01611">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::t</a>.</p>

</div>
</div>
<a id="a99f94a63ffe179595c2f5479d053d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f94a63ffe179595c2f5479d053d3ba">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::select </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">SelectOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(t)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(f))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01666">1666</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a74066c23269bdeeb81ff66d53620278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74066c23269bdeeb81ff66d53620278a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[26/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01733">1733</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01676">Halide::Internal::IRMatcher::BroadcastOp&lt; A, B &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l01677">Halide::Internal::IRMatcher::BroadcastOp&lt; A, B &gt;::lanes</a>.</p>

</div>
</div>
<a id="a9922c231b05db372ed6a96007a2d6a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9922c231b05db372ed6a96007a2d6a20">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::broadcast </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">BroadcastOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01739">1739</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a724ad26f2d5a2276ee7ef51cfd743a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724ad26f2d5a2276ee7ef51cfd743a4b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[27/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt; A, B, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01797">1797</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01747">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;::a</a>, <a class="el" href="_i_r_match_8h_source.html#l01748">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;::b</a>, and <a class="el" href="_i_r_match_8h_source.html#l01749">Halide::Internal::IRMatcher::RampOp&lt; A, B, C &gt;::lanes</a>.</p>

</div>
</div>
<a id="a431f2d238dfcffbd0c3451ef90232877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431f2d238dfcffbd0c3451ef90232877">&#9670;&nbsp;</a></span>ramp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::ramp </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">RampOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(b)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(c))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01803">1803</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_hexagon_alignment_8h_source.html#l00027">Halide::Internal::HexagonAlignmentAnalyzer::is_aligned_impl()</a>.</p>

</div>
</div>
<a id="affcb9e9e2259676b29030d913d838758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb9e9e2259676b29030d913d838758">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[28/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , VectorReduce::Operator reduce_op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt; A, B, reduce_op &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01855">1855</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01813">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, B, reduce_op &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l01814">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, B, reduce_op &gt;::lanes</a>.</p>

</div>
</div>
<a id="ad6723cb8cab78dc4c8f379e3c83a8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6723cb8cab78dc4c8f379e3c83a8360">&#9670;&nbsp;</a></span>h_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::h_add </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a16ec0621eb057662b7f7d001dbd0da01">VectorReduce::Add</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01861">1861</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="ad6067256015c2d4afa44d97cb8eda1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6067256015c2d4afa44d97cb8eda1e6">&#9670;&nbsp;</a></span>h_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::h_min </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a0abcd93c020ca8bae3babbfc837e8f02">VectorReduce::Min</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01867">1867</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a9921a69b5feab00a02588a95d2f450cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9921a69b5feab00a02588a95d2f450cb">&#9670;&nbsp;</a></span>h_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::h_max </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27af60bd97c582326c966cc33190093b82d">VectorReduce::Max</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01873">1873</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a27178171a8cfdc63ef6273eabe81ad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27178171a8cfdc63ef6273eabe81ad93">&#9670;&nbsp;</a></span>h_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::h_and </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a3507ab281fc9d4d92dd7ae852526fc23">VectorReduce::And</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01879">1879</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a8c7f03a2bb65c45f200332b34be7a589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7f03a2bb65c45f200332b34be7a589">&#9670;&nbsp;</a></span>h_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::h_or </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">VectorReduceOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(lanes)), <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27a79f25cf9b2e8a9b72cca870af08ed32b">VectorReduce::Or</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01885">1885</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="af6144c2094a04fc0650b13e88c8cb0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6144c2094a04fc0650b13e88c8cb0e7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[29/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01955">1955</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01893">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="afd99c19b0522f947c719b3995ffe70cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd99c19b0522f947c719b3995ffe70cb">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::operator- </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">NegateOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01961">1961</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a1e62d8f98688b2d727534fbf22289f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e62d8f98688b2d727534fbf22289f2c">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::negate </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; decltype(IRMatcher::operator-(a)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l01967">1967</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00985">operator-()</a>.</p>

</div>
</div>
<a id="adbcf314c678215e84e8af4eef15a6a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcf314c678215e84e8af4eef15a6a21">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[30/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02007">2007</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l01976">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l01975">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::t</a>.</p>

</div>
</div>
<a id="a548d0224c06bd3698a5bc689a8c61fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548d0224c06bd3698a5bc689a8c61fb6">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">CastOp</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02013">2013</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cmdline_8h_source.html#l00129">cmdline::detail::lexical_cast()</a>, and <a class="el" href="_i_r_match_8h_source.html#l01999">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::make()</a>.</p>

</div>
</div>
<a id="a606c85092b9877e71685d7cf5e41ab31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606c85092b9877e71685d7cf5e41ab31">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::fold </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02062">2062</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a443d1c29beb1d2d9560984699366f67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443d1c29beb1d2d9560984699366f67d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[31/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Fold</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02068">2068</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02021">Halide::Internal::IRMatcher::Fold&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="a54edd4eb65abe7517ce70567983e7b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54edd4eb65abe7517ce70567983e7b42">&#9670;&nbsp;</a></span>overflows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::overflows </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02099">2099</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a8af40420f92ca04ccdc2bd5ed78687fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af40420f92ca04ccdc2bd5ed78687fc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[32/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Overflows</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02105">2105</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02076">Halide::Internal::IRMatcher::Overflows&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="a6b0be969cbc9fde866414c2a7bd07648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0be969cbc9fde866414c2a7bd07648">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[33/39]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Overflow</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02144">2144</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a28433cdc327c82a5cad11ca6e051ea75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28433cdc327c82a5cad11ca6e051ea75">&#9670;&nbsp;</a></span>is_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_const </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02175">2175</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_8h_source.html#l00197">halide_handle_cplusplus_type::make()</a>, and <a class="el" href="_i_r_match_8h_source.html#l02165">Halide::Internal::IRMatcher::IsConst&lt; A &gt;::make_folded_const()</a>.</p>

</div>
</div>
<a id="abb2ecf97f86f365e0346423805eaf05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2ecf97f86f365e0346423805eaf05a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[34/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">IsConst</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02181">2181</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02160">Halide::Internal::IRMatcher::IsConst&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="afc9f4c30615143a322274dab09e1829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9f4c30615143a322274dab09e1829c">&#9670;&nbsp;</a></span>can_prove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Prover &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::can_prove </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Prover *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a)), Prover&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02213">2213</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a3d02ed6452c98a876e00e56486f131c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d02ed6452c98a876e00e56486f131c3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[35/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Prover &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">CanProve</a>&lt; A, Prover &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02219">2219</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02189">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;::a</a>.</p>

</div>
</div>
<a id="a772465f4fe4374660084eea333ed6bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772465f4fe4374660084eea333ed6bc9">&#9670;&nbsp;</a></span>is_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_float </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02250">2250</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a40f605385d281d571e62de8fd0a5f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f605385d281d571e62de8fd0a5f008">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[36/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">IsFloat</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02256">2256</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02227">Halide::Internal::IRMatcher::IsFloat&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="a14df3b22fe777586f70976c61ccb1209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14df3b22fe777586f70976c61ccb1209">&#9670;&nbsp;</a></span>is_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_int </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a4">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02288">2288</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a314fa7fbb059cac25c8aa55249c16082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314fa7fbb059cac25c8aa55249c16082">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[37/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_int.html">IsInt</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02294">2294</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02264">Halide::Internal::IRMatcher::IsInt&lt; A &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l02265">Halide::Internal::IRMatcher::IsInt&lt; A &gt;::bits</a>.</p>

</div>
</div>
<a id="aab363d6d7c4dfb66dd0b24d0ad9235d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab363d6d7c4dfb66dd0b24d0ad9235d1">&#9670;&nbsp;</a></span>is_uint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_uint </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02330">2330</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="adb708c84d454bda71c6652d7d6a578f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb708c84d454bda71c6652d7d6a578f2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[38/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_u_int.html">IsUInt</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02336">2336</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02306">Halide::Internal::IRMatcher::IsUInt&lt; A &gt;::a</a>, and <a class="el" href="_i_r_match_8h_source.html#l02307">Halide::Internal::IRMatcher::IsUInt&lt; A &gt;::bits</a>.</p>

</div>
</div>
<a id="a5f0455ea7d220c198c585b7651e74f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0455ea7d220c198c585b7651e74f55">&#9670;&nbsp;</a></span>is_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_scalar </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02371">2371</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a222c889d7baed380d66d0d58c32a1714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222c889d7baed380d66d0d58c32a1714">&#9670;&nbsp;</a></span>is_max_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_max_value </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_max_value.html">IsMaxValue</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02406">2406</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a9f17def21287dbec4a6511400c023e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f17def21287dbec4a6511400c023e56">&#9670;&nbsp;</a></span>is_min_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::is_min_value </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_min_value.html">IsMinValue</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(a))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02443">2443</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a4bf29e2fe3f26dce7eea989ea060baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf29e2fe3f26dce7eea989ea060baa7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[39/39]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::IRMatcher::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_scalar.html">IsScalar</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02449">2449</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l02348">Halide::Internal::IRMatcher::IsScalar&lt; A &gt;::a</a>.</p>

</div>
</div>
<a id="aa0f60c82d8daf8da2c27b3497c6c083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f60c82d8daf8da2c27b3497c6c083f">&#9670;&nbsp;</a></span>fuzz_test_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                            std::decay&lt;After&gt;::type::foldable&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> void Halide::Internal::IRMatcher::fuzz_test_rule </td>
          <td>(</td>
          <td class="paramtype">Before &amp;&amp;&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">After &amp;&amp;&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>wildcard_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02460">2460</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">Halide::abs()</a>, <a class="el" href="_i_r_match_8h_source.html#l00966">constant_fold_bin_op&lt; Add &gt;()</a>, <a class="el" href="_i_r_match_8h_source.html#l02591">evaluate_predicate()</a>, <a class="el" href="_halide_runtime_8h_source.html#l01588">halide_scalar_value_t::f64</a>, <a class="el" href="_i_r_match_8h_source.html#l00094">Halide::Internal::IRMatcher::MatcherState::get_binding()</a>, <a class="el" href="_i_r_match_8h_source.html#l00123">Halide::Internal::IRMatcher::MatcherState::get_bound_const()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00412">halide_type_bfloat</a>, <a class="el" href="_halide_runtime_8h_source.html#l00410">halide_type_float</a>, <a class="el" href="_halide_runtime_8h_source.html#l00408">halide_type_int</a>, <a class="el" href="_halide_runtime_8h_source.html#l00409">halide_type_uint</a>, <a class="el" href="_halide_runtime_8h_source.html#l01582">halide_scalar_value_t::i64</a>, <a class="el" href="_errors_8h_source.html#l00023">internal_error</a>, <a class="el" href="_halide_runtime_8h_source.html#l00446">halide_type_t::lanes</a>, <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">Halide::Internal::make_const()</a>, <a class="el" href="_i_r_match_8h_source.html#l00156">make_const_expr()</a>, <a class="el" href="_i_r_match_8h_source.html#l00070">max_wild</a>, <a class="el" href="_i_r_match_8h_source.html#l00089">Halide::Internal::IRMatcher::MatcherState::set_binding()</a>, <a class="el" href="_i_r_match_8h_source.html#l00099">Halide::Internal::IRMatcher::MatcherState::set_bound_const()</a>, <a class="el" href="_i_r_match_8h_source.html#l00084">Halide::Internal::IRMatcher::MatcherState::special_values_mask</a>, <a class="el" href="structhalide__scalar__value__t.html#a9c0e03e5918800866c4d2e31e467105b">halide_scalar_value_t::u</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01586">halide_scalar_value_t::u64</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02639">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>.</p>

</div>
</div>
<a id="a440cc0cc987c622f2361638a3d310170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440cc0cc987c622f2361638a3d310170">&#9670;&nbsp;</a></span>fuzz_test_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;!(std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                              std::decay&lt;After&gt;::type::foldable)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void Halide::Internal::IRMatcher::fuzz_test_rule </td>
          <td>(</td>
          <td class="paramtype">Before &amp;&amp;&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">After &amp;&amp;&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02585">2585</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a id="a17c3af3849b20aa80caa9ceeb4d67b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c3af3849b20aa80caa9ceeb4d67b66">&#9670;&nbsp;</a></span>evaluate_predicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::IRMatcher::evaluate_predicate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02591">2591</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">fuzz_test_rule()</a>, and <a class="el" href="_i_r_match_8h_source.html#l02705">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>.</p>

</div>
</div>
<a id="aef18091a070c6c3f362c6ca55e75c2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef18091a070c6c3f362c6ca55e75c2db">&#9670;&nbsp;</a></span>evaluate_predicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern , typename  = typename enable_if_pattern&lt;Pattern&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool Halide::Internal::IRMatcher::evaluate_predicate </td>
          <td>(</td>
          <td class="paramtype">Pattern&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">MatcherState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02597">2597</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00446">halide_type_t::lanes</a>, <a class="el" href="_i_r_match_8h_source.html#l00084">Halide::Internal::IRMatcher::MatcherState::special_values_mask</a>, <a class="el" href="structhalide__scalar__value__t.html#a9c0e03e5918800866c4d2e31e467105b">halide_scalar_value_t::u</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01586">halide_scalar_value_t::u64</a>.</p>

</div>
</div>
<a id="a02dfea57650e9742f5aed422e6be5a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dfea57650e9742f5aed422e6be5a58">&#9670;&nbsp;</a></span>rewriter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::rewriter </td>
          <td>(</td>
          <td class="paramtype">Instance&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>wildcard_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression. </p>
<p>The second optional argument (wildcard_type) is a hint as to what the type of the wildcards is likely to be. If omitted it uses the same type as the expression itself. They are not required to be this type, but the rule will only be tested for wildcards of that type when testing is enabled.</p>
<p>The rewriter can be used to check to see if the instance is one of some number of patterns and if so rewrite it into another form, using its operator() method. See Simplify.cpp for a bunch of example usage.</p>
<p>Important: Any Exprs in patterns are captured by reference, not by value, so ensure they outlive the rewriter. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02798">2798</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a54abcfed7ab37a4c726020c119d0efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54abcfed7ab37a4c726020c119d0efff">&#9670;&nbsp;</a></span>rewriter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::rewriter </td>
          <td>(</td>
          <td class="paramtype">Instance&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(instance))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02804">2804</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="aaeb4726f950a627f1361e2bdb1fb98a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4726f950a627f1361e2bdb1fb98a2">&#9670;&nbsp;</a></span>rewriter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::rewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>wildcard_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02809">2809</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<a id="a54caa0633d17c57ea0df1aa5bdca3850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54caa0633d17c57ea0df1aa5bdca3850">&#9670;&nbsp;</a></span>rewriter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto Halide::Internal::IRMatcher::rewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Rewriter</a>&lt;decltype(<a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">pattern_arg</a>(e))&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l02814">2814</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_match_8h_source.html#l00598">pattern_arg()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6feb6895f4d41d350eda704b7e3cc4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6feb6895f4d41d350eda704b7e3cc4bc">&#9670;&nbsp;</a></span>max_wild</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Halide::Internal::IRMatcher::max_wild = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_match_8h_source.html#l00070">70</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">fuzz_test_rule()</a>, <a class="el" href="_i_r_match_8h_source.html#l00241">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l00307">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;::match()</a>, <a class="el" href="_i_r_match_8h_source.html#l00360">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;::match()</a>, and <a class="el" href="_i_r_match_8h_source.html#l00414">Halide::Internal::IRMatcher::WildConst&lt; i &gt;::match()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html">IRMatcher</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
