<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: /Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/BoundaryConditions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_boundary_conditions_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BoundaryConditions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for imposing boundary conditions on Halide::Funcs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_expr_8h_source.html">Expr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_func_8h_source.html">Func.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_lambda_8h_source.html">Lambda.h</a>&quot;</code><br />
</div>
<p><a href="_boundary_conditions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">Halide::BoundaryConditions</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_boundary_conditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Funcs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html">Halide::BoundaryConditions::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaac6050d1e4177e4bf8cbeb62f581b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#aaac6050d1e4177e4bf8cbeb62f581b10">Halide::BoundaryConditions::Internal::collect_region</a> (Region &amp;collected_args, const Expr &amp;a1, const Expr &amp;a2)</td></tr>
<tr class="separator:aaac6050d1e4177e4bf8cbeb62f581b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8999a4092bae996a7c6ab807a0ee2c75"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8999a4092bae996a7c6ab807a0ee2c75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a8999a4092bae996a7c6ab807a0ee2c75">Halide::BoundaryConditions::Internal::collect_region</a> (Region &amp;collected_args, const Expr &amp;a1, const Expr &amp;a2, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a8999a4092bae996a7c6ab807a0ee2c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72afc90ec442417063c57e86a026ef6d"><td class="memItemLeft" align="right" valign="top">const Func &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a72afc90ec442417063c57e86a026ef6d">Halide::BoundaryConditions::Internal::func_like_to_func</a> (const Func &amp;func)</td></tr>
<tr class="separator:a72afc90ec442417063c57e86a026ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69438e0edca0f3277b51eb0507657de6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69438e0edca0f3277b51eb0507657de6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a69438e0edca0f3277b51eb0507657de6">Halide::BoundaryConditions::Internal::func_like_to_func</a> (const T &amp;func_like)</td></tr>
<tr class="separator:a69438e0edca0f3277b51eb0507657de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed713b5f9a6f13e6323f2a21d41d5e"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aa4ed713b5f9a6f13e6323f2a21d41d5e">Halide::BoundaryConditions::constant_exterior</a> (const Func &amp;source, const Tuple &amp;value, const Region &amp;bounds)</td></tr>
<tr class="memdesc:aa4ed713b5f9a6f13e6323f2a21d41d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#aa4ed713b5f9a6f13e6323f2a21d41d5e">More...</a><br /></td></tr>
<tr class="separator:aa4ed713b5f9a6f13e6323f2a21d41d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c80a6fd67303ec5ed34a74ad16a134e"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6c80a6fd67303ec5ed34a74ad16a134e">Halide::BoundaryConditions::constant_exterior</a> (const Func &amp;source, const Expr &amp;value, const Region &amp;bounds)</td></tr>
<tr class="separator:a6c80a6fd67303ec5ed34a74ad16a134e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbd32864dae3a3704210dc69095086c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecbd32864dae3a3704210dc69095086c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aecbd32864dae3a3704210dc69095086c">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Tuple &amp;value, const Region &amp;bounds)</td></tr>
<tr class="separator:aecbd32864dae3a3704210dc69095086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e995c1d77ee4b3a7bf69a676f7aa6b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e995c1d77ee4b3a7bf69a676f7aa6b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0e995c1d77ee4b3a7bf69a676f7aa6b1">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Expr &amp;value, const Region &amp;bounds)</td></tr>
<tr class="separator:a0e995c1d77ee4b3a7bf69a676f7aa6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdfbe04f841ef4a03d29eff1a4d841d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8cdfbe04f841ef4a03d29eff1a4d841d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8cdfbe04f841ef4a03d29eff1a4d841d">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Tuple &amp;value)</td></tr>
<tr class="separator:a8cdfbe04f841ef4a03d29eff1a4d841d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7942af4d7357b82b1b7b1ab2260bef0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7942af4d7357b82b1b7b1ab2260bef0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad7942af4d7357b82b1b7b1ab2260bef0">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Expr &amp;value)</td></tr>
<tr class="separator:ad7942af4d7357b82b1b7b1ab2260bef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada39ff2d1fa601957cf95a1c40870c80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ada39ff2d1fa601957cf95a1c40870c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ada39ff2d1fa601957cf95a1c40870c80">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Tuple &amp;value, Bounds &amp;&amp;...bounds)</td></tr>
<tr class="separator:ada39ff2d1fa601957cf95a1c40870c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada26628c2032da73f1e6df92cff96272"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ada26628c2032da73f1e6df92cff96272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ada26628c2032da73f1e6df92cff96272">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, const Expr &amp;value, Bounds &amp;&amp;...bounds)</td></tr>
<tr class="separator:ada26628c2032da73f1e6df92cff96272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0548f23db36e4a8a03690bc8bee1e850"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0548f23db36e4a8a03690bc8bee1e850">Halide::BoundaryConditions::repeat_edge</a> (const Func &amp;source, const Region &amp;bounds)</td></tr>
<tr class="memdesc:a0548f23db36e4a8a03690bc8bee1e850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="namespace_halide_1_1_boundary_conditions.html#a0548f23db36e4a8a03690bc8bee1e850">More...</a><br /></td></tr>
<tr class="separator:a0548f23db36e4a8a03690bc8bee1e850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49414651fa6a33195c8a768abb2aa327"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49414651fa6a33195c8a768abb2aa327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a49414651fa6a33195c8a768abb2aa327">Halide::BoundaryConditions::repeat_edge</a> (const T &amp;func_like, const Region &amp;bounds)</td></tr>
<tr class="separator:a49414651fa6a33195c8a768abb2aa327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#af552f8e2d722e1248cf4d0a8027a81df">Halide::BoundaryConditions::repeat_edge</a> (const T &amp;func_like)</td></tr>
<tr class="separator:af552f8e2d722e1248cf4d0a8027a81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a68c503d5d143eddfa60a6d6f47542b"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2a68c503d5d143eddfa60a6d6f47542b">Halide::BoundaryConditions::repeat_image</a> (const Func &amp;source, const Region &amp;bounds)</td></tr>
<tr class="memdesc:a2a68c503d5d143eddfa60a6d6f47542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#a2a68c503d5d143eddfa60a6d6f47542b">More...</a><br /></td></tr>
<tr class="separator:a2a68c503d5d143eddfa60a6d6f47542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6428b6477376dbd637acf3d9944b87f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6428b6477376dbd637acf3d9944b87f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae6428b6477376dbd637acf3d9944b87f">Halide::BoundaryConditions::repeat_image</a> (const T &amp;func_like, const Region &amp;bounds)</td></tr>
<tr class="separator:ae6428b6477376dbd637acf3d9944b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8c53aee37e3c73c1b57f69a3ee17a29e">Halide::BoundaryConditions::repeat_image</a> (const T &amp;func_like)</td></tr>
<tr class="separator:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb291f78aaf6f622d7b46c5a49340f7"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aaeb291f78aaf6f622d7b46c5a49340f7">Halide::BoundaryConditions::mirror_image</a> (const Func &amp;source, const Region &amp;bounds)</td></tr>
<tr class="memdesc:aaeb291f78aaf6f622d7b46c5a49340f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same.  <a href="namespace_halide_1_1_boundary_conditions.html#aaeb291f78aaf6f622d7b46c5a49340f7">More...</a><br /></td></tr>
<tr class="separator:aaeb291f78aaf6f622d7b46c5a49340f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a866786bf357a149066a6eb5a16275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49a866786bf357a149066a6eb5a16275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a49a866786bf357a149066a6eb5a16275">Halide::BoundaryConditions::mirror_image</a> (const T &amp;func_like, const Region &amp;bounds)</td></tr>
<tr class="separator:a49a866786bf357a149066a6eb5a16275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#add16db9977891439ac354596aa8208dc">Halide::BoundaryConditions::mirror_image</a> (const T &amp;func_like)</td></tr>
<tr class="separator:add16db9977891439ac354596aa8208dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7cb19239d6058086f711ad2636dd6"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a77d7cb19239d6058086f711ad2636dd6">Halide::BoundaryConditions::mirror_interior</a> (const Func &amp;source, const Region &amp;bounds)</td></tr>
<tr class="memdesc:a77d7cb19239d6058086f711ad2636dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="namespace_halide_1_1_boundary_conditions.html#a77d7cb19239d6058086f711ad2636dd6">More...</a><br /></td></tr>
<tr class="separator:a77d7cb19239d6058086f711ad2636dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7320ce02d786a250572bef29c84497e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7320ce02d786a250572bef29c84497e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae7320ce02d786a250572bef29c84497e">Halide::BoundaryConditions::mirror_interior</a> (const T &amp;func_like, const Region &amp;bounds)</td></tr>
<tr class="separator:ae7320ce02d786a250572bef29c84497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0141a01322201a6c9ef2bd93c39aa6bd">Halide::BoundaryConditions::mirror_interior</a> (const T &amp;func_like)</td></tr>
<tr class="separator:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for imposing boundary conditions on Halide::Funcs. </p>

<p class="definition">Definition in file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_boundary_conditions_8h.html">BoundaryConditions.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
