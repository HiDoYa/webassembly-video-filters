<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: /Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/Generator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_generator_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generator is a class used to encapsulate the building of Funcs in user pipelines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_external_code_8h_source.html">ExternalCode.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_func_8h_source.html">Func.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_image_param_8h_source.html">ImageParam.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_introspection_8h_source.html">Introspection.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_object_instance_registry_8h_source.html">ObjectInstanceRegistry.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_target_8h_source.html">Target.h</a>&quot;</code><br />
</div>
<p><a href="_generator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html">Halide::Internal::ValueTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html" title="ValueTracker is an internal utility class that attempts to track and flag certain obvious Stub-relate...">ValueTracker</a> is an internal utility class that attempts to track and flag certain obvious Stub-related errors at <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> compile time: it tracks the constraints set on any Parameter-based argument (i.e., Input&lt;Buffer&gt; and Output&lt;Buffer&gt;) to ensure that incompatible values aren't set.  <a href="class_halide_1_1_internal_1_1_value_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">Halide::Internal::cond&lt; B, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">Halide::Internal::select_type&lt; First, Rest &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">Halide::Internal::select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">Halide::Internal::GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Halide::Internal::Convert&lt; FROM, TO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">Halide::Internal::GeneratorParamImpl&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">Halide::Internal::GeneratorParam_Target&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">Halide::Internal::GeneratorParam_MachineParams&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">Halide::Internal::GeneratorParam_LoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">Halide::Internal::GeneratorParam_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">Halide::Internal::GeneratorParam_Bool&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">Halide::Internal::GeneratorParam_Enum&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">Halide::Internal::GeneratorParam_Type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">Halide::Internal::GeneratorParam_String&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_param.html">Halide::GeneratorParam&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a> is a templated class that can be used to modify the behavior of the <a class="el" href="class_halide_1_1_generator.html">Generator</a> at code-generation time.  <a href="class_halide_1_1_generator_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html">Halide::Internal::StubInputBuffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html" title="StubInputBuffer is the placeholder that a Stub uses when it requires a Buffer for an input (rather th...">StubInputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an input (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>).  <a href="class_halide_1_1_internal_1_1_stub_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer_base.html">Halide::Internal::StubOutputBufferBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html">Halide::Internal::StubOutputBuffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html" title="StubOutputBuffer is the placeholder that a Stub uses when it requires a Buffer for an output (rather ...">StubOutputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an output (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>).  <a href="class_halide_1_1_internal_1_1_stub_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input.html">Halide::Internal::StubInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html">Halide::Internal::GIOBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html" title="GIOBase is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not pa...">GIOBase</a> is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not part of the public API and should never be used directly by user code.  <a href="class_halide_1_1_internal_1_1_g_i_o_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_base.html">Halide::Internal::GeneratorInputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_impl.html">Halide::Internal::GeneratorInputImpl&lt; T, ValueType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">Halide::Internal::GeneratorInput_Func&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">Halide::Internal::GeneratorInput_Scalar&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">Halide::Internal::GeneratorInput_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1type__sink.html">Halide::Internal::type_sink&lt; typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">Halide::Internal::has_static_halide_type_method&lt; T2, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method_3_01_t2_00_01typename_01type__si902d603523cc7c0df71b135e75cbe224.html">Halide::Internal::has_static_halide_type_method&lt; T2, typename type_sink&lt; decltype(T2::static_halide_type())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_input.html">Halide::GeneratorInput&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_base.html">Halide::Internal::GeneratorOutputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_impl.html">Halide::Internal::GeneratorOutputImpl&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">Halide::Internal::GeneratorOutput_Buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">Halide::Internal::GeneratorOutput_Func&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">Halide::Internal::GeneratorOutput_Arithmetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_output.html">Halide::GeneratorOutput&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___synthetic.html">Halide::Internal::GeneratorParam_Synthetic&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_context.html" title="GeneratorContext is a base class that is used when using Generators (or Stubs) directly; it is used t...">GeneratorContext</a> is a base class that is used when using Generators (or Stubs) directly; it is used to allow the outer context (typically, either a <a class="el" href="class_halide_1_1_generator.html">Generator</a> or "top-level" code) to specify certain information to the inner context to ensure that inner and outer Generators are compiled in a compatible way.  <a href="class_halide_1_1_generator_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_names_interface.html">Halide::NamesInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations.html">Halide::Internal::NoRealizations&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_4.html">Halide::Internal::NoRealizations&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_01_t_00_01_args_8_8_8_01_4.html">Halide::Internal::NoRealizations&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">Halide::Internal::StringOrLoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_info.html">Halide::Internal::GeneratorParamInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">Halide::Internal::GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">Halide::Internal::GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator.html">Halide::Generator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_stub.html">Halide::Internal::GeneratorStub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_generator_stub_1_1_names.html">Halide::Internal::GeneratorStub::Names</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_generator_min_max"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">Halide::Internal::GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehalide__register__generator"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehalide__register__generator.html">halide_register_generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a08dae13ee17f505472e95d3bcaec9984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a08dae13ee17f505472e95d3bcaec9984">HALIDE_GENERATOR_PARAM_TYPED_SETTER</a>(TYPE)&#160;&#160;&#160;    virtual void set(const TYPE &amp;new_value) = 0;</td></tr>
<tr class="separator:a08dae13ee17f505472e95d3bcaec9984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dae13ee17f505472e95d3bcaec9984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a08dae13ee17f505472e95d3bcaec9984">HALIDE_GENERATOR_PARAM_TYPED_SETTER</a>(TYPE)</td></tr>
<tr class="separator:a08dae13ee17f505472e95d3bcaec9984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f">HALIDE_FORWARD_METHOD</a>(Class,  Method)</td></tr>
<tr class="separator:a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cefa62995eaf97e7a6795e159d7e245"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a3cefa62995eaf97e7a6795e159d7e245">HALIDE_FORWARD_METHOD_CONST</a>(Class,  Method)</td></tr>
<tr class="separator:a3cefa62995eaf97e7a6795e159d7e245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856471e468d66102a7f7c3384e7bf3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME,  FULLY_QUALIFIED_STUB_NAME)</td></tr>
<tr class="separator:a5856471e468d66102a7f7c3384e7bf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a745ace50c85e1e1086beda5bd7598d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a9a745ace50c85e1e1086beda5bd7598d">_HALIDE_REGISTER_GENERATOR2</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, GEN_REGISTRY_NAME)</td></tr>
<tr class="separator:a9a745ace50c85e1e1086beda5bd7598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b1d1e407c4804e430152a081194e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#ad4b1d1e407c4804e430152a081194e99">_HALIDE_REGISTER_GENERATOR3</a>(GEN_CLASS_NAME,  GEN_REGISTRY_NAME,  FULLY_QUALIFIED_STUB_NAME)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, FULLY_QUALIFIED_STUB_NAME)</td></tr>
<tr class="separator:ad4b1d1e407c4804e430152a081194e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569beb9a7e98718b004aee7c10f0467"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a>(_1,  _2,  _3,  COUNT, ...)&#160;&#160;&#160;    COUNT</td></tr>
<tr class="separator:a9569beb9a7e98718b004aee7c10f0467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64059dca539cf5f3f7e4c642af576ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>(ARGS)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a> ARGS</td></tr>
<tr class="separator:a64059dca539cf5f3f7e4c642af576ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebb701e7b5841c0e6202138cdb5dff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(...)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>((__VA_ARGS__, 3, 2, 1, 0))</td></tr>
<tr class="separator:ab1ebb701e7b5841c0e6202138cdb5dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3703de57adb30a5044367a8eccb822b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;    _HALIDE_REGISTER_GENERATOR##COUNT</td></tr>
<tr class="separator:a3703de57adb30a5044367a8eccb822b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247774bd287d01a3081de190905019c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)</td></tr>
<tr class="separator:a247774bd287d01a3081de190905019c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e49dea0ba50a51195521ede9c0b20c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(COUNT)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)</td></tr>
<tr class="separator:a33e49dea0ba50a51195521ede9c0b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940f7c9be73066885cb3a5d29e7cbd55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(A,  B)&#160;&#160;&#160;    A B</td></tr>
<tr class="separator:a940f7c9be73066885cb3a5d29e7cbd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76205e384e3152f5eda423c56accbc54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(...)&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(<a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(<a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(__VA_ARGS__)), (__VA_ARGS__))</td></tr>
<tr class="separator:a76205e384e3152f5eda423c56accbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae85638c44eb4fa948399c7b9003bf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_generator_8h.html#a2ae85638c44eb4fa948399c7b9003bf4">HALIDE_REGISTER_GENERATOR_ALIAS</a>(GEN_REGISTRY_NAME,  ORIGINAL_REGISTRY_NAME, ...)</td></tr>
<tr class="separator:a2ae85638c44eb4fa948399c7b9003bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40a4f8fc5c4fcce2e0b5656bd6c831bb">Halide::Internal::GeneratorParamImplBase</a> = typename select_type&lt; cond&lt; std::is_same&lt; T, Target &gt;::value, GeneratorParam_Target&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, MachineParams &gt;::value, GeneratorParam_MachineParams&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, LoopLevel &gt;::value, GeneratorParam_LoopLevel &gt;, cond&lt; std::is_same&lt; T, std::string &gt;::value, GeneratorParam_String&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, Type &gt;::value, GeneratorParam_Type&lt; T &gt; &gt;, cond&lt; std::is_same&lt; T, bool &gt;::value, GeneratorParam_Bool&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; T &gt;::value, GeneratorParam_Arithmetic&lt; T &gt; &gt;, cond&lt; std::is_enum&lt; T &gt;::value, GeneratorParam_Enum&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebc4e1b658e316d9738ac723778525e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:aaebc4e1b658e316d9738ac723778525e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaebc4e1b658e316d9738ac723778525e">Halide::Internal::GeneratorInputImplBase</a> = typename select_type&lt; cond&lt; has_static_halide_type_method&lt; TBase &gt;::value, GeneratorInput_Buffer&lt; T &gt; &gt;, cond&lt; std::is_same&lt; TBase, Func &gt;::value, GeneratorInput_Func&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; TBase &gt;::value, GeneratorInput_Arithmetic&lt; T &gt; &gt;, cond&lt; std::is_scalar&lt; TBase &gt;::value, GeneratorInput_Scalar&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:aaebc4e1b658e316d9738ac723778525e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3efc8f40050501582a4dc9dafcd18a9">Halide::Internal::GeneratorOutputImplBase</a> = typename select_type&lt; cond&lt; has_static_halide_type_method&lt; TBase &gt;::value, GeneratorOutput_Buffer&lt; T &gt; &gt;, cond&lt; std::is_same&lt; TBase, Func &gt;::value, GeneratorOutput_Func&lt; T &gt; &gt;, cond&lt; std::is_arithmetic&lt; TBase &gt;::value, GeneratorOutput_Arithmetic&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc4779d7bb27645f2fc95ab5aaab4d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6bc4779d7bb27645f2fc95ab5aaab4d8">Halide::Internal::GeneratorFactory</a> = std::function&lt; std::unique_ptr&lt; GeneratorBase &gt;(const GeneratorContext &amp;)&gt;</td></tr>
<tr class="separator:a6bc4779d7bb27645f2fc95ab5aaab4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e4e2eb6b31542f36a2c879aa18c48a7">Halide::Internal::GeneratorParamsMap</a> = std::map&lt; std::string, StringOrLoopLevel &gt;</td></tr>
<tr class="separator:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae02ee070dfadab621e55f3b3dd971e18"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18">Halide::Internal::IOKind</a> { <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18af60357a8d17e45793298323f1b372a74">Halide::Internal::Scalar</a>
, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">Halide::Internal::Function</a>
, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a7e62bc342f41c946868f0ea6f0b712d8">Halide::Internal::Buffer</a>
 }</td></tr>
<tr class="separator:ae02ee070dfadab621e55f3b3dd971e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43770c59ec0f13935f4b33502ba7e817"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817">Halide::Internal::SyntheticParamType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">Halide::Internal::Type</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9">Halide::Internal::Dim</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c">Halide::Internal::ArraySize</a>
 }</td></tr>
<tr class="separator:a43770c59ec0f13935f4b33502ba7e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4be7daed1a8c6cd914be946f22ea4df">Halide::Internal::generator_test</a> ()</td></tr>
<tr class="separator:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2672948a0299d09a067ec4dbb862723"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa2672948a0299d09a067ec4dbb862723">Halide::Internal::parameter_constraints</a> (const Parameter &amp;p)</td></tr>
<tr class="separator:aa2672948a0299d09a067ec4dbb862723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b54f450e1cd03c240743907e45487ce">Halide::Internal::enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:a9b54f450e1cd03c240743907e45487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afd2308d89d4a9b9eef0803e92c383b0c">Halide::Internal::enum_from_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const std::string &amp;s)</td></tr>
<tr class="separator:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb90b52661557ff81407bc45cbdf3e6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">Halide::Internal::get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:aebb90b52661557ff81407bc45cbdf3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7c793b324e02e15a109f1e8af548c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2cc7c793b324e02e15a109f1e8af548c">Halide::Internal::halide_type_to_enum_string</a> (const Type &amp;t)</td></tr>
<tr class="separator:a2cc7c793b324e02e15a109f1e8af548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600136fc73541f81f75ee07095a62025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a600136fc73541f81f75ee07095a62025">Halide::Internal::halide_type_to_c_source</a> (const Type &amp;t)</td></tr>
<tr class="separator:a600136fc73541f81f75ee07095a62025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e8f71298de4ece7dc2e59ae811c3fd2">Halide::Internal::halide_type_to_c_type</a> (const Type &amp;t)</td></tr>
<tr class="separator:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032a99a32ca261c475b4335ece416dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">Halide::Internal::generate_filter_main</a> (int argc, char **argv, std::ostream &amp;cerr)</td></tr>
<tr class="memdesc:ad032a99a32ca261c475b4335ece416dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a1288db81d996c1d930c57ec8031a6527">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">More...</a><br /></td></tr>
<tr class="separator:ad032a99a32ca261c475b4335ece416dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a7ffe416c9264a301f4dbee5088cd4212"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">Halide::operator+</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a+(T) b)</td></tr>
<tr class="memdesc:a7ffe416c9264a301f4dbee5088cd4212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between GeneratorParam&lt;T&gt; and any type that supports operator+ with T.  <a href="namespace_halide.html#a7ffe416c9264a301f4dbee5088cd4212">More...</a><br /></td></tr>
<tr class="separator:a7ffe416c9264a301f4dbee5088cd4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad0b04406900c92aff4fe7df31bf35d6c">Halide::operator+</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a+b)</td></tr>
<tr class="separator:ad0b04406900c92aff4fe7df31bf35d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">Halide::operator-</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a -(T) b)</td></tr>
<tr class="memdesc:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between GeneratorParam&lt;T&gt; and any type that supports operator- with T.  <a href="namespace_halide.html#a3fcc2cb5052cc21ff4819dad8d62c86f">More...</a><br /></td></tr>
<tr class="separator:a3fcc2cb5052cc21ff4819dad8d62c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad63c3bccbde6ba2a4986f11bf662bf7e">Halide::operator-</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a - b)</td></tr>
<tr class="separator:ad63c3bccbde6ba2a4986f11bf662bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">Halide::operator*</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a *(T) b)</td></tr>
<tr class="memdesc:a24aabc3f5a598cb3c662e05b01243ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between GeneratorParam&lt;T&gt; and any type that supports operator* with T.  <a href="namespace_halide.html#a24aabc3f5a598cb3c662e05b01243ebb">More...</a><br /></td></tr>
<tr class="separator:a24aabc3f5a598cb3c662e05b01243ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a17ffddd99ce9d53114517a17496e45b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a17ffddd99ce9d53114517a17496e45b1">Halide::operator*</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a *b)</td></tr>
<tr class="separator:a17ffddd99ce9d53114517a17496e45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:addcc05645a8be0bf5b547891b5eedbd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">Halide::operator/</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a/(T) b)</td></tr>
<tr class="memdesc:addcc05645a8be0bf5b547891b5eedbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between GeneratorParam&lt;T&gt; and any type that supports operator/ with T.  <a href="namespace_halide.html#addcc05645a8be0bf5b547891b5eedbd6">More...</a><br /></td></tr>
<tr class="separator:addcc05645a8be0bf5b547891b5eedbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aedb1bbedd0274448f1b81fe8de753287"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aedb1bbedd0274448f1b81fe8de753287">Halide::operator/</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a/b)</td></tr>
<tr class="separator:aedb1bbedd0274448f1b81fe8de753287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a993b255e504fe0b7812c60db527c997b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">Halide::operator%</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a %(T) b)</td></tr>
<tr class="memdesc:a993b255e504fe0b7812c60db527c997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo between GeneratorParam&lt;T&gt; and any type that supports operator% with T.  <a href="namespace_halide.html#a993b255e504fe0b7812c60db527c997b">More...</a><br /></td></tr>
<tr class="separator:a993b255e504fe0b7812c60db527c997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e0eb4d1f94756aa0776e126762c4a5c">Halide::operator%</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a % b)</td></tr>
<tr class="separator:a8e0eb4d1f94756aa0776e126762c4a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ab7126caa58fad82bb502a72f7ba72dae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">Halide::operator&gt;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &gt;(T) b)</td></tr>
<tr class="memdesc:ab7126caa58fad82bb502a72f7ba72dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt; with T.  <a href="namespace_halide.html#ab7126caa58fad82bb502a72f7ba72dae">More...</a><br /></td></tr>
<tr class="separator:ab7126caa58fad82bb502a72f7ba72dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a212d29d2096665d1ee6bdec6ac8cb5ad">Halide::operator&gt;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt; b)</td></tr>
<tr class="separator:a212d29d2096665d1ee6bdec6ac8cb5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a1f99adc84a7324351d6037eacb3f9157"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">Halide::operator&lt;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a&lt;(T) b)</td></tr>
<tr class="memdesc:a1f99adc84a7324351d6037eacb3f9157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt; with T.  <a href="namespace_halide.html#a1f99adc84a7324351d6037eacb3f9157">More...</a><br /></td></tr>
<tr class="separator:a1f99adc84a7324351d6037eacb3f9157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aab6493da795ebe5c52ce922583d7aed4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab6493da795ebe5c52ce922583d7aed4">Halide::operator&lt;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt; b)</td></tr>
<tr class="separator:aab6493da795ebe5c52ce922583d7aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a016a50dc9625193a554ec0d51fb8d953"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">Halide::operator&gt;=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &gt;=(T) b)</td></tr>
<tr class="memdesc:a016a50dc9625193a554ec0d51fb8d953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&gt;= with T.  <a href="namespace_halide.html#a016a50dc9625193a554ec0d51fb8d953">More...</a><br /></td></tr>
<tr class="separator:a016a50dc9625193a554ec0d51fb8d953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a4598327ce18c80e8b2f89edde2554e02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4598327ce18c80e8b2f89edde2554e02">Halide::operator&gt;=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &gt;=b)</td></tr>
<tr class="separator:a4598327ce18c80e8b2f89edde2554e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa4053db56eee7933acebf91f83803cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">Halide::operator&lt;=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a&lt;=(T) b)</td></tr>
<tr class="memdesc:aa4053db56eee7933acebf91f83803cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal comparison between GeneratorParam&lt;T&gt; and any type that supports operator&lt;= with T.  <a href="namespace_halide.html#aa4053db56eee7933acebf91f83803cff">More...</a><br /></td></tr>
<tr class="separator:aa4053db56eee7933acebf91f83803cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a730bcf31dedcc336b12929d2afe35ea2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a730bcf31dedcc336b12929d2afe35ea2">Halide::operator&lt;=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a&lt;=b)</td></tr>
<tr class="separator:a730bcf31dedcc336b12929d2afe35ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a12fecab5f39831c5d8444fbf700c0e04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">Halide::operator==</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a==(T) b)</td></tr>
<tr class="memdesc:a12fecab5f39831c5d8444fbf700c0e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between GeneratorParam&lt;T&gt; and any type that supports operator== with T.  <a href="namespace_halide.html#a12fecab5f39831c5d8444fbf700c0e04">More...</a><br /></td></tr>
<tr class="separator:a12fecab5f39831c5d8444fbf700c0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac9aa81c242a4d52174dfe07e28dd856f">Halide::operator==</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a==b)</td></tr>
<tr class="separator:ac9aa81c242a4d52174dfe07e28dd856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:abe8ddebe6a310029aaf2096c17750a1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">Halide::operator!=</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a !=(T) b)</td></tr>
<tr class="memdesc:abe8ddebe6a310029aaf2096c17750a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between between GeneratorParam&lt;T&gt; and any type that supports operator!= with T.  <a href="namespace_halide.html#abe8ddebe6a310029aaf2096c17750a1e">More...</a><br /></td></tr>
<tr class="separator:abe8ddebe6a310029aaf2096c17750a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af53392f7139bea898ab547a1aa14f8cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af53392f7139bea898ab547a1aa14f8cb">Halide::operator!=</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a !=b)</td></tr>
<tr class="separator:af53392f7139bea898ab547a1aa14f8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">Halide::operator&amp;&amp;</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a &amp;&amp;(T) b)</td></tr>
<tr class="memdesc:a8e8cc876748afd9ec969b7d0d45d1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and between between GeneratorParam&lt;T&gt; and any type that supports operator&amp;&amp; with T.  <a href="namespace_halide.html#a8e8cc876748afd9ec969b7d0d45d1008">More...</a><br /></td></tr>
<tr class="separator:a8e8cc876748afd9ec969b7d0d45d1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a228ada08fcdf1652525a98f2f0f0df44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a228ada08fcdf1652525a98f2f0f0df44">Halide::operator&amp;&amp;</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a &amp;&amp;b)</td></tr>
<tr class="separator:a228ada08fcdf1652525a98f2f0f0df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3fe93546b3f630e218bae59afba254f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac3fe93546b3f630e218bae59afba254f">Halide::operator&amp;&amp;</a> (const GeneratorParam&lt; T &gt; &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype((T) a &amp;&amp;(T) b)</td></tr>
<tr class="separator:ac3fe93546b3f630e218bae59afba254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a2ab1d71b2448732fda75553fc7f23c89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">Halide::operator||</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(a||(T) b)</td></tr>
<tr class="memdesc:a2ab1d71b2448732fda75553fc7f23c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or between between GeneratorParam&lt;T&gt; and any type that supports operator|| with T.  <a href="namespace_halide.html#a2ab1d71b2448732fda75553fc7f23c89">More...</a><br /></td></tr>
<tr class="separator:a2ab1d71b2448732fda75553fc7f23c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:af4786dcd28f875b5886c08221ceade3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af4786dcd28f875b5886c08221ceade3b">Halide::operator||</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype((T) a||b)</td></tr>
<tr class="separator:af4786dcd28f875b5886c08221ceade3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf2ad1425d57e892ab6f16d66af3b882"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adf2ad1425d57e892ab6f16d66af3b882">Halide::operator||</a> (const GeneratorParam&lt; T &gt; &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype((T) a||(T) b)</td></tr>
<tr class="separator:adf2ad1425d57e892ab6f16d66af3b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53911af2c697e8b725295adb70edd361"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a53911af2c697e8b725295adb70edd361"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a53911af2c697e8b725295adb70edd361">Halide::Internal::GeneratorMinMax::min_forward</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(min(a,(T) b))</td></tr>
<tr class="separator:a53911af2c697e8b725295adb70edd361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a254be5aed49ae7fd863e9eb8e42ceb0d">Halide::Internal::GeneratorMinMax::min_forward</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(min((T) a, b))</td></tr>
<tr class="separator:a254be5aed49ae7fd863e9eb8e42ceb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37317f7712e4d37958974a2d71ef7c74"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a37317f7712e4d37958974a2d71ef7c74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a37317f7712e4d37958974a2d71ef7c74">Halide::Internal::GeneratorMinMax::max_forward</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(max(a,(T) b))</td></tr>
<tr class="separator:a37317f7712e4d37958974a2d71ef7c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdc48ece08d2eb96aa94f061196a258"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a7bdc48ece08d2eb96aa94f061196a258"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html#a7bdc48ece08d2eb96aa94f061196a258">Halide::Internal::GeneratorMinMax::max_forward</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(max((T) a, b))</td></tr>
<tr class="separator:a7bdc48ece08d2eb96aa94f061196a258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">Halide::min</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(Internal::GeneratorMinMax::min_forward(a, b))</td></tr>
<tr class="memdesc:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum between GeneratorParam&lt;T&gt; and any type that supports min with T.  <a href="namespace_halide.html#a0fcc240a43e9bd59167b72a75ba39d3a">More...</a><br /></td></tr>
<tr class="separator:a0fcc240a43e9bd59167b72a75ba39d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:a38f0112267498bcda0747506b9d82af8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38f0112267498bcda0747506b9d82af8">Halide::min</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(Internal::GeneratorMinMax::min_forward(a, b))</td></tr>
<tr class="separator:a38f0112267498bcda0747506b9d82af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aa350166ccd23cc6430356bb6833d3910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">Halide::max</a> (const Other &amp;a, const GeneratorParam&lt; T &gt; &amp;b) -&gt; decltype(Internal::GeneratorMinMax::max_forward(a, b))</td></tr>
<tr class="memdesc:aa350166ccd23cc6430356bb6833d3910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum value between GeneratorParam&lt;T&gt; and any type that supports max with T.  <a href="namespace_halide.html#aa350166ccd23cc6430356bb6833d3910">More...</a><br /></td></tr>
<tr class="separator:aa350166ccd23cc6430356bb6833d3910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplParams" colspan="2">template&lt;typename Other , typename T &gt; </td></tr>
<tr class="memitem:aeb5a870f8517436e4720b50792f8fdd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb5a870f8517436e4720b50792f8fdd1">Halide::max</a> (const GeneratorParam&lt; T &gt; &amp;a, const Other &amp;b) -&gt; decltype(Internal::GeneratorMinMax::max_forward(a, b))</td></tr>
<tr class="separator:aeb5a870f8517436e4720b50792f8fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a534f823d7f303e81b20bdff79e38179c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">Halide::operator!</a> (const GeneratorParam&lt; T &gt; &amp;a) -&gt; decltype(!(T) a)</td></tr>
<tr class="memdesc:a534f823d7f303e81b20bdff79e38179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not operator for <a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a>.  <a href="namespace_halide.html#a534f823d7f303e81b20bdff79e38179c">More...</a><br /></td></tr>
<tr class="separator:a534f823d7f303e81b20bdff79e38179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae47fa4b8f49636c214b214f5d0f4ed34">Halide::Internal::parse_scalar</a> (const std::string &amp;value)</td></tr>
<tr class="separator:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682395f90f7229826df771f8c286fac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7682395f90f7229826df771f8c286fac">Halide::Internal::parse_halide_type_list</a> (const std::string &amp;types)</td></tr>
<tr class="separator:a7682395f90f7229826df771f8c286fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generator is a class used to encapsulate the building of Funcs in user pipelines. </p>
<p>A Generator is agnostic to JIT vs AOT compilation; it can be used for either purpose, but is especially convenient to use for AOT compilation.</p>
<p>A Generator explicitly declares the Inputs and Outputs associated for a given pipeline, and (optionally) separates the code for constructing the outputs from the code from scheduling them. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Blur : <span class="keyword">public</span> Generator&lt;Blur&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(16), 2};</div>
<div class="line">    Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(16), 2};</div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        blur_x(x, y) = (input(x, y) + input(x+1, y) + input(x+2, y))/3;</div>
<div class="line">        blur_y(x, y) = (blur_x(x, y) + blur_x(x, y+1) + blur_x(x, y+2))/3;</div>
<div class="line">        output(x, y) = blur(x, y);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a799855594adc0f2bd7302c69d3234b5a">schedule</a>() {</div>
<div class="line">        blur_y.split(y, y, yi, 8).parallel(y).vectorize(x, 8);</div>
<div class="line">        blur_x.store_at(blur_y, y).compute_at(blur_y, yi).vectorize(x, 8);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Var x, y, xi, yi;</div>
<div class="line">    Func blur_x, blur_y;</div>
<div class="line">};</div>
<div class="ttc" id="anamespace_halide_html_a0eb5f455b5c4bce0c54575bc67bf9599"><div class="ttname"><a href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">Halide::UInt</a></div><div class="ttdeci">Type UInt(int bits, int lanes=1)</div><div class="ttdoc">Constructing an unsigned integer type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00503">Type.h:503</a></div></div>
<div class="ttc" id="anamespace_halide_html_afdb8b92dac95804211c0a875302da5f4a799855594adc0f2bd7302c69d3234b5a"><div class="ttname"><a href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a799855594adc0f2bd7302c69d3234b5a">Halide::Output::schedule</a></div><div class="ttdeci">@ schedule</div></div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can compile a Generator into the correct pipeline by introspecting these values and constructing an appropriate signature based on them.</p>
<p>A Generator provides implementations of two methods:</p>
<ul>
<li>generate(), which must fill in all Output Func(s); it may optionally also do scheduling if no schedule() method is present.</li>
<li>schedule(), which (if present) should contain all scheduling code.</li>
</ul>
<p>Inputs can be any C++ scalar type:</p>
<div class="fragment"><div class="line">Input&lt;float&gt; radius{<span class="stringliteral">&quot;radius&quot;</span>};</div>
<div class="line">Input&lt;int32_t&gt; increment{<span class="stringliteral">&quot;increment&quot;</span>};</div>
</div><!-- fragment --><p>An Input&lt;Func&gt; is (essentially) like an ImageParam, except that it may (or may not) not be backed by an actual buffer, and thus has no defined extents.</p>
<div class="fragment"><div class="line">Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
<div class="ttc" id="anamespace_halide_html_a11df91175e8ac20ce33379c178e8c7bc"><div class="ttname"><a href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Halide::Float</a></div><div class="ttdeci">Type Float(int bits, int lanes=1)</div><div class="ttdoc">Construct a floating-point type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00508">Type.h:508</a></div></div>
</div><!-- fragment --><p>You can optionally make the type and/or dimensions of Input&lt;Func&gt; unspecified, in which case the value is simply inferred from the actual Funcs passed to them. Of course, if you specify an explicit Type or Dimension, we still require the input Func to match, or a compilation error results.</p>
<div class="fragment"><div class="line">Input&lt;Func&gt; input{ <span class="stringliteral">&quot;input&quot;</span>, 3 };  <span class="comment">// require 3-dimensional Func,</span></div>
<div class="line">                                  <span class="comment">// but leave Type unspecified</span></div>
</div><!-- fragment --><p>A Generator must explicitly list the output(s) it produces:</p>
<div class="fragment"><div class="line">Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
</div><!-- fragment --><p>You can specify an output that returns a Tuple by specifying a list of Types:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Tupler : Generator&lt;Tupler&gt; {</div>
<div class="line">  Input&lt;Func&gt; input{<span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), 2};</div>
<div class="line">  Output&lt;Func&gt; output{<span class="stringliteral">&quot;output&quot;</span>, {<a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), <a class="code" href="namespace_halide.html#a0eb5f455b5c4bce0c54575bc67bf9599">UInt</a>(8)}, 2};</div>
<div class="line">  <span class="keywordtype">void</span> generate() {</div>
<div class="line">    Var x, y;</div>
<div class="line">    Expr a = cast&lt;float&gt;(input(x, y));</div>
<div class="line">    Expr b = cast&lt;uint8_t&gt;(input(x, y));</div>
<div class="line">    output(x, y) = Tuple(a, b);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="anamespace_halide_html_a70a0c034814a65d55bb848fe9c96653b"><div class="ttname"><a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Halide::Int</a></div><div class="ttdeci">Type Int(int bits, int lanes=1)</div><div class="ttdoc">Constructing a signed integer type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00498">Type.h:498</a></div></div>
</div><!-- fragment --><p>You can also specify Output&lt;X&gt; for any scalar type (except for Handle types); this is merely syntactic sugar on top of a zero-dimensional Func, but can be quite handy, especially when used with multiple outputs:</p>
<div class="fragment"><div class="line">Output&lt;float&gt; <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>{<span class="stringliteral">&quot;sum&quot;</span>};  <span class="comment">// equivalent to Output&lt;Func&gt; {&quot;sum&quot;, Float(32), 0}</span></div>
<div class="ttc" id="anamespace_halide_html_a41aa8982b04d0b5faf76de0fd4c0cc33"><div class="ttname"><a href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">Halide::sum</a></div><div class="ttdeci">Expr sum(Expr, const std::string &amp;s=&quot;sum&quot;)</div><div class="ttdoc">An inline reduction.</div></div>
</div><!-- fragment --><p>As with Input&lt;Func&gt;, you can optionally make the type and/or dimensions of an Output&lt;Func&gt; unspecified; any unspecified types must be resolved via an implicit GeneratorParam in order to use top-level compilation.</p>
<p>You can also declare an <em>array</em> of Input or Output, by using an array type as the type parameter:</p>
<div class="fragment"><div class="line"><span class="comment">// Takes exactly 3 images and outputs exactly 3 sums.</span></div>
<div class="line"><span class="keyword">class </span>SumRowsAndColumns : Generator&lt;SumRowsAndColumns&gt; {</div>
<div class="line">  Input&lt;Func[3]&gt; inputs{<span class="stringliteral">&quot;inputs&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2};</div>
<div class="line">  Input&lt;int32_t[2]&gt; extents{<span class="stringliteral">&quot;extents&quot;</span>};</div>
<div class="line">  Output&lt;Func[3]&gt; sums{<span class="stringliteral">&quot;sums&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 1};</div>
<div class="line">  <span class="keywordtype">void</span> generate() {</div>
<div class="line">    assert(inputs.size() == sums.size());</div>
<div class="line">    <span class="comment">// assume all inputs are same extent</span></div>
<div class="line">    Expr width = extent[0];</div>
<div class="line">    Expr height = extent[1];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; inputs.size(); ++i) {</div>
<div class="line">      RDom r(0, width, 0, height);</div>
<div class="line">      sums[i]() = 0.f;</div>
<div class="line">      sums[i]() += inputs[i](r.x, r.y);</div>
<div class="line">     }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>You can also leave array size unspecified, with some caveats:</p><ul>
<li>For ahead-of-time compilation, Inputs must have a concrete size specified via a GeneratorParam at build time (e.g., pyramid.size=3)</li>
<li>For JIT compilation via a Stub, Inputs array sizes will be inferred from the vector passed.</li>
<li>For ahead-of-time compilation, Outputs may specify a concrete size via a GeneratorParam at build time (e.g., pyramid.size=3), or the size can be specified via a resize() method.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>Pyramid : <span class="keyword">public</span> Generator&lt;Pyramid&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GeneratorParam&lt;int32_t&gt; levels{<span class="stringliteral">&quot;levels&quot;</span>, 10};</div>
<div class="line">    Input&lt;Func&gt; input{ <span class="stringliteral">&quot;input&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line">    Output&lt;Func[]&gt; pyramid{ <span class="stringliteral">&quot;pyramid&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        pyramid.resize(levels);</div>
<div class="line">        pyramid[0](x, y) = input(x, y);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; pyramid.size(); i++) {</div>
<div class="line">            pyramid[i](x, y) = (pyramid[i-1](2*x, 2*y) +</div>
<div class="line">                               pyramid[i-1](2*x+1, 2*y) +</div>
<div class="line">                               pyramid[i-1](2*x, 2*y+1) +</div>
<div class="line">                               pyramid[i-1](2*x+1, 2*y+1))/4;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>A Generator can also be customized via compile-time parameters (GeneratorParams), which affect code generation.</p>
<p>GeneratorParams, Inputs, and Outputs are (by convention) always public and always declared at the top of the Generator class, in the order</p>
<div class="fragment"><div class="line">GeneratorParam(s)</div>
<div class="line">Input&lt;Func&gt;(s)</div>
<div class="line">Input&lt;non-Func&gt;(s)</div>
<div class="line">Output&lt;Func&gt;(s)</div>
</div><!-- fragment --><p>Note that the Inputs and Outputs will appear in the C function call in the order they are declared. All Input&lt;Func&gt; and Output&lt;Func&gt; are represented as <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a>; all other Input&lt;&gt; are the appropriate C++ scalar type. (GeneratorParams are always referenced by name, not position, so their order is irrelevant.)</p>
<p>All Inputs and Outputs must have explicit names, and all such names must match the regex [A-Za-z][A-Za-z_0-9]* (i.e., essentially a C/C++ variable name, with some extra restrictions on underscore use). By convention, the name should match the member-variable name.</p>
<p>You can dynamically add Inputs and Outputs to your Generator via adding a configure() method; if present, it will be called before generate(). It can examine GeneratorParams but it may not examine predeclared Inputs or Outputs; the only thing it should do is call add_input&lt;&gt;() and/or add_output&lt;&gt;(). Added inputs will be appended (in order) after predeclared Inputs but before any Outputs; added outputs will be appended after predeclared Outputs.</p>
<p>Note that the pointers returned by add_input() and add_output() are owned by the Generator and will remain valid for the Generator's lifetime; user code should not attempt to delete or free them.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MultiSum : <span class="keyword">public</span> Generator&lt;MultiSum&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GeneratorParam&lt;int32_t&gt; input_count{<span class="stringliteral">&quot;input_count&quot;</span>, 10};</div>
<div class="line">    Output&lt;Func&gt; output{ <span class="stringliteral">&quot;output&quot;</span>, <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2 };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configure() {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; input_count; ++i) {</div>
<div class="line">            extra_inputs.push_back(</div>
<div class="line">                add_input&lt;Func&gt;(<span class="stringliteral">&quot;input_&quot;</span> + std::to_string(i), <a class="code" href="namespace_halide.html#a11df91175e8ac20ce33379c178e8c7bc">Float</a>(32), 2);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> generate() {</div>
<div class="line">        Expr <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> = 0.f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; input_count; ++i) {</div>
<div class="line">            <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a> += (*extra_inputs)[i](x, y);</div>
<div class="line">        }</div>
<div class="line">        output(x, y) = <a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>;</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Input&lt;Func&gt;* extra_inputs;</div>
<div class="line">};</div>
</div><!-- fragment --><p>All Generators have three GeneratorParams that are implicitly provided by the base class: </p><pre class="fragment">GeneratorParam&lt;Target&gt; target{"target", Target()};
GeneratorParam&lt;bool&gt; auto_schedule{"auto_schedule", false};
GeneratorParam&lt;MachineParams&gt; machine_params{"machine_params", MachineParams::generic()};
</pre><ul>
<li>'target' is the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Halide::Target</a> for which the Generator is producing code. It is read-only during the Generator's lifetime, and must not be modified; its value should always be filled in by the calling code: either the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> build system (for ahead-of-time compilation), or ordinary C++ code (for JIT compilation).</li>
<li>'auto_schedule' indicates whether the auto-scheduler should be run for this Generator:<ul>
<li>if 'false', the Generator should schedule its Funcs as it sees fit.</li>
<li>if 'true', the Generator should only provide estimate()s for its Funcs, and not call any other scheduling methods.</li>
</ul>
</li>
<li>'machine_params' is only used if auto_schedule is true; it is ignored if auto_schedule is false. It provides details about the machine architecture being targeted which may be used to enhance the automatically-generated schedule.</li>
</ul>
<p>Generators are added to a global registry to simplify AOT build mechanics; this is done by simply using the HALIDE_REGISTER_GENERATOR macro at global scope:</p>
<div class="fragment"><div class="line"><a class="code" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(ExampleGen, jit_example)</div>
<div class="ttc" id="a_generator_8h_html_a76205e384e3152f5eda423c56accbc54"><div class="ttname"><a href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a></div><div class="ttdeci">#define HALIDE_REGISTER_GENERATOR(...)</div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03782">Generator.h:3782</a></div></div>
</div><!-- fragment --><p>The registered name of the Generator is provided must match the same rules as Input names, above.</p>
<p>Note that the class name of the generated Stub class will match the registered name by default; if you want to vary it (typically, to include namespaces), you can add it as an optional third argument:</p>
<div class="fragment"><div class="line"><a class="code" href="_generator_8h.html#a76205e384e3152f5eda423c56accbc54">HALIDE_REGISTER_GENERATOR</a>(ExampleGen, jit_example, SomeNamespace::JitExampleStub)</div>
</div><!-- fragment --><p>Note that a Generator is always executed with a specific Target assigned to it, that you can access via the get_target() method. (You should <em>not</em> use the global <a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d" title="Return the target that Halide will use.">get_target_from_environment()</a>, etc. methods provided in <a class="el" href="_target_8h.html" title="Defines the structure that describes a Halide target.">Target.h</a>)</p>
<p>(Note that there are older variations of Generator that differ from what's documented above; these are still supported but not described here. See <a href="https://github.com/halide/Halide/wiki/Old-Generator-Documentation">https://github.com/halide/Halide/wiki/Old-Generator-Documentation</a> for more information.) </p>

<p class="definition">Definition in file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a08dae13ee17f505472e95d3bcaec9984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dae13ee17f505472e95d3bcaec9984">&#9670;&nbsp;</a></span>HALIDE_GENERATOR_PARAM_TYPED_SETTER <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_GENERATOR_PARAM_TYPED_SETTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE</td><td>)</td>
          <td>&#160;&#160;&#160;    virtual void set(const TYPE &amp;new_value) = 0;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00522">522</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a08dae13ee17f505472e95d3bcaec9984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dae13ee17f505472e95d3bcaec9984">&#9670;&nbsp;</a></span>HALIDE_GENERATOR_PARAM_TYPED_SETTER <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_GENERATOR_PARAM_TYPED_SETTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordtype">void</span> set(<span class="keyword">const</span> TYPE &amp;new_value)<span class="keyword"> override </span>{     \</div>
<div class="line">        typed_setter_impl&lt;TYPE&gt;(new_value, #TYPE); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00522">522</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f29f9d6f0fc7fe4ae9a30a1a6c1a4f">&#9670;&nbsp;</a></span>HALIDE_FORWARD_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FORWARD_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Method&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;                                                                                                                      \</div>
<div class="line">    inline <span class="keyword">auto</span> Method(Args &amp;&amp;...args)-&gt;typename std::remove_reference&lt;decltype(std::declval&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...))&gt;::type { \</div>
<div class="line">        return this-&gt;<span class="keyword">template</span> as&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...);                                                                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01632">1632</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a3cefa62995eaf97e7a6795e159d7e245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cefa62995eaf97e7a6795e159d7e245">&#9670;&nbsp;</a></span>HALIDE_FORWARD_METHOD_CONST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FORWARD_METHOD_CONST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Method&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;                                                                                      \</div>
<div class="line">    inline <span class="keyword">auto</span> Method(Args &amp;&amp;...args) <span class="keyword">const</span>-&gt;                                                                      \</div>
<div class="line">        typename std::remove_reference&lt;decltype(std::declval&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...))&gt;::type { \</div>
<div class="line">        this-&gt;check_gio_access();                                                                                   \</div>
<div class="line">        return this-&gt;<span class="keyword">template</span> as&lt;Class&gt;().Method(std::forward&lt;Args&gt;(args)...);                                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01638">1638</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a5856471e468d66102a7f7c3384e7bf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856471e468d66102a7f7c3384e7bf3a">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FULLY_QUALIFIED_STUB_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacehalide__register__generator.html">halide_register_generator</a> {                                                                                           \</div>
<div class="line">    struct halide_global_ns;                                                                                                        \</div>
<div class="line">    namespace GEN_REGISTRY_NAME##_ns {                                                                                              \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::GeneratorBase&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);                          \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::GeneratorBase&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context) {                         \</div>
<div class="line">            return GEN_CLASS_NAME::create(context, #GEN_REGISTRY_NAME, #FULLY_QUALIFIED_STUB_NAME);                                 \</div>
<div class="line">        }                                                                                                                           \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static <span class="keyword">auto</span> reg_##GEN_REGISTRY_NAME = <a class="code" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a>(#GEN_REGISTRY_NAME, GEN_REGISTRY_NAME##_ns::factory); \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static_assert(std::is_same&lt;::halide_register_generator::halide_global_ns, halide_register_generator::halide_global_ns&gt;::value,  \</div>
<div class="line">                  <span class="stringliteral">&quot;HALIDE_REGISTER_GENERATOR must be used at global scope&quot;</span>);</div>
<div class="ttc" id="aclass_halide_1_1_generator_context_html"><div class="ttname"><a href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a></div><div class="ttdoc">GeneratorContext is a base class that is used when using Generators (or Stubs) directly; it is used t...</div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l02833">Generator.h:2833</a></div></div>
<div class="ttc" id="aclass_halide_1_1_internal_1_1_register_generator_html"><div class="ttname"><a href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a></div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03665">Generator.h:3665</a></div></div>
<div class="ttc" id="anamespacehalide__register__generator_html"><div class="ttname"><a href="namespacehalide__register__generator.html">halide_register_generator</a></div><div class="ttdef"><b>Definition:</b> <a href="_generator_8h_source.html#l03734">Generator.h:3734</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03738">3738</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a9a745ace50c85e1e1086beda5bd7598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a745ace50c85e1e1086beda5bd7598d">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, GEN_REGISTRY_NAME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03752">3752</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ad4b1d1e407c4804e430152a081194e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b1d1e407c4804e430152a081194e99">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_CLASS_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FULLY_QUALIFIED_STUB_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a5856471e468d66102a7f7c3384e7bf3a">_HALIDE_REGISTER_GENERATOR_IMPL</a>(GEN_CLASS_NAME, GEN_REGISTRY_NAME, FULLY_QUALIFIED_STUB_NAME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03755">3755</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a9569beb9a7e98718b004aee7c10f0467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9569beb9a7e98718b004aee7c10f0467">&#9670;&nbsp;</a></span>__HALIDE_REGISTER_ARGCOUNT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __HALIDE_REGISTER_ARGCOUNT_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03761">3761</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a64059dca539cf5f3f7e4c642af576ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64059dca539cf5f3f7e4c642af576ae3">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_ARGCOUNT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_ARGCOUNT_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ARGS</td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a9569beb9a7e98718b004aee7c10f0467">__HALIDE_REGISTER_ARGCOUNT_IMPL</a> ARGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03764">3764</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ab1ebb701e7b5841c0e6202138cdb5dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebb701e7b5841c0e6202138cdb5dff">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_ARGCOUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_ARGCOUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a64059dca539cf5f3f7e4c642af576ae3">_HALIDE_REGISTER_ARGCOUNT_IMPL</a>((__VA_ARGS__, 3, 2, 1, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03767">3767</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a3703de57adb30a5044367a8eccb822b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3703de57adb30a5044367a8eccb822b0">&#9670;&nbsp;</a></span>___HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ___HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;    _HALIDE_REGISTER_GENERATOR##COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03770">3770</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a247774bd287d01a3081de190905019c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247774bd287d01a3081de190905019c7">&#9670;&nbsp;</a></span>__HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a3703de57adb30a5044367a8eccb822b0">___HALIDE_REGISTER_CHOOSER</a>(COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03773">3773</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a33e49dea0ba50a51195521ede9c0b20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e49dea0ba50a51195521ede9c0b20c">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_CHOOSER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_CHOOSER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">COUNT</td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a247774bd287d01a3081de190905019c7">__HALIDE_REGISTER_CHOOSER</a>(COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03776">3776</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a940f7c9be73066885cb3a5d29e7cbd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940f7c9be73066885cb3a5d29e7cbd55">&#9670;&nbsp;</a></span>_HALIDE_REGISTER_GENERATOR_PASTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _HALIDE_REGISTER_GENERATOR_PASTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">A, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">B&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    A B</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03779">3779</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a76205e384e3152f5eda423c56accbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76205e384e3152f5eda423c56accbc54">&#9670;&nbsp;</a></span>HALIDE_REGISTER_GENERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_REGISTER_GENERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="_generator_8h.html#a940f7c9be73066885cb3a5d29e7cbd55">_HALIDE_REGISTER_GENERATOR_PASTE</a>(<a class="el" href="_generator_8h.html#a33e49dea0ba50a51195521ede9c0b20c">_HALIDE_REGISTER_CHOOSER</a>(<a class="el" href="_generator_8h.html#ab1ebb701e7b5841c0e6202138cdb5dff">_HALIDE_REGISTER_ARGCOUNT</a>(__VA_ARGS__)), (__VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_15_generators_8cpp-example.html#a1">tutorial/lesson_15_generators.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03782">3782</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a2ae85638c44eb4fa948399c7b9003bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae85638c44eb4fa948399c7b9003bf4">&#9670;&nbsp;</a></span>HALIDE_REGISTER_GENERATOR_ALIAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_REGISTER_GENERATOR_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">GEN_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ORIGINAL_REGISTRY_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacehalide__register__generator.html">halide_register_generator</a> {                                                                                           \</div>
<div class="line">    struct halide_global_ns;                                                                                                        \</div>
<div class="line">    namespace ORIGINAL_REGISTRY_NAME##_ns {                                                                                         \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::GeneratorBase&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);                          \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    namespace GEN_REGISTRY_NAME##_ns {                                                                                              \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::GeneratorBase&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context);                          \</div>
<div class="line">        std::unique_ptr&lt;Halide::Internal::GeneratorBase&gt; factory(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_generator_context.html">Halide::GeneratorContext</a> &amp;context) {                         \</div>
<div class="line">            auto g = ORIGINAL_REGISTRY_NAME##_ns::factory(context);                                                                 \</div>
<div class="line">            g-&gt;set_generator_param_values(__VA_ARGS__);                                                                             \</div>
<div class="line">            return g;                                                                                                               \</div>
<div class="line">        }                                                                                                                           \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static <span class="keyword">auto</span> reg_##GEN_REGISTRY_NAME = <a class="code" href="class_halide_1_1_internal_1_1_register_generator.html">Halide::Internal::RegisterGenerator</a>(#GEN_REGISTRY_NAME, GEN_REGISTRY_NAME##_ns::factory); \</div>
<div class="line">    }                                                                                                                               \</div>
<div class="line">    static_assert(std::is_same&lt;::halide_register_generator::halide_global_ns, halide_register_generator::halide_global_ns&gt;::value,  \</div>
<div class="line">                  <span class="stringliteral">&quot;HALIDE_REGISTER_GENERATOR_ALIAS must be used at global scope&quot;</span>);</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l03799">3799</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_generator_8h.html">Generator.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
