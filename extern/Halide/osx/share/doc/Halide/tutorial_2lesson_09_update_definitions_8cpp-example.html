<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: tutorial/lesson_09_update_definitions.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial_2lesson_09_update_definitions_8cpp-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_09_update_definitions.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Halide tutorial lesson 9: Multi-pass Funcs, update definitions, and reductions</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On linux, you can compile and run it like so:</span></div>
<div class="line"><span class="comment">// g++ lesson_09*.cpp -g -std=c++11 -I &lt;path/to/Halide.h&gt; -I &lt;path/to/tools/halide_image_io.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide `libpng-config --cflags --ldflags` -ljpeg -lpthread -ldl -fopenmp -o lesson_09</span></div>
<div class="line"><span class="comment">// LD_LIBRARY_PATH=&lt;path/to/libHalide.so&gt; ./lesson_09</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On os x (will only work if you actually have g++, not Apple&#39;s pretend g++ which is actually clang):</span></div>
<div class="line"><span class="comment">// g++ lesson_09*.cpp -g -std=c++11 -I &lt;path/to/Halide.h&gt; -I &lt;path/to/tools/halide_image_io.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide `libpng-config --cflags --ldflags` -ljpeg -fopenmp -o lesson_09</span></div>
<div class="line"><span class="comment">// DYLD_LIBRARY_PATH=&lt;path/to/libHalide.dylib&gt; ./lesson_09</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you have the entire Halide source tree, you can also build it by</span></div>
<div class="line"><span class="comment">// running:</span></div>
<div class="line"><span class="comment">//    make tutorial_lesson_09_update_definitions</span></div>
<div class="line"><span class="comment">// in a shell with the current directory at the top of the halide</span></div>
<div class="line"><span class="comment">// source tree.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Halide.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;re going to be using x86 SSE intrinsics later on in this lesson.</span></div>
<div class="line"><span class="preprocessor">#ifdef __SSE2__</span></div>
<div class="line"><span class="preprocessor">#include &lt;emmintrin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;ll also need a clock to do performance testing at the end.</span></div>
<div class="line"><span class="preprocessor">#include &quot;clock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_halide.html">Halide</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Support code for loading pngs.</span></div>
<div class="line"><span class="preprocessor">#include &quot;halide_image_io.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>Halide::Tools;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="comment">// Declare some Vars to use below.</span></div>
<div class="line">    Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load a grayscale image to use as an input.</span></div>
<div class="line">    Buffer&lt;uint8_t&gt; input = load_image(<span class="stringliteral">&quot;images/gray.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can define a Func in multiple passes. Let&#39;s see a toy</span></div>
<div class="line">    <span class="comment">// example first.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The first definition must be one like we have seen already</span></div>
<div class="line">        <span class="comment">// - a mapping from Vars to an Expr:</span></div>
<div class="line">        Func f;</div>
<div class="line">        f(x, y) = x + y;</div>
<div class="line">        <span class="comment">// We call this first definition the &quot;pure&quot; definition.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But the later definitions can include computed expressions on</span></div>
<div class="line">        <span class="comment">// both sides. The simplest example is modifying a single point:</span></div>
<div class="line">        f(3, 7) = 42;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We call these extra definitions &quot;update&quot; definitions, or</span></div>
<div class="line">        <span class="comment">// &quot;reduction&quot; definitions. A reduction definition is an</span></div>
<div class="line">        <span class="comment">// update definition that recursively refers back to the</span></div>
<div class="line">        <span class="comment">// function&#39;s current value at the same site:</span></div>
<div class="line">        f(x, y) = f(x, y) + 17;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we confine our update to a single row, we can</span></div>
<div class="line">        <span class="comment">// recursively refer to values in the same column:</span></div>
<div class="line">        f(x, 3) = f(x, 0) * f(x, 10);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Similarly, if we confine our update to a single column, we</span></div>
<div class="line">        <span class="comment">// can recursively refer to other values in the same row.</span></div>
<div class="line">        f(0, y) = f(0, y) / f(3, y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The general rule is: Each Var used in an update definition</span></div>
<div class="line">        <span class="comment">// must appear unadorned in the same position as in the pure</span></div>
<div class="line">        <span class="comment">// definition in all references to the function on the left-</span></div>
<div class="line">        <span class="comment">// and right-hand sides. So the following definitions are</span></div>
<div class="line">        <span class="comment">// legal updates:</span></div>
<div class="line">        f(x, 17) = x + 8;</div>
<div class="line">        f(0, y) = y * 8;</div>
<div class="line">        f(x, x + 1) = x + 8;</div>
<div class="line">        f(y / 2, y) = f(0, y) * 17;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But these ones would cause an error:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(x, 0) = f(x + 1, 0);</span></div>
<div class="line">        <span class="comment">// First argument to f on the right-hand-side must be &#39;x&#39;, not &#39;x + 1&#39;.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(y, y + 1) = y + 8;</span></div>
<div class="line">        <span class="comment">// Second argument to f on the left-hand-side must be &#39;y&#39;, not &#39;y + 1&#39;.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(y, x) = y - x;</span></div>
<div class="line">        <span class="comment">// Arguments to f on the left-hand-side are in the wrong places.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(3, 4) = x + y;</span></div>
<div class="line">        <span class="comment">// Free variables appear on the right-hand-side but not the left-hand-side.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll realize this one just to make sure it compiles. The</span></div>
<div class="line">        <span class="comment">// second-to-last definition forces us to realize over a</span></div>
<div class="line">        <span class="comment">// domain that is taller than it is wide.</span></div>
<div class="line">        f.realize({100, 101});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For each realization of f, each step runs in its entirety</span></div>
<div class="line">        <span class="comment">// before the next one begins. Let&#39;s trace the loads and</span></div>
<div class="line">        <span class="comment">// stores for a simpler example:</span></div>
<div class="line">        Func g(<span class="stringliteral">&quot;g&quot;</span>);</div>
<div class="line">        g(x, y) = x + y;    <span class="comment">// Pure definition</span></div>
<div class="line">        g(2, 1) = 42;       <span class="comment">// First update definition</span></div>
<div class="line">        g(x, 0) = g(x, 1);  <span class="comment">// Second update definition</span></div>
<div class="line"> </div>
<div class="line">        g.trace_loads();</div>
<div class="line">        g.trace_stores();</div>
<div class="line"> </div>
<div class="line">        g.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reading the log, we see that each pass is applied in</span></div>
<div class="line">        <span class="comment">// turn. The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> result[4][4];</div>
<div class="line">        <span class="comment">// Pure definition</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = x + y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// First update definition</span></div>
<div class="line">        result[1][2] = 42;</div>
<div class="line">        <span class="comment">// Second update definition</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">            result[0][x] = result[1][x];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Putting update passes inside loops.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Starting with this pure definition:</span></div>
<div class="line">        Func f;</div>
<div class="line">        f(x, y) = (x + y) / 100.0f;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Say we want an update that squares the first fifty rows. We</span></div>
<div class="line">        <span class="comment">// could do this by adding 50 update definitions:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// f(x, 0) = f(x, 0) * f(x, 0);</span></div>
<div class="line">        <span class="comment">// f(x, 1) = f(x, 1) * f(x, 1);</span></div>
<div class="line">        <span class="comment">// f(x, 2) = f(x, 2) * f(x, 2);</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <span class="comment">// f(x, 49) = f(x, 49) * f(x, 49);</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Or equivalently using a compile-time loop in our C++:</span></div>
<div class="line">        <span class="comment">// for (int i = 0; i &lt; 50; i++) {</span></div>
<div class="line">        <span class="comment">//   f(x, i) = f(x, i) * f(x, i);</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// But it&#39;s more manageable and more flexible to put the loop</span></div>
<div class="line">        <span class="comment">// in the generated code. We do this by defining a &quot;reduction</span></div>
<div class="line">        <span class="comment">// domain&quot; and using it inside an update definition:</span></div>
<div class="line">        RDom r(0, 50);</div>
<div class="line">        f(x, r) = f(x, r) * f(x, r);</div>
<div class="line">        Buffer&lt;float&gt; halide_result = f.realize({100, 100});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update_rdom.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">float</span> c_result[100][100];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">                c_result[y][x] = (x + y) / 100.0f;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 50; r++) {</div>
<div class="line">                <span class="comment">// The loop over the reduction domain occurs inside of</span></div>
<div class="line">                <span class="comment">// the loop over any pure variables used in the update</span></div>
<div class="line">                <span class="comment">// step:</span></div>
<div class="line">                c_result[r][x] = c_result[r][x] * c_result[r][x];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (fabs(halide_result(x, y) - c_result[y][x]) &gt; 0.01f) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %f instead of %f\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now we&#39;ll examine a real-world use for an update definition:</span></div>
<div class="line">    <span class="comment">// computing a histogram.</span></div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Some operations on images can&#39;t be cleanly expressed as a pure</span></div>
<div class="line">        <span class="comment">// function from the output coordinates to the value stored</span></div>
<div class="line">        <span class="comment">// there. The classic example is computing a histogram. The</span></div>
<div class="line">        <span class="comment">// natural way to do it is to iterate over the input image,</span></div>
<div class="line">        <span class="comment">// updating histogram buckets. Here&#39;s how you do that in Halide:</span></div>
<div class="line">        Func histogram(<span class="stringliteral">&quot;histogram&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Histogram buckets start as zero.</span></div>
<div class="line">        histogram(x) = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define a multi-dimensional reduction domain over the input image:</span></div>
<div class="line">        RDom r(0, input.width(), 0, input.height());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For every point in the reduction domain, increment the</span></div>
<div class="line">        <span class="comment">// histogram bucket corresponding to the intensity of the</span></div>
<div class="line">        <span class="comment">// input image at that point.</span></div>
<div class="line">        histogram(input(r.x, r.y)) += 1;</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = histogram.realize({256});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[256];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {</div>
<div class="line">            c_result[x] = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = 0; r_y &lt; input.height(); r_y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = 0; r_x &lt; input.width(); r_x++) {</div>
<div class="line">                c_result[input(r_x, r_y)] += 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the answers agree:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (c_result[x] != halide_result(x)) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scheduling update steps</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The pure variables in an update step and can be</span></div>
<div class="line">        <span class="comment">// parallelized, vectorized, split, etc as usual.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Vectorizing, splitting, or parallelize the variables that</span></div>
<div class="line">        <span class="comment">// are part of the reduction domain is trickier. We&#39;ll cover</span></div>
<div class="line">        <span class="comment">// that in a later lesson.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Consider the definition:</span></div>
<div class="line">        Func f;</div>
<div class="line">        f(x, y) = x * y;</div>
<div class="line">        <span class="comment">// Set row zero to each row 8</span></div>
<div class="line">        f(x, 0) = f(x, 8);</div>
<div class="line">        <span class="comment">// Set column zero equal to column 8 plus 2</span></div>
<div class="line">        f(0, y) = f(8, y) + 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The pure variables in each stage can be scheduled</span></div>
<div class="line">        <span class="comment">// independently. To control the pure definition, we schedule</span></div>
<div class="line">        <span class="comment">// as we have done in the past. The following code vectorizes</span></div>
<div class="line">        <span class="comment">// and parallelizes the pure definition only.</span></div>
<div class="line">        f.vectorize(x, 4).parallel(y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We use Func::update(int) to get a handle to an update step</span></div>
<div class="line">        <span class="comment">// for the purposes of scheduling. The following line</span></div>
<div class="line">        <span class="comment">// vectorizes the first update step across x. We can&#39;t do</span></div>
<div class="line">        <span class="comment">// anything with y for this update step, because it doesn&#39;t</span></div>
<div class="line">        <span class="comment">// use y.</span></div>
<div class="line">        f.update(0).vectorize(x, 4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now we parallelize the second update step in chunks of size</span></div>
<div class="line">        <span class="comment">// 4.</span></div>
<div class="line">        Var yo, yi;</div>
<div class="line">        f.update(1).split(y, yo, yi, 4).parallel(yo);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = f.realize({16, 16});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_update_schedule.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Here&#39;s the equivalent (serial) C:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[16][16];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Pure step. Vectorized in x and parallelized in y.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) {  <span class="comment">// Should be a parallel for loop</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {</div>
<div class="line">                <span class="keywordtype">int</span> x[] = {x_vec * 4, x_vec * 4 + 1, x_vec * 4 + 2, x_vec * 4 + 3};</div>
<div class="line">                c_result[y][x[0]] = x[0] * y;</div>
<div class="line">                c_result[y][x[1]] = x[1] * y;</div>
<div class="line">                c_result[y][x[2]] = x[2] * y;</div>
<div class="line">                c_result[y][x[3]] = x[3] * y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First update. Vectorized in x.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {</div>
<div class="line">            <span class="keywordtype">int</span> x[] = {x_vec * 4, x_vec * 4 + 1, x_vec * 4 + 2, x_vec * 4 + 3};</div>
<div class="line">            c_result[0][x[0]] = c_result[8][x[0]];</div>
<div class="line">            c_result[0][x[1]] = c_result[8][x[1]];</div>
<div class="line">            c_result[0][x[2]] = c_result[8][x[2]];</div>
<div class="line">            c_result[0][x[3]] = c_result[8][x[3]];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Second update. Parallelized in chunks of size 4 in y.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 4; yo++) {  <span class="comment">// Should be a parallel for loop</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 4; yi++) {</div>
<div class="line">                <span class="keywordtype">int</span> y = yo * 4 + yi;</div>
<div class="line">                c_result[y][0] = c_result[y][8] + 2;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the C and Halide results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 16; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// That covers how to schedule the variables within a Func that</span></div>
<div class="line">    <span class="comment">// uses update steps, but what about producer-consumer</span></div>
<div class="line">    <span class="comment">// relationships that involve compute_at and store_at? Let&#39;s</span></div>
<div class="line">    <span class="comment">// examine a reduction as a producer, in a producer-consumer pair.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Because an update does multiple passes over a stored array,</span></div>
<div class="line">        <span class="comment">// it&#39;s not meaningful to inline them. So the default schedule</span></div>
<div class="line">        <span class="comment">// for them does the closest thing possible. It computes them</span></div>
<div class="line">        <span class="comment">// in the innermost loop of their consumer. Consider this</span></div>
<div class="line">        <span class="comment">// trivial example:</span></div>
<div class="line">        Func producer, consumer;</div>
<div class="line">        producer(x) = x * 2;</div>
<div class="line">        producer(x) += 10;</div>
<div class="line">        consumer(x) = 2 * producer(x);</div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_inline_reduction.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            producer_storage[0] = x * 2;</div>
<div class="line">            <span class="comment">// Update step for producer</span></div>
<div class="line">            producer_storage[0] = producer_storage[0] + 10;</div>
<div class="line">            <span class="comment">// Pure step for consumer</span></div>
<div class="line">            c_result[x] = 2 * producer_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For all other compute_at/store_at options, the reduction</span></div>
<div class="line">        <span class="comment">// gets placed where you would expect, somewhere in the loop</span></div>
<div class="line">        <span class="comment">// nest of the consumer.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now let&#39;s consider a reduction as a consumer in a</span></div>
<div class="line">    <span class="comment">// producer-consumer pair. This is a little more involved.</span></div>
<div class="line">    <span class="comment">// Case 1: The consumer references the producer in the pure step only.</span></div>
<div class="line">    {</div>
<div class="line">        Func producer, consumer;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The producer is pure.</span></div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 2 * producer(x);</div>
<div class="line">        consumer(x) += 50;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The valid schedules for the producer in this case are</span></div>
<div class="line">        <span class="comment">// the default schedule - inlined, and also:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 1) producer.compute_at(x), which places the computation of</span></div>
<div class="line">        <span class="comment">// the producer inside the loop over x in the pure step of the</span></div>
<div class="line">        <span class="comment">// consumer.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 2) producer.compute_root(), which computes all of the</span></div>
<div class="line">        <span class="comment">// producer ahead of time.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// 3) producer.store_root().compute_at(x), which allocates</span></div>
<div class="line">        <span class="comment">// space for the consumer outside the loop over x, but fills</span></div>
<div class="line">        <span class="comment">// it in as needed inside the loop.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Let&#39;s use option 1.</span></div>
<div class="line"> </div>
<div class="line">        producer.compute_at(consumer, x);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_pure.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] = 2 * producer_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] += 50;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// All of the pure step is evaluated before any of the</span></div>
<div class="line">        <span class="comment">// update step, so there are two separate loops over x.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 2: The consumer references the producer in the update step only</span></div>
<div class="line">        Func producer, consumer;</div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 100 - x * 10;</div>
<div class="line">        consumer(x) += producer(x);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Again we compute the producer per x coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer. This places producer code inside the update</span></div>
<div class="line">        <span class="comment">// step of the consumer, because that&#39;s the only step that</span></div>
<div class="line">        <span class="comment">// uses the producer.</span></div>
<div class="line">        producer.compute_at(consumer, x);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note however, that we didn&#39;t say:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// producer.compute_at(consumer.update(0), x).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Scheduling is done with respect to Vars of a Func, and</span></div>
<div class="line">        <span class="comment">// the Vars of a Func are shared across the pure and</span></div>
<div class="line">        <span class="comment">// update steps.</span></div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] = 100 - x * 10;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] += producer_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 3: The consumer references the producer in</span></div>
<div class="line">        <span class="comment">// multiple steps that share common variables</span></div>
<div class="line">        Func producer, consumer;</div>
<div class="line">        producer(x) = x * 17;</div>
<div class="line">        consumer(x) = 170 - producer(x);</div>
<div class="line">        consumer(x) += producer(x) / 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Again we compute the producer per x coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer. This places producer code inside both the</span></div>
<div class="line">        <span class="comment">// pure and the update step of the consumer. So there end</span></div>
<div class="line">        <span class="comment">// up being two separate realizations of the producer, and</span></div>
<div class="line">        <span class="comment">// redundant work occurs.</span></div>
<div class="line">        producer.compute_at(consumer, x);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_pure_and_update.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] = 170 - producer_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// Another copy of the pure step for producer</span></div>
<div class="line">            <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">            producer_storage[0] = x * 17;</div>
<div class="line">            c_result[x] += producer_storage[0] / 2;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 4: The consumer references the producer in</span></div>
<div class="line">        <span class="comment">// multiple steps that do not share common variables</span></div>
<div class="line">        Func producer, consumer;</div>
<div class="line">        producer(x, y) = (x * y) / 10 + 8;</div>
<div class="line">        consumer(x, y) = x + y;</div>
<div class="line">        consumer(x, 0) += producer(x, x);</div>
<div class="line">        consumer(0, y) += producer(y, 9 - y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// In this case neither producer.compute_at(consumer, x)</span></div>
<div class="line">        <span class="comment">// nor producer.compute_at(consumer, y) will work, because</span></div>
<div class="line">        <span class="comment">// either one fails to cover one of the uses of the</span></div>
<div class="line">        <span class="comment">// producer. So we&#39;d have to inline producer, or use</span></div>
<div class="line">        <span class="comment">// producer.compute_root().</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Let&#39;s say we really really want producer to be</span></div>
<div class="line">        <span class="comment">// compute_at the inner loops of both consumer update</span></div>
<div class="line">        <span class="comment">// steps. Halide doesn&#39;t allow multiple different</span></div>
<div class="line">        <span class="comment">// schedules for a single Func, but we can work around it</span></div>
<div class="line">        <span class="comment">// by making two wrappers around producer, and scheduling</span></div>
<div class="line">        <span class="comment">// those instead:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Attempt 2:</span></div>
<div class="line">        Func producer_1, producer_2, consumer_2;</div>
<div class="line">        producer_1(x, y) = producer(x, y);</div>
<div class="line">        producer_2(x, y) = producer(x, y);</div>
<div class="line"> </div>
<div class="line">        consumer_2(x, y) = x + y;</div>
<div class="line">        consumer_2(x, 0) += producer_1(x, x);</div>
<div class="line">        consumer_2(0, y) += producer_2(y, 9 - y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The wrapper functions give us two separate handles on</span></div>
<div class="line">        <span class="comment">// the producer, so we can schedule them differently.</span></div>
<div class="line">        producer_1.compute_at(consumer_2, x);</div>
<div class="line">        producer_2.compute_at(consumer_2, y);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer_2.realize({10, 10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_multiple_updates.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10][10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">                c_result[y][x] = x + y;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// First update step for consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_1_storage[1];</div>
<div class="line">            producer_1_storage[0] = (x * x) / 10 + 8;</div>
<div class="line">            c_result[0][x] += producer_1_storage[0];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Second update step for consumer</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordtype">int</span> producer_2_storage[1];</div>
<div class="line">            producer_2_storage[0] = (y * (9 - y)) / 10 + 8;</div>
<div class="line">            c_result[y][0] += producer_2_storage[0];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Case 5: Scheduling a producer under a reduction domain</span></div>
<div class="line">        <span class="comment">// variable of the consumer.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We are not just restricted to scheduling producers at</span></div>
<div class="line">        <span class="comment">// the loops over the pure variables of the consumer. If a</span></div>
<div class="line">        <span class="comment">// producer is only used within a loop over a reduction</span></div>
<div class="line">        <span class="comment">// domain (RDom) variable, we can also schedule the</span></div>
<div class="line">        <span class="comment">// producer there.</span></div>
<div class="line"> </div>
<div class="line">        Func producer, consumer;</div>
<div class="line"> </div>
<div class="line">        RDom r(0, 5);</div>
<div class="line">        producer(x) = x % 8;</div>
<div class="line">        consumer(x) = x + 10;</div>
<div class="line">        consumer(x) += r + producer(x + r);</div>
<div class="line"> </div>
<div class="line">        producer.compute_at(consumer, r);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result = consumer.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_09_compute_at_rvar.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="comment">// Pure step for the consumer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            c_result[x] = x + 10;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Update step for the consumer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="comment">// The loop over the reduction domain is always the inner loop.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 5; r++) {</div>
<div class="line">                <span class="comment">// We&#39;ve schedule the storage and computation of</span></div>
<div class="line">                <span class="comment">// the producer here. We just need a single value.</span></div>
<div class="line">                <span class="keywordtype">int</span> producer_storage[1];</div>
<div class="line">                <span class="comment">// Pure step of the producer.</span></div>
<div class="line">                producer_storage[0] = (x + r) % 8;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Now use it in the update step of the consumer.</span></div>
<div class="line">                c_result[x] += r + producer_storage[0];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A real-world example of a reduction inside a producer-consumer chain.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The default schedule for a reduction is a good one for</span></div>
<div class="line">        <span class="comment">// convolution-like operations. For example, the following</span></div>
<div class="line">        <span class="comment">// computes a 5x5 box-blur of our grayscale test image with a</span></div>
<div class="line">        <span class="comment">// clamp-to-edge boundary condition:</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First add the boundary condition.</span></div>
<div class="line">        Func clamped = <a name="a0"></a><a class="code" href="namespace_halide_1_1_boundary_conditions.html#a0548f23db36e4a8a03690bc8bee1e850">BoundaryConditions::repeat_edge</a>(input);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define a 5x5 box that starts at (-2, -2)</span></div>
<div class="line">        RDom r(-2, 5, -2, 5);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the 5x5 sum around each pixel.</span></div>
<div class="line">        Func local_sum;</div>
<div class="line">        local_sum(x, y) = 0;  <span class="comment">// Compute the sum as a 32-bit integer</span></div>
<div class="line">        local_sum(x, y) += clamped(x + r.x, y + r.y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Divide the sum by 25 to make it an average</span></div>
<div class="line">        Func blurry;</div>
<div class="line">        blurry(x, y) = cast&lt;uint8_t&gt;(local_sum(x, y) / 25);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;uint8_t&gt; halide_result = blurry.realize({input.width(), input.height()});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The default schedule will inline &#39;clamped&#39; into the update</span></div>
<div class="line">        <span class="comment">// step of &#39;local_sum&#39;, because clamped only has a pure</span></div>
<div class="line">        <span class="comment">// definition, and so its default schedule is fully-inlined.</span></div>
<div class="line">        <span class="comment">// We will then compute local_sum per x coordinate of blurry,</span></div>
<div class="line">        <span class="comment">// because the default schedule for reductions is</span></div>
<div class="line">        <span class="comment">// compute-innermost. Here&#39;s the equivalent C:</span></div>
<div class="line"> </div>
<div class="line">        Buffer&lt;uint8_t&gt; c_result(input.width(), input.height());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordtype">int</span> local_sum[1];</div>
<div class="line">                <span class="comment">// Pure step of local_sum</span></div>
<div class="line">                local_sum[0] = 0;</div>
<div class="line">                <span class="comment">// Update step of local_sum</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = -2; r_y &lt;= 2; r_y++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = -2; r_x &lt;= 2; r_x++) {</div>
<div class="line">                        <span class="comment">// The clamping has been inlined into the update step.</span></div>
<div class="line">                        <span class="keywordtype">int</span> clamped_x = <a name="a1"></a><a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(<a name="a2"></a><a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">std::max</a>(x + r_x, 0), input.width() - 1);</div>
<div class="line">                        <span class="keywordtype">int</span> clamped_y = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(<a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">std::max</a>(y + r_y, 0), input.height() - 1);</div>
<div class="line">                        local_sum[0] += input(clamped_x, clamped_y);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Pure step of blurry</span></div>
<div class="line">                c_result(x, y) = (<a name="a3"></a><a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>)(local_sum[0] / 25);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result(x, y));</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Reduction helpers.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// There are several reduction helper functions provided in</span></div>
<div class="line">        <span class="comment">// Halide.h, which compute small reductions and schedule them</span></div>
<div class="line">        <span class="comment">// innermost into their consumer. The most useful one is</span></div>
<div class="line">        <span class="comment">// &quot;sum&quot;.</span></div>
<div class="line">        Func f1;</div>
<div class="line">        RDom r(0, 100);</div>
<div class="line">        f1(x) = <a name="a4"></a><a class="code" href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">sum</a>(r + x) * 7;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sum creates a small anonymous Func to do the reduction. It&#39;s equivalent to:</span></div>
<div class="line">        Func f2;</div>
<div class="line">        Func anon;</div>
<div class="line">        anon(x) = 0;</div>
<div class="line">        anon(x) += r + x;</div>
<div class="line">        f2(x) = anon(x) * 7;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// So even though f1 references a reduction domain, it is a</span></div>
<div class="line">        <span class="comment">// pure function. The reduction domain has been swallowed to</span></div>
<div class="line">        <span class="comment">// define the inner anonymous reduction.</span></div>
<div class="line"> </div>
<div class="line">        Buffer&lt;int&gt; halide_result_1 = f1.realize({10});</div>
<div class="line">        Buffer&lt;int&gt; halide_result_2 = f2.realize({10});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        <span class="keywordtype">int</span> c_result[10];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordtype">int</span> anon[1];</div>
<div class="line">            anon[0] = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 100; r++) {</div>
<div class="line">                anon[0] += r + x;</div>
<div class="line">            }</div>
<div class="line">            c_result[x] = anon[0] * 7;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check they all match.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result_1(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result_1(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result_1(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (halide_result_2(x) != c_result[x]) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;halide_result_2(%d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                       x, halide_result_2(x), c_result[x]);</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A complex example that uses reduction helpers.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Other reduction helpers include &quot;product&quot;, &quot;minimum&quot;,</span></div>
<div class="line">        <span class="comment">// &quot;maximum&quot;, &quot;argmin&quot;, and &quot;argmax&quot;. Using argmin and argmax</span></div>
<div class="line">        <span class="comment">// requires understanding tuples, which come in a later</span></div>
<div class="line">        <span class="comment">// lesson. Let&#39;s use minimum and maximum to compute the local</span></div>
<div class="line">        <span class="comment">// spread of our grayscale image.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First, add a boundary condition to the input.</span></div>
<div class="line">        Func clamped;</div>
<div class="line">        Expr x_clamped = <a name="a5"></a><a class="code" href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">clamp</a>(x, 0, input.width() - 1);</div>
<div class="line">        Expr y_clamped = <a class="code" href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">clamp</a>(y, 0, input.height() - 1);</div>
<div class="line">        clamped(x, y) = input(x_clamped, y_clamped);</div>
<div class="line"> </div>
<div class="line">        RDom box(-2, 5, -2, 5);</div>
<div class="line">        <span class="comment">// Compute the local maximum minus the local minimum:</span></div>
<div class="line">        Func spread;</div>
<div class="line">        spread(x, y) = (<a name="a6"></a><a class="code" href="namespace_halide.html#a20c3805a6d059a671810c6d004e8d1bd">maximum</a>(clamped(x + box.x, y + box.y)) -</div>
<div class="line">                        <a name="a7"></a><a class="code" href="namespace_halide.html#aab45b50a1d7838663e5cfaceff50d8b7">minimum</a>(clamped(x + box.x, y + box.y)));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute the result in strips of 32 scanlines</span></div>
<div class="line">        Var yo, yi;</div>
<div class="line">        spread.split(y, yo, yi, 32).parallel(yo);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Vectorize across x within the strips. This implicitly</span></div>
<div class="line">        <span class="comment">// vectorizes stuff that is computed within the loop over x in</span></div>
<div class="line">        <span class="comment">// spread, which includes our minimum and maximum helpers, so</span></div>
<div class="line">        <span class="comment">// they get vectorized too.</span></div>
<div class="line">        spread.vectorize(x, 16);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll apply the boundary condition by padding each scanline</span></div>
<div class="line">        <span class="comment">// as we need it in a circular buffer (see lesson 08).</span></div>
<div class="line">        clamped.store_at(spread, yo).compute_at(spread, yi);</div>
<div class="line"> </div>
<div class="line">        Buffer&lt;uint8_t&gt; halide_result = spread.realize({input.width(), input.height()});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The C equivalent is almost too horrible to contemplate (and</span></div>
<div class="line"><span class="comment">// took me a long time to debug). This time I want to time</span></div>
<div class="line"><span class="comment">// both the Halide version and the C version, so I&#39;ll use sse</span></div>
<div class="line"><span class="comment">// intrinsics for the vectorization, and openmp to do the</span></div>
<div class="line"><span class="comment">// parallel for loop (you&#39;ll need to compile with -fopenmp or</span></div>
<div class="line"><span class="comment">// similar to get correct timing).</span></div>
<div class="line"><span class="preprocessor">#ifdef __SSE2__</span></div>
<div class="line">        <span class="comment">// Don&#39;t include the time required to allocate the output buffer.</span></div>
<div class="line">        Buffer&lt;uint8_t&gt; c_result(input.width(), input.height());</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef _OPENMP</span></div>
<div class="line">        <span class="keywordtype">double</span> t1 = current_time();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Run this one hundred times so we can average the timing results.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; (input.height() + 31) / 32; yo++) {</div>
<div class="line">                <span class="keywordtype">int</span> y_base = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(yo * 32, input.height() - 32);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Compute clamped in a circular buffer of size 8</span></div>
<div class="line">                <span class="comment">// (smallest power of two greater than 5). Each thread</span></div>
<div class="line">                <span class="comment">// needs its own allocation, so it must occur here.</span></div>
<div class="line"> </div>
<div class="line">                <span class="keywordtype">int</span> clamped_width = input.width() + 4;</div>
<div class="line">                <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_storage = (<a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)<a name="a8"></a><a class="code" href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc</a>(clamped_width * 8);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 32; yi++) {</div>
<div class="line">                    <span class="keywordtype">int</span> y = y_base + yi;</div>
<div class="line"> </div>
<div class="line">                    <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *output_row = &amp;c_result(0, y);</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Compute clamped for this scanline, skipping rows</span></div>
<div class="line">                    <span class="comment">// already computed within this slice.</span></div>
<div class="line">                    <span class="keywordtype">int</span> min_y_clamped = (yi == 0) ? (y - 2) : (y + 2);</div>
<div class="line">                    <span class="keywordtype">int</span> max_y_clamped = (y + 2);</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cy = min_y_clamped; cy &lt;= max_y_clamped; cy++) {</div>
<div class="line">                        <span class="comment">// Figure out which row of the circular buffer</span></div>
<div class="line">                        <span class="comment">// we&#39;re filling in using bitmasking:</span></div>
<div class="line">                        <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                            clamped_storage + (cy &amp; 7) * clamped_width;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Figure out which row of the input we&#39;re reading</span></div>
<div class="line">                        <span class="comment">// from by clamping the y coordinate:</span></div>
<div class="line">                        <span class="keywordtype">int</span> clamped_y = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(<a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">std::max</a>(cy, 0), input.height() - 1);</div>
<div class="line">                        <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *input_row = &amp;input(0, clamped_y);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Fill it in with the padding.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -2; x &lt; input.width() + 2; x++) {</div>
<div class="line">                            <span class="keywordtype">int</span> clamped_x = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(<a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">std::max</a>(x, 0), input.width() - 1);</div>
<div class="line">                            *clamped_row++ = input_row[clamped_x];</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Now iterate over vectors of x for the pure step of the output.</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; (input.width() + 15) / 16; x_vec++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x_base = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(x_vec * 16, input.width() - 16);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Allocate storage for the minimum and maximum</span></div>
<div class="line">                        <span class="comment">// helpers. One vector is enough.</span></div>
<div class="line">                        __m128i minimum_storage, maximum_storage;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The pure step for the maximum is a vector of zeros</span></div>
<div class="line">                        maximum_storage = _mm_setzero_si128();</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The update step for maximum</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_y = y - 2; max_y &lt;= y + 2; max_y++) {</div>
<div class="line">                            <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                                clamped_storage + (max_y &amp; 7) * clamped_width;</div>
<div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_x = x_base - 2; max_x &lt;= x_base + 2; max_x++) {</div>
<div class="line">                                __m128i v = _mm_loadu_si128(</div>
<div class="line">                                    (__m128i <span class="keyword">const</span> *)(clamped_row + max_x + 2));</div>
<div class="line">                                maximum_storage = _mm_max_epu8(maximum_storage, v);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The pure step for the minimum is a vector of</span></div>
<div class="line">                        <span class="comment">// ones. Create it by comparing something to</span></div>
<div class="line">                        <span class="comment">// itself.</span></div>
<div class="line">                        minimum_storage = _mm_cmpeq_epi32(_mm_setzero_si128(),</div>
<div class="line">                                                          _mm_setzero_si128());</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The update step for minimum.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_y = y - 2; min_y &lt;= y + 2; min_y++) {</div>
<div class="line">                            <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *clamped_row =</div>
<div class="line">                                clamped_storage + (min_y &amp; 7) * clamped_width;</div>
<div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_x = x_base - 2; min_x &lt;= x_base + 2; min_x++) {</div>
<div class="line">                                __m128i v = _mm_loadu_si128(</div>
<div class="line">                                    (__m128i <span class="keyword">const</span> *)(clamped_row + min_x + 2));</div>
<div class="line">                                minimum_storage = _mm_min_epu8(minimum_storage, v);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Now compute the spread.</span></div>
<div class="line">                        __m128i spread = _mm_sub_epi8(maximum_storage, minimum_storage);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Store it.</span></div>
<div class="line">                        _mm_storeu_si128((__m128i *)(output_row + x_base), spread);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <a name="a9"></a><a class="code" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(clamped_storage);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Skip the timing comparison if we don&#39;t have openmp</span></div>
<div class="line"><span class="comment">// enabled. Otherwise it&#39;s unfair to C.</span></div>
<div class="line"><span class="preprocessor">#ifdef _OPENMP</span></div>
<div class="line">        <span class="keywordtype">double</span> t2 = current_time();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now run the Halide version again without the</span></div>
<div class="line">        <span class="comment">// jit-compilation overhead. Also run it one hundred times.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {</div>
<div class="line">            spread.realize(halide_result);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> t3 = current_time();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Report the timings. On my machine they both take about 3ms</span></div>
<div class="line">        <span class="comment">// for the 4-megapixel input (fast!), which makes sense,</span></div>
<div class="line">        <span class="comment">// because they&#39;re using the same vectorization and</span></div>
<div class="line">        <span class="comment">// parallelization strategy. However I find the Halide easier</span></div>
<div class="line">        <span class="comment">// to read, write, debug, modify, and port.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Halide spread took %f ms. C equivalent took %f ms\n&quot;</span>,</div>
<div class="line">               (t3 - t2) / 100, (t2 - t1) / 100);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// _OPENMP</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check the results match:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.height(); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.width(); x++) {</div>
<div class="line">                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result(x, y));</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// __SSE2__</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_halide_1_1_boundary_conditions_html_a0548f23db36e4a8a03690bc8bee1e850"><div class="ttname"><a href="namespace_halide_1_1_boundary_conditions.html#a0548f23db36e4a8a03690bc8bee1e850">Halide::BoundaryConditions::repeat_edge</a></div><div class="ttdeci">Func repeat_edge(const Func &amp;source, const Region &amp;bounds)</div><div class="ttdoc">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the give...</div></div>
<div class="ttc" id="anamespace_halide_html"><div class="ttname"><a href="namespace_halide.html">Halide</a></div><div class="ttdoc">This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...</div><div class="ttdef"><b>Definition:</b> <a href="_add_atomic_mutex_8h_source.html#l00021">AddAtomicMutex.h:21</a></div></div>
<div class="ttc" id="anamespace_halide_html_a20c3805a6d059a671810c6d004e8d1bd"><div class="ttname"><a href="namespace_halide.html#a20c3805a6d059a671810c6d004e8d1bd">Halide::maximum</a></div><div class="ttdeci">Expr maximum(Expr, const std::string &amp;s=&quot;maximum&quot;)</div></div>
<div class="ttc" id="anamespace_halide_html_a40b1c066344e4816e822a467522bb1f1"><div class="ttname"><a href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">Halide::clamp</a></div><div class="ttdeci">Expr clamp(Expr a, const Expr &amp;min_val, const Expr &amp;max_val)</div><div class="ttdoc">Clamps an expression to lie within the given bounds.</div></div>
<div class="ttc" id="anamespace_halide_html_a41aa8982b04d0b5faf76de0fd4c0cc33"><div class="ttname"><a href="namespace_halide.html#a41aa8982b04d0b5faf76de0fd4c0cc33">Halide::sum</a></div><div class="ttdeci">Expr sum(Expr, const std::string &amp;s=&quot;sum&quot;)</div><div class="ttdoc">An inline reduction.</div></div>
<div class="ttc" id="anamespace_halide_html_a842daf6fbd0f87ec9ea8336cb0cdd23e"><div class="ttname"><a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">Halide::min</a></div><div class="ttdeci">Expr min(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdoc">Explicit overloads of min and max for FuncRef.</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00578">Func.h:578</a></div></div>
<div class="ttc" id="anamespace_halide_html_aab45b50a1d7838663e5cfaceff50d8b7"><div class="ttname"><a href="namespace_halide.html#aab45b50a1d7838663e5cfaceff50d8b7">Halide::minimum</a></div><div class="ttdeci">Expr minimum(Expr, const std::string &amp;s=&quot;minimum&quot;)</div></div>
<div class="ttc" id="anamespace_halide_html_aea2c7f5fe6c79a49dcbb28951cf8405d"><div class="ttname"><a href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">Halide::max</a></div><div class="ttdeci">Expr max(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00581">Func.h:581</a></div></div>
<div class="ttc" id="aruntime__internal_8h_html_a1c8580582aae58105f16108d4ec89e9a"><div class="ttname"><a href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc</a></div><div class="ttdeci">void * malloc(size_t)</div></div>
<div class="ttc" id="aruntime__internal_8h_html_a5f44f30d12f5ed554d1bdb9825df6137"><div class="ttname"><a href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a></div><div class="ttdeci">unsigned __INT8_TYPE__ uint8_t</div><div class="ttdef"><b>Definition:</b> <a href="runtime__internal_8h_source.html#l00025">runtime_internal.h:25</a></div></div>
<div class="ttc" id="aruntime__internal_8h_html_af07d89f5ceaea0c7c8252cc41fd75f37"><div class="ttname"><a href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a></div><div class="ttdeci">void free(void *)</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
