<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_halide_1_1_internal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_autoscheduler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_autoscheduler.html">Autoscheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_elf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_elf.html">Elf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_generator_min_max"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_integer_division"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_introspection"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_introspection.html">Introspection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html">IRMatcher</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative template-metaprogramming approach to expression matching. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an associative op with its identity.  <a href="struct_halide_1_1_internal_1_1_associative_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent the equivalent associative op of an update definition.  <a href="struct_halide_1_1_internal_1_1_associative_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1aslog.html">aslog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_pipeline_features.html">PipelineFeatures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_schedule_features.html">ScheduleFeatures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_weights.html">Weights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_find_all_calls.html">FindAllCalls</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for keeping track of functions that are directly called and the arguments with which they are called.  <a href="class_halide_1_1_internal_1_1_find_all_calls.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the bounds of a region of arbitrary dimension.  <a href="struct_halide_1_1_internal_1_1_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name.html">all_ints_and_optional_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_first_00_01_rest_8_8_8_01_4.html">all_ints_and_optional_name&lt; First, Rest... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_t_01_4.html">all_ints_and_optional_name&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_4.html">all_ints_and_optional_name&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html">CodeGen_MIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html">CodeGen_PowerPC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___py_torch.html">CodeGen_PyTorch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code to wrap a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline so that it can be used as a C++ extension operator in <a class="el" href="namespace_halide_1_1_py_torch.html">PyTorch</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___py_torch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___r_i_s_c_v.html">CodeGen_RISCV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___r_i_s_c_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___web_assembly.html">CodeGen_WebAssembly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits WebAssembly code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___web_assembly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html">JSONCompilerLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html" title="JSONCompilerLogger is a basic implementation of the CompilerLogger interface that saves logged data,...">JSONCompilerLogger</a> is a basic implementation of the <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> interface that saves logged data, then logs it all in JSON format in <a class="el" href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html#acae75903027e56d5b48e15a90826a4ec" title="Emit all the gathered data to the given stream.">emit_to_stream()</a>.  <a href="class_halide_1_1_internal_1_1_j_s_o_n_compiler_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> optional debugging during codegen, use the debug class as follows:  <a href="class_halide_1_1_internal_1_1debug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition which can either represent a init or an update definition.  <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of reduction variables the expression or tuple depends on.  <a href="struct_halide_1_1_internal_1_1_reduction_variable_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all calls to image buffers and parameters in the function.  <a href="struct_halide_1_1_internal_1_1_buffer_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html">DeviceArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> looks similar to an <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Halide::Argument</a>, but has behavioral differences that make it specific to the GPU pipeline; the fact that neither is-a nor has-a <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Halide::Argument</a> is deliberate.  <a href="struct_halide_1_1_internal_1_1_device_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_host_closure.html">HostClosure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a> modified to inspect GPU-specific memory accesses, and produce a vector of <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> objects.  <a href="class_halide_1_1_internal_1_1_host_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_dimension.html">Dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_voidifier.html">Voidifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer constants.  <a href="struct_halide_1_1_internal_1_1_u_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A possibly-weak pointer to a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> function.  <a href="struct_halide_1_1_internal_1_1_function_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html">ValueTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html" title="ValueTracker is an internal utility class that attempts to track and flag certain obvious Stub-relate...">ValueTracker</a> is an internal utility class that attempts to track and flag certain obvious Stub-related errors at <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> compile time: it tracks the constraints set on any Parameter-based argument (i.e., Input&lt;Buffer&gt; and Output&lt;Buffer&gt;) to ensure that incompatible values aren't set.  <a href="class_halide_1_1_internal_1_1_value_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">GeneratorParamImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">GeneratorParam_String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html">StubInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html" title="StubInputBuffer is the placeholder that a Stub uses when it requires a Buffer for an input (rather th...">StubInputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an input (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>).  <a href="class_halide_1_1_internal_1_1_stub_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer_base.html">StubOutputBufferBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html">StubOutputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html" title="StubOutputBuffer is the placeholder that a Stub uses when it requires a Buffer for an output (rather ...">StubOutputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a> for an output (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>).  <a href="class_halide_1_1_internal_1_1_stub_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input.html">StubInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html">GIOBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html" title="GIOBase is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not pa...">GIOBase</a> is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not part of the public API and should never be used directly by user code.  <a href="class_halide_1_1_internal_1_1_g_i_o_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_base.html">GeneratorInputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_impl.html">GeneratorInputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1type__sink.html">type_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method_3_01_t2_00_01typename_01type__si902d603523cc7c0df71b135e75cbe224.html">has_static_halide_type_method&lt; T2, typename type_sink&lt; decltype(T2::static_halide_type())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_base.html">GeneratorOutputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_impl.html">GeneratorOutputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___synthetic.html">GeneratorParam_Synthetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations.html">NoRealizations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_4.html">NoRealizations&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_01_t_00_01_args_8_8_8_01_4.html">NoRealizations&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_info.html">GeneratorParamInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_register_generator.html">RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_stub.html">GeneratorStub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_hexagon_alignment_analyzer.html">HexagonAlignmentAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inferred argument.  <a href="struct_halide_1_1_internal_1_1_inferred_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent ranges of Exprs.  <a href="struct_halide_1_1_internal_1_1_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself.">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual IR nodes begin here.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> a value from a named symbol if predicate is true.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'lanes' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then evaluate and return the message, which should be a call to an error function.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_producer_consumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a> a 'value' to the buffer called 'name' at a given 'index' if 'predicate' is true.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer.">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_fork.html">Fork</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of statements executed concurrently.  <a href="struct_halide_1_1_internal_1_1_fork.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_acquire.html">Acquire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new vector by taking elements from another sequence of vectors.  <a href="struct_halide_1_1_internal_1_1_shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a multi-dimensional region of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> or an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a> that needs to be prefetched.  <a href="struct_halide_1_1_internal_1_1_prefetch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_atomic.html">Atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all the <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a> nodes in the body statement.  <a href="struct_halide_1_1_internal_1_1_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html">VectorReduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally reduce a vector to a scalar or narrower vector using the given commutative and associative binary operator.  <a href="struct_halide_1_1_internal_1_1_vector_reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html">IRDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that computes a lexical ordering on IR nodes.  <a href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_compare_cache.html">IRCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lossily track known equal exprs with a cache.  <a href="class_halide_1_1_internal_1_1_i_r_compare_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html">ExprWithCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper about Exprs so that they can be deeply compared with a cache for known-equal subexpressions.  <a href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html">IRGraphMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator that caches and reapplies previously-done mutations, so that it can handle graphs of IR that have not had CSE done to them.  <a href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_variadic_visitor.html">VariadicVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor/mutator capable of passing arbitrary arguments to the visit methods using CRTP and returning any types from them.  <a href="class_halide_1_1_internal_1_1_variadic_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_module.html">JITModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">JITHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_user_context.html">JITUserContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_i_t_shared_runtime.html">JITSharedRuntime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> of an argument to a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a>.  <a href="struct_halide_1_1_internal_1_1_lowered_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition.">Definition</a> of a lowered function.  <a href="struct_halide_1_1_internal_1_1_lowered_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_python_extension_gen.html">PythonExtensionGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain.">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cost.html">Cost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_region_costs.html">RegionCosts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto scheduling component which is used to assign costs for computing a region of a function or one of its stages.  <a href="struct_halide_1_1_internal_1_1_region_costs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_p_u_compilation_cache.html">GPUCompilationCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_halide_1_1_internal_1_1_dim.html" title="The Dim struct represents one loop in the schedule&#39;s representation of a loop nest.">Dim</a> struct represents one loop in the schedule's representation of a loop nest.  <a href="struct_halide_1_1_internal_1_1_dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bound on a loop, typically from <a class="el" href="class_halide_1_1_func.html#aa0f0f793275ea1d83361747ea13ccd7a" title="Statically declare that the range over which a function should be evaluated is given by the second an...">Func::bound</a>.  <a href="struct_halide_1_1_internal_1_1_bound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_storage_dim.html">StorageDim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties of one axis of the storage of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="struct_halide_1_1_internal_1_1_storage_dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents two stages with fused loop nests from outermost to a specific loop level.  <a href="struct_halide_1_1_internal_1_1_fused_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_func_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack_3_01void_01_4.html">SmallStack&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding.html">ScopedBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for pushing/popping Scope&lt;&gt; values, to allow for early-exit in Visitor/Mutators that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding_3_01void_01_4.html">ScopedBinding&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">meta_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_01_4.html">meta_and&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or.html">meta_or</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or_3_01_t1_00_01_args_8_8_8_01_4.html">meta_or&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">all_are_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_value.html">ScopedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for saving/restoring variable values on the stack, to allow for early-exit that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1next__integer__sequence.html">next_integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1next__integer__sequence_3_01integer__sequence_3_01_t_00_01_ints_8_8_8_01_4_01_4.html">next_integer_sequence&lt; integer_sequence&lt; T, Ints... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper_3_01_t_00_01_n_00_01_n_01_4.html">make_integer_sequence_helper&lt; T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_static_cast.html">StaticCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_roundtrippable.html">IsRoundtrippable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_wasm_module.html">WasmModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to compiled wasm code which can be called later.  <a href="struct_halide_1_1_internal_1_1_wasm_module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_gpu_object_lifetime_tracker.html">GpuObjectLifetimeTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abff8dba5612d856cc2acfab99e3cf479"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a></td></tr>
<tr class="separator:abff8dba5612d856cc2acfab99e3cf479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0611a86047e2c583dd061a620dcc6e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr class="separator:aaa0611a86047e2c583dd061a620dcc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c76d77a93240aaabd916abf0b10beb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ae0c76d77a93240aaabd916abf0b10beb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae0c76d77a93240aaabd916abf0b10beb">add_const_if_T_is_const</a> = typename std::conditional&lt; std::is_const&lt; T &gt;::value, const T2, T2 &gt;::type</td></tr>
<tr class="separator:ae0c76d77a93240aaabd916abf0b10beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40a4f8fc5c4fcce2e0b5656bd6c831bb">GeneratorParamImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a> &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, std::string &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">GeneratorParam_String</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, bool &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_enum&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a>&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:a40a4f8fc5c4fcce2e0b5656bd6c831bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebc4e1b658e316d9738ac723778525e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:aaebc4e1b658e316d9738ac723778525e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaebc4e1b658e316d9738ac723778525e">GeneratorInputImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; TBase, <a class="el" href="class_halide_1_1_func.html">Func</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_scalar&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a>&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:aaebc4e1b658e316d9738ac723778525e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3efc8f40050501582a4dc9dafcd18a9">GeneratorOutputImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; TBase, <a class="el" href="class_halide_1_1_func.html">Func</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a>&lt; T &gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a>&lt; T &gt; &gt;&gt;::type</td></tr>
<tr class="separator:ab3efc8f40050501582a4dc9dafcd18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc4779d7bb27645f2fc95ab5aaab4d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6bc4779d7bb27645f2fc95ab5aaab4d8">GeneratorFactory</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a> &gt;(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a> &amp;)&gt;</td></tr>
<tr class="separator:a6bc4779d7bb27645f2fc95ab5aaab4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e4e2eb6b31542f36a2c879aa18c48a7">GeneratorParamsMap</a> = std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a> &gt;</td></tr>
<tr class="separator:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab837f22cfa4bfe22dba01f4908e839ff"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab837f22cfa4bfe22dba01f4908e839ff">halide_task</a>) (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="separator:ab837f22cfa4bfe22dba01f4908e839ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114c2dcec2af79da28735c5b11c0916"><td class="memItemLeft" align="right" valign="top">typedef llvm::raw_pwrite_stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">LLVMOStream</a></td></tr>
<tr class="separator:a7114c2dcec2af79da28735c5b11c0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplParams" colspan="2">template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a>&lt; T, 0, N &gt;::type</td></tr>
<tr class="separator:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplParams" colspan="2">template&lt;size_t... Ints&gt; </td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5d7a7bcb6b4a7de95e27c3234a36c68">index_sequence</a> = <a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a>&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, Ints... &gt;</td></tr>
<tr class="separator:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a77432e592449f569978b6aabd58831f0">make_index_sequence</a> = <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a>&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, N &gt;</td></tr>
<tr class="separator:a77432e592449f569978b6aabd58831f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8548315fd4d13ccebe45a8123369f7ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> { <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec">Upper</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93">Lower</a>
 }</td></tr>
<tr class="memdesc:a8548315fd4d13ccebe45a8123369f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a varying expression, try to find a constant that is either: An upper bound (always greater than or equal to the expression), or A lower bound (always less than or equal to the expression) If it fails, returns an undefined Expr.  <a href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">More...</a><br /></td></tr>
<tr class="separator:a8548315fd4d13ccebe45a8123369f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> { <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417">IntImm</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8">UIntImm</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07">FloatImm</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73">StringImm</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842">Broadcast</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c">Cast</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9">Variable</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2">Sub</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a">Div</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2">Min</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233">Max</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47">EQ</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0">NE</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b">LT</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6">LE</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020">GT</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9">GE</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b">And</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c">Or</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666">Not</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff">Select</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb">Load</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb">Ramp</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e">Call</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6">Let</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083">Shuffle</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">VectorReduce</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2">LetStmt</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742">AssertStmt</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0">ProducerConsumer</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11">For</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a993ca650a85e8e69b8f7eaa4809c4862">Acquire</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72">Store</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7">Provide</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f">Allocate</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594">Free</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc">Realize</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2">Block</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a36c81967df3424f919e89b09ed34c90d">Fork</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c">IfThenElse</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f">Evaluate</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e">Prefetch</a>
, <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a557eccd321b7f10f5127c1ef27aaac7d">Atomic</a>
<br />
 }</td></tr>
<tr class="memdesc:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">All our IR node types get unique IDs for the purposes of RTTI.  <a href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">More...</a><br /></td></tr>
<tr class="separator:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8761f129e6554b9ea03de31bf066f1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> { <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493">Serial</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131">Parallel</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725">Vectorized</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac">Unrolled</a>
, <br />
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a498ab78ee0b25ce33c83714c1a453831">Extern</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28">GPUBlock</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d">GPUThread</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642">GPULane</a>
<br />
 }</td></tr>
<tr class="memdesc:a6a8761f129e6554b9ea03de31bf066f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of loop traversal.  <a href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">More...</a><br /></td></tr>
<tr class="separator:a6a8761f129e6554b9ea03de31bf066f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ee070dfadab621e55f3b3dd971e18"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18">IOKind</a> { <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18af60357a8d17e45793298323f1b372a74">Scalar</a>
, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">Function</a>
, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a7e62bc342f41c946868f0ea6f0b712d8">Buffer</a>
 }</td></tr>
<tr class="separator:ae02ee070dfadab621e55f3b3dd971e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43770c59ec0f13935f4b33502ba7e817"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817">SyntheticParamType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9">Dim</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c">ArraySize</a>
 }</td></tr>
<tr class="separator:a43770c59ec0f13935f4b33502ba7e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> { <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255">Constant</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd">Increasing</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b">Decreasing</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
 }</td></tr>
<tr class="memdesc:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">More...</a><br /></td></tr>
<tr class="separator:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c72fcb8800b47e313c62f5416a4fe"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4feafbbbe5ac592bfdafcfa397cd609d8117">PureVar</a> = 0
, <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fead117eadbd7c1c4d821b3a598d54d03f2">PureRVar</a>
, <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4feac2ab1e3a4730b5543c84be4a4a223b83">ImpureRVar</a>
 }</td></tr>
<tr class="memdesc:a5b8c72fcb8800b47e313c62f5416a4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each Dim below has a dim_type, which tells you what transformations are legal on it.  <a href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fe">More...</a><br /></td></tr>
<tr class="separator:a5b8c72fcb8800b47e313c62f5416a4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d0ab1dd42e03181bf0320902e233995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2d0ab1dd42e03181bf0320902e233995">add_atomic_mutex</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="separator:a2d0ab1dd42e03181bf0320902e233995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5c6a19891ace3a590f49ba456ca1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afe5c6a19891ace3a590f49ba456ca1d6">add_image_checks</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;fb, bool will_inject_host_copies)</td></tr>
<tr class="memdesc:afe5c6a19891ace3a590f49ba456ca1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g.  <a href="namespace_halide_1_1_internal.html#afe5c6a19891ace3a590f49ba456ca1d6">More...</a><br /></td></tr>
<tr class="separator:afe5c6a19891ace3a590f49ba456ca1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1610da9bbdeab59ba5d7724231352ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1610da9bbdeab59ba5d7724231352ab">add_parameter_checks</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:af1610da9bbdeab59ba5d7724231352ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure that all referenced parameters meet their constraints.  <a href="namespace_halide_1_1_internal.html#af1610da9bbdeab59ba5d7724231352ab">More...</a><br /></td></tr>
<tr class="separator:af1610da9bbdeab59ba5d7724231352ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4111f5909dc405a5d564c7c0c2c4a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e4111f5909dc405a5d564c7c0c2c4a4">align_loads</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, int alignment)</td></tr>
<tr class="memdesc:a1e4111f5909dc405a5d564c7c0c2c4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors.  <a href="namespace_halide_1_1_internal.html#a1e4111f5909dc405a5d564c7c0c2c4a4">More...</a><br /></td></tr>
<tr class="separator:a1e4111f5909dc405a5d564c7c0c2c4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eac3ad68dfb697c5ee97100f2053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a410eac3ad68dfb697c5ee97100f2053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables.  <a href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">More...</a><br /></td></tr>
<tr class="separator:a410eac3ad68dfb697c5ee97100f2053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab98c44d7a462e3217c6a4f6ddbe3bc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aab98c44d7a462e3217c6a4f6ddbe3bc7">apply_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, bool is_update, const std::string &amp;prefix, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;dim_extent_alignment)</td></tr>
<tr class="memdesc:aab98c44d7a462e3217c6a4f6ddbe3bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let).  <a href="namespace_halide_1_1_internal.html#aab98c44d7a462e3217c6a4f6ddbe3bc7">More...</a><br /></td></tr>
<tr class="separator:aab98c44d7a462e3217c6a4f6ddbe3bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639111963bc0698b1b724299ec35b840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a639111963bc0698b1b724299ec35b840">compute_loop_bounds_after_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a639111963bc0698b1b724299ec35b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions.  <a href="namespace_halide_1_1_internal.html#a639111963bc0698b1b724299ec35b840">More...</a><br /></td></tr>
<tr class="separator:a639111963bc0698b1b724299ec35b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43db81cbccaa74354f14e7f902094ed8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43db81cbccaa74354f14e7f902094ed8">get_ops_table</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;exprs)</td></tr>
<tr class="separator:a43db81cbccaa74354f14e7f902094ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf049bd392c948b161c1435e23184a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acf049bd392c948b161c1435e23184a20">prove_associativity</a> (const std::string &amp;f, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; args, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; exprs)</td></tr>
<tr class="memdesc:acf049bd392c948b161c1435e23184a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any.  <a href="namespace_halide_1_1_internal.html#acf049bd392c948b161c1435e23184a20">More...</a><br /></td></tr>
<tr class="separator:acf049bd392c948b161c1435e23184a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6050713d80d82d1ba201fc9f709b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a74a6050713d80d82d1ba201fc9f709b7">associativity_test</a> ()</td></tr>
<tr class="separator:a74a6050713d80d82d1ba201fc9f709b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092d026f554bbd98a3c603e58e6e46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0092d026f554bbd98a3c603e58e6e46e">fork_async_producers</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="separator:a0092d026f554bbd98a3c603e58e6e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdf8e17b611c700b1a41969a8dc7c1e1">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an int representation of 's'.  <a href="namespace_halide_1_1_internal.html#acdf8e17b611c700b1a41969a8dc7c1e1">More...</a><br /></td></tr>
<tr class="separator:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553a170f5d655144a90d342f46bb5bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a553a170f5d655144a90d342f46bb5bc7">substitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a553a170f5d655144a90d342f46bb5bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> with its estimate if specified.  <a href="namespace_halide_1_1_internal.html#a553a170f5d655144a90d342f46bb5bc7">More...</a><br /></td></tr>
<tr class="separator:a553a170f5d655144a90d342f46bb5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c43260020b62213bc2383cb13f7aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a78c43260020b62213bc2383cb13f7aeb">substitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="separator:a78c43260020b62213bc2383cb13f7aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f09ed39b20fb0f51fbda5a7b14c7f93">get_extent</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;i)</td></tr>
<tr class="memdesc:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an interval.  <a href="namespace_halide_1_1_internal.html#a7f09ed39b20fb0f51fbda5a7b14c7f93">More...</a><br /></td></tr>
<tr class="separator:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce3144d60aa2f3abdb127b3750cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a09ce3144d60aa2f3abdb127b3750cb73">box_size</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a09ce3144d60aa2f3abdb127b3750cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an n-d box.  <a href="namespace_halide_1_1_internal.html#a09ce3144d60aa2f3abdb127b3750cb73">More...</a><br /></td></tr>
<tr class="separator:a09ce3144d60aa2f3abdb127b3750cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f30fc5e0c64f2e3f32ffe1416f045b0">disp_regions</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;regions)</td></tr>
<tr class="memdesc:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to print the bounds of a region.  <a href="namespace_halide_1_1_internal.html#a5f30fc5e0c64f2e3f32ffe1416f045b0">More...</a><br /></td></tr>
<tr class="separator:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf44d2ab2c8eca7437d770011107830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cf44d2ab2c8eca7437d770011107830">get_stage_definition</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a4cf44d2ab2c8eca7437d770011107830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding definition of a function given the stage.  <a href="namespace_halide_1_1_internal.html#a4cf44d2ab2c8eca7437d770011107830">More...</a><br /></td></tr>
<tr class="separator:a4cf44d2ab2c8eca7437d770011107830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12964871a49b9d9eb81fb01991771150"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12964871a49b9d9eb81fb01991771150">get_stage_dims</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a12964871a49b9d9eb81fb01991771150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding loop dimensions of a function given the stage.  <a href="namespace_halide_1_1_internal.html#a12964871a49b9d9eb81fb01991771150">More...</a><br /></td></tr>
<tr class="separator:a12964871a49b9d9eb81fb01991771150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a753561dbe4e01ef75c2af4ce17d3dfb1">combine_load_costs</a> (std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;partial)</td></tr>
<tr class="memdesc:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> partial load costs to the corresponding function in the result costs.  <a href="namespace_halide_1_1_internal.html#a753561dbe4e01ef75c2af4ce17d3dfb1">More...</a><br /></td></tr>
<tr class="separator:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47061da7dd7653e9d9058b850d94e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2f47061da7dd7653e9d9058b850d94e5">get_stage_bounds</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num, const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:a2f47061da7dd7653e9d9058b850d94e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions.  <a href="namespace_halide_1_1_internal.html#a2f47061da7dd7653e9d9058b850d94e5">More...</a><br /></td></tr>
<tr class="separator:a2f47061da7dd7653e9d9058b850d94e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b43d784b088d341d5cb7b465da9e68"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a20b43d784b088d341d5cb7b465da9e68">get_stage_bounds</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:a20b43d784b088d341d5cb7b465da9e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds for all the stages of the function 'f'.  <a href="namespace_halide_1_1_internal.html#a20b43d784b088d341d5cb7b465da9e68">More...</a><br /></td></tr>
<tr class="separator:a20b43d784b088d341d5cb7b465da9e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7faaf922e66ac6f7367697d18fd1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1d7faaf922e66ac6f7367697d18fd1cd">perform_inline</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::set&lt; std::string &gt; &amp;inlines=std::set&lt; std::string &gt;(), const std::vector&lt; std::string &gt; &amp;order=std::vector&lt; std::string &gt;())</td></tr>
<tr class="memdesc:a1d7faaf922e66ac6f7367697d18fd1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression.  <a href="namespace_halide_1_1_internal.html#a1d7faaf922e66ac6f7367697d18fd1cd">More...</a><br /></td></tr>
<tr class="separator:a1d7faaf922e66ac6f7367697d18fd1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d082a8fe5678245509867a53372c3"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f6d082a8fe5678245509867a53372c3">get_parents</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, int stage)</td></tr>
<tr class="memdesc:a5f6d082a8fe5678245509867a53372c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all functions that are directly called by a function stage (f, stage).  <a href="namespace_halide_1_1_internal.html#a5f6d082a8fe5678245509867a53372c3">More...</a><br /></td></tr>
<tr class="separator:a5f6d082a8fe5678245509867a53372c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a765c203107b702636e6f2cf5ba896f95">get_element</a> (const std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="memdesc:a765c203107b702636e6f2cf5ba896f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of element within a map.  <a href="namespace_halide_1_1_internal.html#a765c203107b702636e6f2cf5ba896f95">More...</a><br /></td></tr>
<tr class="separator:a765c203107b702636e6f2cf5ba896f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a46ec18d54c5534ccccc9e21ac262"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a525a46ec18d54c5534ccccc9e21ac262"><td class="memTemplItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a525a46ec18d54c5534ccccc9e21ac262">get_element</a> (std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="separator:a525a46ec18d54c5534ccccc9e21ac262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976aabd7126fce7f9d7a46daeee8fd40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a976aabd7126fce7f9d7a46daeee8fd40">inline_all_trivial_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a976aabd7126fce7f9d7a46daeee8fd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="namespace_halide_1_1_internal.html#a976aabd7126fce7f9d7a46daeee8fd40">More...</a><br /></td></tr>
<tr class="separator:a976aabd7126fce7f9d7a46daeee8fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120045d61aae3bbe15e3da7b81bbb821"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a120045d61aae3bbe15e3da7b81bbb821">is_func_called_element_wise</a> (const std::vector&lt; std::string &gt; &amp;order, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> index, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a120045d61aae3bbe15e3da7b81bbb821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> (order[index]) is only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner.  <a href="namespace_halide_1_1_internal.html#a120045d61aae3bbe15e3da7b81bbb821">More...</a><br /></td></tr>
<tr class="separator:a120045d61aae3bbe15e3da7b81bbb821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e38c670066041490103529f6c5707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adb0e38c670066041490103529f6c5707">inline_all_element_wise_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:adb0e38c670066041490103529f6c5707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner.  <a href="namespace_halide_1_1_internal.html#adb0e38c670066041490103529f6c5707">More...</a><br /></td></tr>
<tr class="separator:adb0e38c670066041490103529f6c5707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654878c752bfbc9f2aa979007ff80037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a654878c752bfbc9f2aa979007ff80037">propagate_estimate_test</a> ()</td></tr>
<tr class="separator:a654878c752bfbc9f2aa979007ff80037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff82b6f1aebe05e4b73da31dd6d6c69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a> ()</td></tr>
<tr class="separator:aaff82b6f1aebe05e4b73da31dd6d6c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b0883bbda1c2664341158fce0b030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a963b0883bbda1c2664341158fce0b030">bounds_of_expr_in_scope</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>(), bool const_bound=false)</td></tr>
<tr class="memdesc:a963b0883bbda1c2664341158fce0b030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="namespace_halide_1_1_internal.html#a963b0883bbda1c2664341158fce0b030">More...</a><br /></td></tr>
<tr class="separator:a963b0883bbda1c2664341158fce0b030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f08062dfc06a1816ce78793faf5477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a61f08062dfc06a1816ce78793faf5477">find_constant_bound</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> d, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope())</td></tr>
<tr class="separator:a61f08062dfc06a1816ce78793faf5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34593e7612bf139260707200b6dacb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa34593e7612bf139260707200b6dacb3">find_constant_bounds</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:aa34593e7612bf139260707200b6dacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bounds for a varying expression that are either constants or +/-inf.  <a href="namespace_halide_1_1_internal.html#aa34593e7612bf139260707200b6dacb3">More...</a><br /></td></tr>
<tr class="separator:aa34593e7612bf139260707200b6dacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand box a to encompass box b.  <a href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">More...</a><br /></td></tr>
<tr class="separator:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9641dd947fdf6352ccd5e34548db35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9641dd947fdf6352ccd5e34548db35e">boxes_overlap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac9641dd947fdf6352ccd5e34548db35e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a could possibly overlap box b.  <a href="namespace_halide_1_1_internal.html#ac9641dd947fdf6352ccd5e34548db35e">More...</a><br /></td></tr>
<tr class="separator:ac9641dd947fdf6352ccd5e34548db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86d8a9b260b097d115182e4b8488f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af86d8a9b260b097d115182e4b8488f09">box_union</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:af86d8a9b260b097d115182e4b8488f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of two boxes.  <a href="namespace_halide_1_1_internal.html#af86d8a9b260b097d115182e4b8488f09">More...</a><br /></td></tr>
<tr class="separator:af86d8a9b260b097d115182e4b8488f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c57c8cff1c0ff811a01724b58086bdc">box_intersection</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a8c57c8cff1c0ff811a01724b58086bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intersection of two boxes.  <a href="namespace_halide_1_1_internal.html#a8c57c8cff1c0ff811a01724b58086bdc">More...</a><br /></td></tr>
<tr class="separator:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198438916c78b87c90e665d665a18cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9198438916c78b87c90e665d665a18cd">box_contains</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a9198438916c78b87c90e665d665a18cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a provably contains box b.  <a href="namespace_halide_1_1_internal.html#a9198438916c78b87c90e665d665a18cd">More...</a><br /></td></tr>
<tr class="separator:a9198438916c78b87c90e665d665a18cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2207eb7ea627a6c40ef9112d5992e58e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2207eb7ea627a6c40ef9112d5992e58e">boxes_required</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a2207eb7ea627a6c40ef9112d5992e58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression.  <a href="namespace_halide_1_1_internal.html#a2207eb7ea627a6c40ef9112d5992e58e">More...</a><br /></td></tr>
<tr class="separator:a2207eb7ea627a6c40ef9112d5992e58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f1f17003b595e2ce4fdf3b20028f1f"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a08f1f17003b595e2ce4fdf3b20028f1f">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a08f1f17003b595e2ce4fdf3b20028f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835e975cd27bec85e3b6eba41818ed51"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a835e975cd27bec85e3b6eba41818ed51">boxes_provided</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a835e975cd27bec85e3b6eba41818ed51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="namespace_halide_1_1_internal.html#a835e975cd27bec85e3b6eba41818ed51">More...</a><br /></td></tr>
<tr class="separator:a835e975cd27bec85e3b6eba41818ed51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888d5a8e9f3f2571477f2a79257bb725"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a888d5a8e9f3f2571477f2a79257bb725">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a888d5a8e9f3f2571477f2a79257bb725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068250f17aa862eac84cfdaf439c9a8c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a068250f17aa862eac84cfdaf439c9a8c">boxes_touched</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a068250f17aa862eac84cfdaf439c9a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="namespace_halide_1_1_internal.html#a068250f17aa862eac84cfdaf439c9a8c">More...</a><br /></td></tr>
<tr class="separator:a068250f17aa862eac84cfdaf439c9a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0ccd7d9bbf3e0868391038fd0f6401"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8b0ccd7d9bbf3e0868391038fd0f6401">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a8b0ccd7d9bbf3e0868391038fd0f6401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6463d6b6c8c2d39485ca75d70bf7b246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6463d6b6c8c2d39485ca75d70bf7b246">box_required</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="memdesc:a6463d6b6c8c2d39485ca75d70bf7b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="namespace_halide_1_1_internal.html#a6463d6b6c8c2d39485ca75d70bf7b246">More...</a><br /></td></tr>
<tr class="separator:a6463d6b6c8c2d39485ca75d70bf7b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9b1c2da827d6cb5394a0bb7e34533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a98c9b1c2da827d6cb5394a0bb7e34533">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a98c9b1c2da827d6cb5394a0bb7e34533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48514c5115221230858e6e5b8584877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae48514c5115221230858e6e5b8584877">box_provided</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:ae48514c5115221230858e6e5b8584877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f44cfeb8474bb0aaa36e526fd65e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a48f44cfeb8474bb0aaa36e526fd65e35">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a48f44cfeb8474bb0aaa36e526fd65e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b563d3cf1a063d9c85a584f796d032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa4b563d3cf1a063d9c85a584f796d032">box_touched</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:aa4b563d3cf1a063d9c85a584f796d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3eadf5a7fa994f622e31c373bcf3d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6d3eadf5a7fa994f622e31c373bcf3d3">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>())</td></tr>
<tr class="separator:a6d3eadf5a7fa994f622e31c373bcf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807d0d1524fb2f20b1533d05032c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0b807d0d1524fb2f20b1533d05032c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <a href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">More...</a><br /></td></tr>
<tr class="separator:a0b807d0d1524fb2f20b1533d05032c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ef9127bf30f5e2a67963eb8db0323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr class="separator:a439ef9127bf30f5e2a67963eb8db0323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2369df82ba80121eb935e5ac7076de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab2369df82ba80121eb935e5ac7076de5">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;<a class="el" href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c">realization_order</a>, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ab2369df82ba80121eb935e5ac7076de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="namespace_halide_1_1_internal.html#ab2369df82ba80121eb935e5ac7076de5">More...</a><br /></td></tr>
<tr class="separator:ab2369df82ba80121eb935e5ac7076de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7428f5e071a4f8c2d89a79afc6b426a0">bound_small_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58338c6b3553965f8360efe1d31788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b58338c6b3553965f8360efe1d31788">buffer_accessor</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a9b58338c6b3553965f8360efe1d31788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aefca0281fde1b4caf8d1d188d4bd809d">get_name_from_end_of_parameter_pack</a> (T &amp;&amp;)</td></tr>
<tr class="separator:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3480ee712c4aecb9425a7e5c540889f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae3480ee712c4aecb9425a7e5c540889f">get_name_from_end_of_parameter_pack</a> (const std::string &amp;n)</td></tr>
<tr class="separator:ae3480ee712c4aecb9425a7e5c540889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a8762a4f14a3d708461f0d1616bc2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a016a8762a4f14a3d708461f0d1616bc2">get_name_from_end_of_parameter_pack</a> ()</td></tr>
<tr class="separator:a016a8762a4f14a3d708461f0d1616bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Args&gt; </td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70ab4586f42653c6b16a6e0ad186f1e5">get_name_from_end_of_parameter_pack</a> (First first, Second second, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab882d8987fcdb737d28066db1130b509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab882d8987fcdb737d28066db1130b509">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="separator:ab882d8987fcdb737d28066db1130b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d23994d86bd76a8167c6144f3a3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a352d23994d86bd76a8167c6144f3a3dc">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;)</td></tr>
<tr class="separator:a352d23994d86bd76a8167c6144f3a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc82b2d635d098a40d4b87018edd0a73">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;result, int x, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:afc82b2d635d098a40d4b87018edd0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae7ed87b50654371fbd0e1415c8d52e4e">get_shape_from_start_of_parameter_pack</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844f5db8861adba47dc2dc0e38666407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a844f5db8861adba47dc2dc0e38666407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a844f5db8861adba47dc2dc0e38666407">buffer_type_name_non_const</a> (std::ostream &amp;s)</td></tr>
<tr class="separator:a844f5db8861adba47dc2dc0e38666407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f55fb27359093d52c4c4447db053edc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7f55fb27359093d52c4c4447db053edc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f55fb27359093d52c4c4447db053edc">buffer_type_name_non_const&lt; void &gt;</a> (std::ostream &amp;s)</td></tr>
<tr class="separator:a7f55fb27359093d52c4c4447db053edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14638fa4f1475b6b6acb22a9419afea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab14638fa4f1475b6b6acb22a9419afea"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab14638fa4f1475b6b6acb22a9419afea">buffer_type_name</a> ()</td></tr>
<tr class="separator:ab14638fa4f1475b6b6acb22a9419afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefe960250b26cc13e38cb734803057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5eefe960250b26cc13e38cb734803057">canonicalize_gpu_vars</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5eefe960250b26cc13e38cb734803057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize GPU var names into some pre-determined block/thread names (i.e.  <a href="namespace_halide_1_1_internal.html#a5eefe960250b26cc13e38cb734803057">More...</a><br /></td></tr>
<tr class="separator:a5eefe960250b26cc13e38cb734803057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e82dcdf95ffc30f75298421434b23"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afb8e82dcdf95ffc30f75298421434b23">new_CodeGen_D3D12Compute_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:afb8e82dcdf95ffc30f75298421434b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34de426bebece420150ce4122a60984"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af34de426bebece420150ce4122a60984">new_CodeGen_Hexagon</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, llvm::LLVMContext &amp;context)</td></tr>
<tr class="separator:af34de426bebece420150ce4122a60984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cff24ff522c4d1603ab6d068096937"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a22cff24ff522c4d1603ab6d068096937">build_closure_type</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, llvm::StructType *halide_buffer_t_type, llvm::LLVMContext *context)</td></tr>
<tr class="memdesc:a22cff24ff522c4d1603ab6d068096937"><td class="mdescLeft">&#160;</td><td class="mdescRight">The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a>.  <a href="namespace_halide_1_1_internal.html#a22cff24ff522c4d1603ab6d068096937">More...</a><br /></td></tr>
<tr class="separator:a22cff24ff522c4d1603ab6d068096937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d846909bbfed031801337b1a8203ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7d846909bbfed031801337b1a8203ed3">pack_closure</a> (llvm::StructType *type, llvm::Value *<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;src, llvm::StructType *halide_buffer_t_type, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *builder)</td></tr>
<tr class="memdesc:a7d846909bbfed031801337b1a8203ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that builds a struct containing all the externally referenced state.  <a href="namespace_halide_1_1_internal.html#a7d846909bbfed031801337b1a8203ed3">More...</a><br /></td></tr>
<tr class="separator:a7d846909bbfed031801337b1a8203ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0822c4fa8fbb5790406eb22d2d5849ca">unpack_closure</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, llvm::StructType *type, llvm::Value *src, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *builder)</td></tr>
<tr class="memdesc:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that unpacks a struct containing all the externally referenced state into a symbol table.  <a href="namespace_halide_1_1_internal.html#a0822c4fa8fbb5790406eb22d2d5849ca">More...</a><br /></td></tr>
<tr class="separator:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f10140e29131153c3be98d2899b090"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr class="memdesc:a71f10140e29131153c3be98d2899b090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">More...</a><br /></td></tr>
<tr class="separator:a71f10140e29131153c3be98d2899b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99e3563cd430c42905e547bfb02082b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad99e3563cd430c42905e547bfb02082b">get_vector_num_elements</a> (llvm::Type *)</td></tr>
<tr class="memdesc:ad99e3563cd430c42905e547bfb02082b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements in an llvm vector type, or return 1 if it's not a vector type.  <a href="namespace_halide_1_1_internal.html#ad99e3563cd430c42905e547bfb02082b">More...</a><br /></td></tr>
<tr class="separator:ad99e3563cd430c42905e547bfb02082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df32a68c28abfa75e1a5e397817a674"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1df32a68c28abfa75e1a5e397817a674">get_vector_element_type</a> (llvm::Type *)</td></tr>
<tr class="memdesc:a1df32a68c28abfa75e1a5e397817a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scalar type of an llvm vector type.  <a href="namespace_halide_1_1_internal.html#a1df32a68c28abfa75e1a5e397817a674">More...</a><br /></td></tr>
<tr class="separator:a1df32a68c28abfa75e1a5e397817a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915d1d0235eef96e4d9988a169a9f7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1915d1d0235eef96e4d9988a169a9f7d">element_count</a> (int e)</td></tr>
<tr class="separator:a1915d1d0235eef96e4d9988a169a9f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e666b9660ff646f788264bf2f08b95"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a28e666b9660ff646f788264bf2f08b95">get_vector_type</a> (llvm::Type *, int)</td></tr>
<tr class="separator:a28e666b9660ff646f788264bf2f08b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc60421b682a09ea4c4dcaaaa3e105e2">function_takes_user_context</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which built-in functions require a user-context first argument?  <a href="namespace_halide_1_1_internal.html#adc60421b682a09ea4c4dcaaaa3e105e2">More...</a><br /></td></tr>
<tr class="separator:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abe6b887804e86f403f0af16d5a2ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4abe6b887804e86f403f0af16d5a2ba1">can_allocation_fit_on_stack</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:a4abe6b887804e86f403f0af16d5a2ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False.  <a href="namespace_halide_1_1_internal.html#a4abe6b887804e86f403f0af16d5a2ba1">More...</a><br /></td></tr>
<tr class="separator:a4abe6b887804e86f403f0af16d5a2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14294d4d56333f9579e1cb083347df30"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14294d4d56333f9579e1cb083347df30">long_div_mod_round_to_zero</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *max_abs=nullptr)</td></tr>
<tr class="memdesc:a14294d4d56333f9579e1cb083347df30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a {div/mod}_round_to_zero using binary long division for int/uint.  <a href="namespace_halide_1_1_internal.html#a14294d4d56333f9579e1cb083347df30">More...</a><br /></td></tr>
<tr class="separator:a14294d4d56333f9579e1cb083347df30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a110889396502096d2b5e3995734ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7a110889396502096d2b5e3995734ef6">lower_mux</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *<a class="el" href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">mux</a>)</td></tr>
<tr class="memdesc:a7a110889396502096d2b5e3995734ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a mux intrinsic to a select tree.  <a href="namespace_halide_1_1_internal.html#a7a110889396502096d2b5e3995734ef6">More...</a><br /></td></tr>
<tr class="separator:a7a110889396502096d2b5e3995734ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4fa94b1f3a877eb3387824c09df826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b4fa94b1f3a877eb3387824c09df826">get_target_options</a> (const llvm::Module &amp;module, llvm::TargetOptions &amp;options, std::string &amp;mcpu, std::string &amp;mattrs)</td></tr>
<tr class="memdesc:a7b4fa94b1f3a877eb3387824c09df826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, set llvm:TargetOptions, cpu and attr information.  <a href="namespace_halide_1_1_internal.html#a7b4fa94b1f3a877eb3387824c09df826">More...</a><br /></td></tr>
<tr class="separator:a7b4fa94b1f3a877eb3387824c09df826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16d175882e16f544bf4bf92ec931b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1b16d175882e16f544bf4bf92ec931b5">clone_target_options</a> (const llvm::Module &amp;from, llvm::Module &amp;to)</td></tr>
<tr class="memdesc:a1b16d175882e16f544bf4bf92ec931b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two llvm::Modules, clone target options from one to the other.  <a href="namespace_halide_1_1_internal.html#a1b16d175882e16f544bf4bf92ec931b5">More...</a><br /></td></tr>
<tr class="separator:a1b16d175882e16f544bf4bf92ec931b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e20aff45028d266f854487159df341"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::TargetMachine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1e20aff45028d266f854487159df341">make_target_machine</a> (const llvm::Module &amp;module)</td></tr>
<tr class="memdesc:af1e20aff45028d266f854487159df341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, get or create an llvm:TargetMachine.  <a href="namespace_halide_1_1_internal.html#af1e20aff45028d266f854487159df341">More...</a><br /></td></tr>
<tr class="separator:af1e20aff45028d266f854487159df341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e7008bc30f56a6cbfb69a120ccf0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01e7008bc30f56a6cbfb69a120ccf0d0">set_function_attributes_for_target</a> (llvm::Function *, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;)</td></tr>
<tr class="memdesc:a01e7008bc30f56a6cbfb69a120ccf0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>.  <a href="namespace_halide_1_1_internal.html#a01e7008bc30f56a6cbfb69a120ccf0d0">More...</a><br /></td></tr>
<tr class="separator:a01e7008bc30f56a6cbfb69a120ccf0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fd598253847fcd510e32b107aeb2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36fd598253847fcd510e32b107aeb2f3">embed_bitcode</a> (llvm::Module *M, const std::string &amp;halide_command)</td></tr>
<tr class="memdesc:a36fd598253847fcd510e32b107aeb2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a copy of the llvm IR currently represented by the module as data in the __LLVM,__bitcode section.  <a href="namespace_halide_1_1_internal.html#a36fd598253847fcd510e32b107aeb2f3">More...</a><br /></td></tr>
<tr class="separator:a36fd598253847fcd510e32b107aeb2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57913c1a65cd4c4a6ccb3aeef5cccef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab57913c1a65cd4c4a6ccb3aeef5cccef">new_CodeGen_Metal_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:ab57913c1a65cd4c4a6ccb3aeef5cccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed8645ab46a91ec69efb386bf6f9fec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aeed8645ab46a91ec69efb386bf6f9fec">new_CodeGen_OpenCL_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:aeed8645ab46a91ec69efb386bf6f9fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd129afe2e75e5f434b573290cf50149"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd129afe2e75e5f434b573290cf50149">new_CodeGen_OpenGLCompute_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:abd129afe2e75e5f434b573290cf50149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1088b9db437ecb80a185a8250a6196a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1088b9db437ecb80a185a8250a6196a8">new_CodeGen_PTX_Dev</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a1088b9db437ecb80a185a8250a6196a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735759322b0f8490b0d550f4b10f4000"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a735759322b0f8490b0d550f4b10f4000">set_compiler_logger</a> (std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt; compiler_logger)</td></tr>
<tr class="memdesc:a735759322b0f8490b0d550f4b10f4000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object, replacing any existing one.  <a href="namespace_halide_1_1_internal.html#a735759322b0f8490b0d550f4b10f4000">More...</a><br /></td></tr>
<tr class="separator:a735759322b0f8490b0d550f4b10f4000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba1f88f3490dd824db2fb31bbe6339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a58ba1f88f3490dd824db2fb31bbe6339">get_compiler_logger</a> ()</td></tr>
<tr class="memdesc:a58ba1f88f3490dd824db2fb31bbe6339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object.  <a href="namespace_halide_1_1_internal.html#a58ba1f88f3490dd824db2fb31bbe6339">More...</a><br /></td></tr>
<tr class="separator:a58ba1f88f3490dd824db2fb31bbe6339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170638fdb8e1cb975e1ff7fb561a560"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9170638fdb8e1cb975e1ff7fb561a560">cplusplus_function_mangled_name</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;namespaces, <a class="el" href="struct_halide_1_1_type.html">Type</a> return_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;args, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a9170638fdb8e1cb975e1ff7fb561a560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mangled C++ name for a function.  <a href="namespace_halide_1_1_internal.html#a9170638fdb8e1cb975e1ff7fb561a560">More...</a><br /></td></tr>
<tr class="separator:a9170638fdb8e1cb975e1ff7fb561a560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d63fc361474a95f58c2839461cc7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a67d63fc361474a95f58c2839461cc7df">cplusplus_mangle_test</a> ()</td></tr>
<tr class="separator:a67d63fc361474a95f58c2839461cc7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2af44447b9269918e9d63d948ea8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f2af44447b9269918e9d63d948ea8bd">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:a5f2af44447b9269918e9d63d948ea8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="namespace_halide_1_1_internal.html#a5f2af44447b9269918e9d63d948ea8bd">More...</a><br /></td></tr>
<tr class="separator:a5f2af44447b9269918e9d63d948ea8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac03dcb48bcb8e81238a1c6cfea195e1a">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="namespace_halide_1_1_internal.html#ac03dcb48bcb8e81238a1c6cfea195e1a">More...</a><br /></td></tr>
<tr class="separator:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cbc086e9926046bdb9f4ade681111a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a88cbc086e9926046bdb9f4ade681111a">cse_test</a> ()</td></tr>
<tr class="separator:a88cbc086e9926046bdb9f4ade681111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f0a702bd775e67baed5bcd986ae27"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab98f0a702bd775e67baed5bcd986ae27">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:ab98f0a702bd775e67baed5bcd986ae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="namespace_halide_1_1_internal.html#ab98f0a702bd775e67baed5bcd986ae27">More...</a><br /></td></tr>
<tr class="separator:ab98f0a702bd775e67baed5bcd986ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029791644c90ea7a194d58fc87ab41bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a029791644c90ea7a194d58fc87ab41bf">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;)</td></tr>
<tr class="memdesc:a029791644c90ea7a194d58fc87ab41bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> in a human readable format.  <a href="namespace_halide_1_1_internal.html#a029791644c90ea7a194d58fc87ab41bf">More...</a><br /></td></tr>
<tr class="separator:a029791644c90ea7a194d58fc87ab41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d7f181b8a337d445a1df28de18384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a866d7f181b8a337d445a1df28de18384">debug_arguments</a> (<a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *func, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a866d7f181b8a337d445a1df28de18384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> that describe the target and arguments.  <a href="namespace_halide_1_1_internal.html#a866d7f181b8a337d445a1df28de18384">More...</a><br /></td></tr>
<tr class="separator:a866d7f181b8a337d445a1df28de18384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2b563fa94726a65b596979b9d2f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaea2b563fa94726a65b596979b9d2f85">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aaea2b563fa94726a65b596979b9d2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered.  <a href="namespace_halide_1_1_internal.html#aaea2b563fa94726a65b596979b9d2f85">More...</a><br /></td></tr>
<tr class="separator:aaea2b563fa94726a65b596979b9d2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a949dd909bf5d0b5aadc590c5dd2a61d0">extract_odd_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="namespace_halide_1_1_internal.html#a949dd909bf5d0b5aadc590c5dd2a61d0">More...</a><br /></td></tr>
<tr class="separator:a949dd909bf5d0b5aadc590c5dd2a61d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52cdf2d45822985407927e4a553dbe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad52cdf2d45822985407927e4a553dbe8">extract_even_lanes</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:ad52cdf2d45822985407927e4a553dbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="namespace_halide_1_1_internal.html#ad52cdf2d45822985407927e4a553dbe8">More...</a><br /></td></tr>
<tr class="separator:ad52cdf2d45822985407927e4a553dbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fea986b372b2a3932ae617ca62116d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a24fea986b372b2a3932ae617ca62116d">extract_lane</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;vec, int lane)</td></tr>
<tr class="memdesc:a24fea986b372b2a3932ae617ca62116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="namespace_halide_1_1_internal.html#a24fea986b372b2a3932ae617ca62116d">More...</a><br /></td></tr>
<tr class="separator:a24fea986b372b2a3932ae617ca62116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba806ef5f80bcc7ad6905f7789906cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acba806ef5f80bcc7ad6905f7789906cd">rewrite_interleavings</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:acba806ef5f80bcc7ad6905f7789906cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="namespace_halide_1_1_internal.html#acba806ef5f80bcc7ad6905f7789906cd">More...</a><br /></td></tr>
<tr class="separator:acba806ef5f80bcc7ad6905f7789906cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">deinterleave_vector_test</a> ()</td></tr>
<tr class="separator:a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa8d3c39b97b822e2c3e50a1c977441aa">remove_let_definitions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all let definitions of expr.  <a href="namespace_halide_1_1_internal.html#aa8d3c39b97b822e2c3e50a1c977441aa">More...</a><br /></td></tr>
<tr class="separator:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce9e5a21138e54d3b6ceb6e8d28b37a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ce9e5a21138e54d3b6ceb6e8d28b37a">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; std::string &gt; &amp;filter)</td></tr>
<tr class="memdesc:a9ce9e5a21138e54d3b6ceb6e8d28b37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variables' indices that expr depends on and are in the filter.  <a href="namespace_halide_1_1_internal.html#a9ce9e5a21138e54d3b6ceb6e8d28b37a">More...</a><br /></td></tr>
<tr class="separator:a9ce9e5a21138e54d3b6ceb6e8d28b37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75348e972a1020930f674670a8a95673"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75348e972a1020930f674670a8a95673">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;filter)</td></tr>
<tr class="separator:a75348e972a1020930f674670a8a95673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd0b2aa2de8bdaedec76acedad6fed"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a48cd0b2aa2de8bdaedec76acedad6fed">gather_rvariables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a48cd0b2aa2de8bdaedec76acedad6fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20174955742327f92120c99ab2d3bed"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab20174955742327f92120c99ab2d3bed">gather_rvariables</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;tuple)</td></tr>
<tr class="separator:ab20174955742327f92120c99ab2d3bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66032c9826d25bfa470c4c974081d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b66032c9826d25bfa470c4c974081d5">add_let_expression</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping, const std::vector&lt; std::string &gt; &amp;let_variables)</td></tr>
<tr class="memdesc:a9b66032c9826d25bfa470c4c974081d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> necessary let expressions to expr.  <a href="namespace_halide_1_1_internal.html#a9b66032c9826d25bfa470c4c974081d5">More...</a><br /></td></tr>
<tr class="separator:a9b66032c9826d25bfa470c4c974081d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8422615887974b7d347d7b069e592ced"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8422615887974b7d347d7b069e592ced">sort_expressions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a8422615887974b7d347d7b069e592ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically sort the expression graph expressed by expr.  <a href="namespace_halide_1_1_internal.html#a8422615887974b7d347d7b069e592ced">More...</a><br /></td></tr>
<tr class="separator:a8422615887974b7d347d7b069e592ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723b068d50849e69fc7f255d5716ed72"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a723b068d50849e69fc7f255d5716ed72">inference_bounds</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;funcs, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;output_bounds)</td></tr>
<tr class="memdesc:a723b068d50849e69fc7f255d5716ed72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounds of funcs.  <a href="namespace_halide_1_1_internal.html#a723b068d50849e69fc7f255d5716ed72">More...</a><br /></td></tr>
<tr class="separator:a723b068d50849e69fc7f255d5716ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bf1fdad80911ade94da1a53f58f2a5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a45bf1fdad80911ade94da1a53f58f2a5">inference_bounds</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;output_bounds)</td></tr>
<tr class="separator:a45bf1fdad80911ade94da1a53f58f2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff30be2f05a33246906cb93c5ef840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeff30be2f05a33246906cb93c5ef840">box_to_vector</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;bounds)</td></tr>
<tr class="memdesc:abeff30be2f05a33246906cb93c5ef840"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension.">Box</a> to vector of (min, extent)  <a href="namespace_halide_1_1_internal.html#abeff30be2f05a33246906cb93c5ef840">More...</a><br /></td></tr>
<tr class="separator:abeff30be2f05a33246906cb93c5ef840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d062e9354cd14001f47cd01e82b93a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a44d062e9354cd14001f47cd01e82b93a">equal</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds0, const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds1)</td></tr>
<tr class="memdesc:a44d062e9354cd14001f47cd01e82b93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bounds0 and bounds1 represent the same bounds.  <a href="namespace_halide_1_1_internal.html#a44d062e9354cd14001f47cd01e82b93a">More...</a><br /></td></tr>
<tr class="separator:a44d062e9354cd14001f47cd01e82b93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e35493cbdbaecbf87027d1b3474a5b8">vars_to_strings</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variable names.  <a href="namespace_halide_1_1_internal.html#a9e35493cbdbaecbf87027d1b3474a5b8">More...</a><br /></td></tr>
<tr class="separator:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c20a455c5f2aed48623d012438b99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a96c20a455c5f2aed48623d012438b99d">extract_rdom</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a96c20a455c5f2aed48623d012438b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reduction domain used by expr.  <a href="namespace_halide_1_1_internal.html#a96c20a455c5f2aed48623d012438b99d">More...</a><br /></td></tr>
<tr class="separator:a96c20a455c5f2aed48623d012438b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c553025a28a2d63ed43f8875bf4c18"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3c553025a28a2d63ed43f8875bf4c18">solve_inverse</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;new_var, const std::string &amp;var)</td></tr>
<tr class="memdesc:ab3c553025a28a2d63ed43f8875bf4c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">expr is new_var == f(var), solve for var == g(new_var) if multiple new_var corresponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>  <a href="namespace_halide_1_1_internal.html#ab3c553025a28a2d63ed43f8875bf4c18">More...</a><br /></td></tr>
<tr class="separator:ab3c553025a28a2d63ed43f8875bf4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6436cf62347fbab1ff9e413ec61caf9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6436cf62347fbab1ff9e413ec61caf9">find_buffer_param_calls</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func)</td></tr>
<tr class="separator:ae6436cf62347fbab1ff9e413ec61caf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07d22606b612c93b460aee695063291"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac07d22606b612c93b460aee695063291">find_implicit_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ac07d22606b612c93b460aee695063291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all implicit variables in expr.  <a href="namespace_halide_1_1_internal.html#ac07d22606b612c93b460aee695063291">More...</a><br /></td></tr>
<tr class="separator:ac07d22606b612c93b460aee695063291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7c0a6c9d1ffb171d4343876021f604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea7c0a6c9d1ffb171d4343876021f604">substitute_rdom_predicate</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aea7c0a6c9d1ffb171d4343876021f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the variable.  <a href="namespace_halide_1_1_internal.html#aea7c0a6c9d1ffb171d4343876021f604">More...</a><br /></td></tr>
<tr class="separator:aea7c0a6c9d1ffb171d4343876021f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b228248e212d4e140a3b7499f65a8c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b228248e212d4e140a3b7499f65a8c4">is_calling_function</a> (const std::string &amp;func_name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:a4b228248e212d4e140a3b7499f65a8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr contains call to func_name.  <a href="namespace_halide_1_1_internal.html#a4b228248e212d4e140a3b7499f65a8c4">More...</a><br /></td></tr>
<tr class="separator:a4b228248e212d4e140a3b7499f65a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1be017ee388aad7a1cb19fa653e300"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add1be017ee388aad7a1cb19fa653e300">is_calling_function</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:add1be017ee388aad7a1cb19fa653e300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr depends on any function or buffer.  <a href="namespace_halide_1_1_internal.html#add1be017ee388aad7a1cb19fa653e300">More...</a><br /></td></tr>
<tr class="separator:add1be017ee388aad7a1cb19fa653e300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038d35b4053c243832706da480e78f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a038d35b4053c243832706da480e78f80">substitute_call_arg_with_pure_arg</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, int variable_id, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a038d35b4053c243832706da480e78f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces call to <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f in <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e such that the call argument at variable_id is the pure argument.  <a href="namespace_halide_1_1_internal.html#a038d35b4053c243832706da480e78f80">More...</a><br /></td></tr>
<tr class="separator:a038d35b4053c243832706da480e78f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb129e599eb08042ff95446b7e040233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adb129e599eb08042ff95446b7e040233">make_device_interface_call</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api, <a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a> memory_type=<a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb">MemoryType::Auto</a>)</td></tr>
<tr class="memdesc:adb129e599eb08042ff95446b7e040233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> which evaluates to the device interface for the given device api at runtime.  <a href="namespace_halide_1_1_internal.html#adb129e599eb08042ff95446b7e040233">More...</a><br /></td></tr>
<tr class="separator:adb129e599eb08042ff95446b7e040233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4af08fdc8caf03891015c7dec4c8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a4af08fdc8caf03891015c7dec4c8c9">inject_early_frees</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a9a4af08fdc8caf03891015c7dec4c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="namespace_halide_1_1_internal.html#a9a4af08fdc8caf03891015c7dec4c8c9">More...</a><br /></td></tr>
<tr class="separator:a9a4af08fdc8caf03891015c7dec4c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0747a9e54d0da5a37c1530162121942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0747a9e54d0da5a37c1530162121942f">eliminated_bool_type</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> bool_type, <a class="el" href="struct_halide_1_1_type.html">Type</a> other_type)</td></tr>
<tr class="memdesc:a0747a9e54d0da5a37c1530162121942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors.  <a href="namespace_halide_1_1_internal.html#a0747a9e54d0da5a37c1530162121942f">More...</a><br /></td></tr>
<tr class="separator:a0747a9e54d0da5a37c1530162121942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e1020025973b3e49f515e57e126d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a860e1020025973b3e49f515e57e126d5">is_float16_transcendental</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *)</td></tr>
<tr class="memdesc:a860e1020025973b3e49f515e57e126d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a call is a float16 transcendental (e.g.  <a href="namespace_halide_1_1_internal.html#a860e1020025973b3e49f515e57e126d5">More...</a><br /></td></tr>
<tr class="separator:a860e1020025973b3e49f515e57e126d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9ff6cdf658b71397ad57ada686d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cd9ff6cdf658b71397ad57ada686d8f">lower_float16_transcendental_to_float32_equivalent</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *)</td></tr>
<tr class="memdesc:a4cd9ff6cdf658b71397ad57ada686d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a float16 transcendental using the float32 equivalent.  <a href="namespace_halide_1_1_internal.html#a4cd9ff6cdf658b71397ad57ada686d8f">More...</a><br /></td></tr>
<tr class="separator:a4cd9ff6cdf658b71397ad57ada686d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d9776355fa799b71816c0ab2e97e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c0d9776355fa799b71816c0ab2e97e6">float32_to_bfloat16</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a7c0d9776355fa799b71816c0ab2e97e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> to/from float and bfloat using bitwise math.  <a href="namespace_halide_1_1_internal.html#a7c0d9776355fa799b71816c0ab2e97e6">More...</a><br /></td></tr>
<tr class="separator:a7c0d9776355fa799b71816c0ab2e97e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bc1fe74ae6a148b8e7ee57f26c994d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa8bc1fe74ae6a148b8e7ee57f26c994d">float32_to_float16</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:aa8bc1fe74ae6a148b8e7ee57f26c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386f43e07f78c9b4be57358b183150ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a386f43e07f78c9b4be57358b183150ce">float16_to_float32</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:a386f43e07f78c9b4be57358b183150ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc4c96649e436c9f67531779788b077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adfc4c96649e436c9f67531779788b077">bfloat16_to_float32</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:adfc4c96649e436c9f67531779788b077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be785c18917d142a0fa55c86ab3a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a79be785c18917d142a0fa55c86ab3a87">lower_float16_cast</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *op)</td></tr>
<tr class="separator:a79be785c18917d142a0fa55c86ab3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63523f83489f292e9ac11d247dba7718"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a63523f83489f292e9ac11d247dba7718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a63523f83489f292e9ac11d247dba7718">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t) noexcept</td></tr>
<tr class="separator:a63523f83489f292e9ac11d247dba7718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3d80243a2f3de47f613df12b48475c3">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t)</td></tr>
<tr class="separator:ad3d80243a2f3de47f613df12b48475c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b46f80479d5e41ff7ebf80ced31267"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a89b46f80479d5e41ff7ebf80ced31267">is_unordered_parallel</a> (<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> for_type)</td></tr>
<tr class="memdesc:a89b46f80479d5e41ff7ebf80ced31267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if for_type executes for loop iterations in parallel and unordered.  <a href="namespace_halide_1_1_internal.html#a89b46f80479d5e41ff7ebf80ced31267">More...</a><br /></td></tr>
<tr class="separator:a89b46f80479d5e41ff7ebf80ced31267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa25b9bc3a80bac033c05e5178ab5a4c7">is_parallel</a> (<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> for_type)</td></tr>
<tr class="memdesc:aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if for_type executes for loop iterations in parallel.  <a href="namespace_halide_1_1_internal.html#aa25b9bc3a80bac033c05e5178ab5a4c7">More...</a><br /></td></tr>
<tr class="separator:aa25b9bc3a80bac033c05e5178ab5a4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16792c0d67cebb47fe0a30377c3e7212"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr , typename T &gt; </td></tr>
<tr class="memitem:a16792c0d67cebb47fe0a30377c3e7212"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16792c0d67cebb47fe0a30377c3e7212">stmt_or_expr_uses_vars</a> (const StmtOrExpr &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a16792c0d67cebb47fe0a30377c3e7212"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#a16792c0d67cebb47fe0a30377c3e7212">More...</a><br /></td></tr>
<tr class="separator:a16792c0d67cebb47fe0a30377c3e7212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr &gt; </td></tr>
<tr class="memitem:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5d94fcb5a93f4d4ddc839dc3f7631e5e">stmt_or_expr_uses_var</a> (const StmtOrExpr &amp;e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#a5d94fcb5a93f4d4ddc839dc3f7631e5e">More...</a><br /></td></tr>
<tr class="separator:a5d94fcb5a93f4d4ddc839dc3f7631e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734ee6c4861fe4be70badd557199d84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af734ee6c4861fe4be70badd557199d84">expr_uses_var</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af734ee6c4861fe4be70badd557199d84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#af734ee6c4861fe4be70badd557199d84">More...</a><br /></td></tr>
<tr class="separator:af734ee6c4861fe4be70badd557199d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdd19ef6ec57aee5d5bea413bed3452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0fdd19ef6ec57aee5d5bea413bed3452">stmt_uses_var</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a0fdd19ef6ec57aee5d5bea413bed3452"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#a0fdd19ef6ec57aee5d5bea413bed3452">More...</a><br /></td></tr>
<tr class="separator:a0fdd19ef6ec57aee5d5bea413bed3452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31bec6d9fdbb014d4e6b82549452065"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae31bec6d9fdbb014d4e6b82549452065"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae31bec6d9fdbb014d4e6b82549452065">expr_uses_vars</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:ae31bec6d9fdbb014d4e6b82549452065"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#ae31bec6d9fdbb014d4e6b82549452065">More...</a><br /></td></tr>
<tr class="separator:ae31bec6d9fdbb014d4e6b82549452065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d8bcd8e6cf2ad8368c7f106f5852f1e">stmt_uses_vars</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument.  <a href="namespace_halide_1_1_internal.html#a3d8bcd8e6cf2ad8368c7f106f5852f1e">More...</a><br /></td></tr>
<tr class="separator:a3d8bcd8e6cf2ad8368c7f106f5852f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">find_direct_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a16b42e90ad180f1254cdd3be0ae7be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents.  <a href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">More...</a><br /></td></tr>
<tr class="separator:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">find_transitive_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively.  <a href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">More...</a><br /></td></tr>
<tr class="separator:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896238d54e6f7d94171698d1c4296b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a896238d54e6f7d94171698d1c4296b97">populate_environment</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a896238d54e6f7d94171698d1c4296b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all Functions transitively referenced by f in any way and add them to the given map.  <a href="namespace_halide_1_1_internal.html#a896238d54e6f7d94171698d1c4296b97">More...</a><br /></td></tr>
<tr class="separator:a896238d54e6f7d94171698d1c4296b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f298be9b8105946543dd390b374ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a543f298be9b8105946543dd390b374ff">lower_widening_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a543f298be9b8105946543dd390b374ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement intrinsics with non-intrinsic using equivalents.  <a href="namespace_halide_1_1_internal.html#a543f298be9b8105946543dd390b374ff">More...</a><br /></td></tr>
<tr class="separator:a543f298be9b8105946543dd390b374ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ae1b99eee51f16210b3d97effc25bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab8ae1b99eee51f16210b3d97effc25bd">lower_widening_mul</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:ab8ae1b99eee51f16210b3d97effc25bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac43abd869f41381772e6bb7d2c6e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaac43abd869f41381772e6bb7d2c6e5d">lower_widening_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:aaac43abd869f41381772e6bb7d2c6e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49839698df68c878972d04abb2f0c2e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a49839698df68c878972d04abb2f0c2e5">lower_widening_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a49839698df68c878972d04abb2f0c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72390cac65d124349c7e74677aa87167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a72390cac65d124349c7e74677aa87167">lower_widening_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a72390cac65d124349c7e74677aa87167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e70aeecd9a6473b07d533436feee25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad1e70aeecd9a6473b07d533436feee25">lower_rounding_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:ad1e70aeecd9a6473b07d533436feee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c2f27463a8c2007fb94474a7d31e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c3c2f27463a8c2007fb94474a7d31e6">lower_rounding_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a8c3c2f27463a8c2007fb94474a7d31e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52903c4a764166671b47c1bee5972657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a52903c4a764166671b47c1bee5972657">lower_saturating_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a52903c4a764166671b47c1bee5972657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65673b59449764669bf6424de17481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc65673b59449764669bf6424de17481">lower_saturating_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:acc65673b59449764669bf6424de17481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb06df309ffae62a414ff80f298064c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3cb06df309ffae62a414ff80f298064c">lower_halving_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a3cb06df309ffae62a414ff80f298064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3fa4ef1d631a29d7440487960a6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3ab3fa4ef1d631a29d7440487960a6e1">lower_halving_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a3ab3fa4ef1d631a29d7440487960a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d347c813cf72a9fff938583a277f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a433d347c813cf72a9fff938583a277f0">lower_rounding_halving_add</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a433d347c813cf72a9fff938583a277f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb95301fa111daaa29ab989cd1ce974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7cb95301fa111daaa29ab989cd1ce974">lower_rounding_halving_sub</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a7cb95301fa111daaa29ab989cd1ce974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4767c0dccb944d87678d84e2eae8c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4767c0dccb944d87678d84e2eae8c7a">lower_intrinsic</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *op)</td></tr>
<tr class="memdesc:ab4767c0dccb944d87678d84e2eae8c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace one of the above ops with equivalent arithmetic.  <a href="namespace_halide_1_1_internal.html#ab4767c0dccb944d87678d84e2eae8c7a">More...</a><br /></td></tr>
<tr class="separator:ab4767c0dccb944d87678d84e2eae8c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09931c2014b2d9371646a16e8f70040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab09931c2014b2d9371646a16e8f70040">find_intrinsics</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:ab09931c2014b2d9371646a16e8f70040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace common arithmetic patterns with intrinsics.  <a href="namespace_halide_1_1_internal.html#ab09931c2014b2d9371646a16e8f70040">More...</a><br /></td></tr>
<tr class="separator:ab09931c2014b2d9371646a16e8f70040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac549d8172be01dcee56b59f1b78801ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac549d8172be01dcee56b59f1b78801ef">find_intrinsics</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:ac549d8172be01dcee56b59f1b78801ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771bb6d2ec214f749b0c1b294d5c5a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a771bb6d2ec214f749b0c1b294d5c5a90">lower_intrinsics</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a771bb6d2ec214f749b0c1b294d5c5a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse of find_intrinsics.  <a href="namespace_halide_1_1_internal.html#a771bb6d2ec214f749b0c1b294d5c5a90">More...</a><br /></td></tr>
<tr class="separator:a771bb6d2ec214f749b0c1b294d5c5a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a93dc6272bd86b8d10c171d0c1e26d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a24a93dc6272bd86b8d10c171d0c1e26d">lower_intrinsics</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a24a93dc6272bd86b8d10c171d0c1e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf714a588746f3f1017dc77dad68a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afdf714a588746f3f1017dc77dad68a67">flatten_nested_ramps</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:afdf714a588746f3f1017dc77dad68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement/expression and replace nested ramps and broadcasts.  <a href="namespace_halide_1_1_internal.html#afdf714a588746f3f1017dc77dad68a67">More...</a><br /></td></tr>
<tr class="separator:afdf714a588746f3f1017dc77dad68a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2729ffaedee0544f9b584f53bc91954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2729ffaedee0544f9b584f53bc91954b">flatten_nested_ramps</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="separator:a2729ffaedee0544f9b584f53bc91954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b98bf6f8f3475caaa691d7884a31d45">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abec0560d55ceb7384483f00da38ad73f">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:abec0560d55ceb7384483f00da38ad73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a32bce2836846aa0286859b005b6aa015">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, Last last)</td></tr>
<tr class="separator:a32bce2836846aa0286859b005b6aa015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdc822256984ddc07c031b230ce2b8ae">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, First first, Second second, Rest &amp;&amp;...rest)</td></tr>
<tr class="separator:acdc822256984ddc07c031b230ce2b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1f9bfb55aa0058e51d72037fde785fb0">schedule_scalar</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f)</td></tr>
<tr class="separator:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad946e0645ead551baee06d6c39e6552"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aad946e0645ead551baee06d6c39e6552">deep_copy</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aad946e0645ead551baee06d6c39e6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> DAG.  <a href="namespace_halide_1_1_internal.html#aad946e0645ead551baee06d6c39e6552">More...</a><br /></td></tr>
<tr class="separator:aad946e0645ead551baee06d6c39e6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4235fdb540be5dde3f9942604be666f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4235fdb540be5dde3f9942604be666f0">zero_gpu_loop_mins</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a4235fdb540be5dde3f9942604be666f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all GPU loops to have a min of zero.  <a href="namespace_halide_1_1_internal.html#a4235fdb540be5dde3f9942604be666f0">More...</a><br /></td></tr>
<tr class="separator:a4235fdb540be5dde3f9942604be666f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081752824625e87b5e95bfae979499f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0081752824625e87b5e95bfae979499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model.  <a href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">More...</a><br /></td></tr>
<tr class="separator:a0081752824625e87b5e95bfae979499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f235cf0feb61ceabb0ad10573d85f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f235cf0feb61ceabb0ad10573d85f84">fuzz_float_stores</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a5f235cf0feb61ceabb0ad10573d85f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">On every store of a floating point value, mask off the least-significant-bit of the mantissa.  <a href="namespace_halide_1_1_internal.html#a5f235cf0feb61ceabb0ad10573d85f84">More...</a><br /></td></tr>
<tr class="separator:a5f235cf0feb61ceabb0ad10573d85f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4be7daed1a8c6cd914be946f22ea4df">generator_test</a> ()</td></tr>
<tr class="separator:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2672948a0299d09a067ec4dbb862723"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa2672948a0299d09a067ec4dbb862723">parameter_constraints</a> (const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &amp;p)</td></tr>
<tr class="separator:aa2672948a0299d09a067ec4dbb862723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b54f450e1cd03c240743907e45487ce">enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:a9b54f450e1cd03c240743907e45487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afd2308d89d4a9b9eef0803e92c383b0c">enum_from_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const std::string &amp;s)</td></tr>
<tr class="separator:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb90b52661557ff81407bc45cbdf3e6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:aebb90b52661557ff81407bc45cbdf3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7c793b324e02e15a109f1e8af548c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2cc7c793b324e02e15a109f1e8af548c">halide_type_to_enum_string</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a2cc7c793b324e02e15a109f1e8af548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600136fc73541f81f75ee07095a62025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a600136fc73541f81f75ee07095a62025">halide_type_to_c_source</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a600136fc73541f81f75ee07095a62025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e8f71298de4ece7dc2e59ae811c3fd2">halide_type_to_c_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032a99a32ca261c475b4335ece416dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">generate_filter_main</a> (int argc, char **argv, std::ostream &amp;cerr)</td></tr>
<tr class="memdesc:ad032a99a32ca261c475b4335ece416dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a1288db81d996c1d930c57ec8031a6527">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">More...</a><br /></td></tr>
<tr class="separator:ad032a99a32ca261c475b4335ece416dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae47fa4b8f49636c214b214f5d0f4ed34">parse_scalar</a> (const std::string &amp;value)</td></tr>
<tr class="separator:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682395f90f7229826df771f8c286fac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7682395f90f7229826df771f8c286fac">parse_halide_type_list</a> (const std::string &amp;types)</td></tr>
<tr class="separator:a7682395f90f7229826df771f8c286fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696c48228f0cb335255ae46954909e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8696c48228f0cb335255ae46954909e1">inject_hexagon_rpc</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;host_target, <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module)</td></tr>
<tr class="memdesc:a8696c48228f0cb335255ae46954909e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module.  <a href="namespace_halide_1_1_internal.html#a8696c48228f0cb335255ae46954909e1">More...</a><br /></td></tr>
<tr class="separator:a8696c48228f0cb335255ae46954909e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a0c1dd9c3f33e07eb6df7b59850286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55a0c1dd9c3f33e07eb6df7b59850286">compile_module_to_hexagon_shared_object</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;device_code)</td></tr>
<tr class="separator:a55a0c1dd9c3f33e07eb6df7b59850286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9944b3d2cbfb0262a46b72ec515ab130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9944b3d2cbfb0262a46b72ec515ab130">optimize_hexagon_shuffles</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, int lut_alignment)</td></tr>
<tr class="memdesc:a9944b3d2cbfb0262a46b72ec515ab130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace indirect and other loads with simple loads + vlut calls.  <a href="namespace_halide_1_1_internal.html#a9944b3d2cbfb0262a46b72ec515ab130">More...</a><br /></td></tr>
<tr class="separator:a9944b3d2cbfb0262a46b72ec515ab130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e99863aa9fd2833e535440b632093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad61e99863aa9fd2833e535440b632093">scatter_gather_generator</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="separator:ad61e99863aa9fd2833e535440b632093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2278e803f98fc7b6e2b382ace8052975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2278e803f98fc7b6e2b382ace8052975">optimize_hexagon_instructions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a2278e803f98fc7b6e2b382ace8052975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations.  <a href="namespace_halide_1_1_internal.html#a2278e803f98fc7b6e2b382ace8052975">More...</a><br /></td></tr>
<tr class="separator:a2278e803f98fc7b6e2b382ace8052975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a62ca468e067e12843e66cfa0fb33d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33a62ca468e067e12843e66cfa0fb33d">native_deinterleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:a33a62ca468e067e12843e66cfa0fb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="namespace_halide_1_1_internal.html#a33a62ca468e067e12843e66cfa0fb33d">More...</a><br /></td></tr>
<tr class="separator:a33a62ca468e067e12843e66cfa0fb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cfab6d9f71632c8e4b712c7c400e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad90cfab6d9f71632c8e4b712c7c400e8">native_interleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:ad90cfab6d9f71632c8e4b712c7c400e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ab59246b78ff782aceed334637e4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaf5ab59246b78ff782aceed334637e4c">is_native_deinterleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:aaf5ab59246b78ff782aceed334637e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa264f8cbd16a2062c62a731ef88a261"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa264f8cbd16a2062c62a731ef88a261">is_native_interleave</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="separator:aaa264f8cbd16a2062c62a731ef88a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5b91e32017e38df05ae28f39a8b78c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada5b91e32017e38df05ae28f39a8b78c">type_suffix</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> type, bool signed_variants=true)</td></tr>
<tr class="separator:ada5b91e32017e38df05ae28f39a8b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edb350d77a097d5b1dce8ba2a9890cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6edb350d77a097d5b1dce8ba2a9890cf">type_suffix</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, bool signed_variants=true)</td></tr>
<tr class="separator:a6edb350d77a097d5b1dce8ba2a9890cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b52d96bb5a9b758cbaf557e35f4695"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6b52d96bb5a9b758cbaf557e35f4695">type_suffix</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, bool signed_variants=true)</td></tr>
<tr class="separator:af6b52d96bb5a9b758cbaf557e35f4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d49ddfaea99d3ddf07425940e67dd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93d49ddfaea99d3ddf07425940e67dd0">type_suffix</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;ops, bool signed_variants=true)</td></tr>
<tr class="separator:a93d49ddfaea99d3ddf07425940e67dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af522a6ad40733cb252fc7547a8af7dce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af522a6ad40733cb252fc7547a8af7dce">infer_arguments</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;body, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:af522a6ad40733cb252fc7547a8af7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f932b31fe791a7b2002b829c8e5364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a50f932b31fe791a7b2002b829c8e5364">call_extern_and_assert</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a50f932b31fe791a7b2002b829c8e5364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to call an extern function, and assert that it returns 0.  <a href="namespace_halide_1_1_internal.html#a50f932b31fe791a7b2002b829c8e5364">More...</a><br /></td></tr>
<tr class="separator:a50f932b31fe791a7b2002b829c8e5364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9fa15ced2f13142e6c4b5e5f4649aa15">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed.  <a href="namespace_halide_1_1_internal.html#a9fa15ced2f13142e6c4b5e5f4649aa15">More...</a><br /></td></tr>
<tr class="separator:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e110a8277167d2764e231d1dbebf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a983e110a8277167d2764e231d1dbebf5">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:a983e110a8277167d2764e231d1dbebf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="namespace_halide_1_1_internal.html#a983e110a8277167d2764e231d1dbebf5">More...</a><br /></td></tr>
<tr class="separator:a983e110a8277167d2764e231d1dbebf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114825936949569e0a72294236a775c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7114825936949569e0a72294236a775c">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a7114825936949569e0a72294236a775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720ad50bc88a71450138fcec77b3b73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a720ad50bc88a71450138fcec77b3b73c">inline_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> caller, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a720ad50bc88a71450138fcec77b3b73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6883343b90964967cb0bafb2551f5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab6883343b90964967cb0bafb2551f5c3">validate_schedule_inlined_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:ab6883343b90964967cb0bafb2551f5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the schedule of an inlined function is legal, throwing an error if it is not.  <a href="namespace_halide_1_1_internal.html#ab6883343b90964967cb0bafb2551f5c3">More...</a><br /></td></tr>
<tr class="separator:ab6883343b90964967cb0bafb2551f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc100b5bea312321ff79baff93ee558"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbc100b5bea312321ff79baff93ee558"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abbc100b5bea312321ff79baff93ee558">ref_count</a> (const T *t) noexcept</td></tr>
<tr class="memdesc:abbc100b5bea312321ff79baff93ee558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="namespace_halide_1_1_internal.html#abbc100b5bea312321ff79baff93ee558">More...</a><br /></td></tr>
<tr class="separator:abbc100b5bea312321ff79baff93ee558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a11ca920b642ef490aeac2b4e864d6254">destroy</a> (const T *t)</td></tr>
<tr class="separator:a11ca920b642ef490aeac2b4e864d6254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1074fbd76b40a9cc210fbd22fdcda914"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1074fbd76b40a9cc210fbd22fdcda914">equal</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a1074fbd76b40a9cc210fbd22fdcda914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="namespace_halide_1_1_internal.html#a1074fbd76b40a9cc210fbd22fdcda914">More...</a><br /></td></tr>
<tr class="separator:a1074fbd76b40a9cc210fbd22fdcda914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705ef4763a82b7907112099a01604d0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a705ef4763a82b7907112099a01604d0d">equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;b)</td></tr>
<tr class="separator:a705ef4763a82b7907112099a01604d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad2884f65d9bbb20c6cdcc65e08d47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3fad2884f65d9bbb20c6cdcc65e08d47">graph_equal</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="separator:a3fad2884f65d9bbb20c6cdcc65e08d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b5e9d7137c035d913570030d474bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31b5e9d7137c035d913570030d474bac">graph_equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;b)</td></tr>
<tr class="separator:a31b5e9d7137c035d913570030d474bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59065f04bcf4e664007d95affa7ce3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac59065f04bcf4e664007d95affa7ce3f">ir_equality_test</a> ()</td></tr>
<tr class="separator:ac59065f04bcf4e664007d95affa7ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10452d8940fd9d44b657a915b7cea42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad10452d8940fd9d44b657a915b7cea42">expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad10452d8940fd9d44b657a915b7cea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="namespace_halide_1_1_internal.html#ad10452d8940fd9d44b657a915b7cea42">More...</a><br /></td></tr>
<tr class="separator:ad10452d8940fd9d44b657a915b7cea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d77cbd158befc1b58416319609f313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad8d77cbd158befc1b58416319609f313">expr_match</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;pattern, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad8d77cbd158befc1b58416319609f313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <a href="namespace_halide_1_1_internal.html#ad8d77cbd158befc1b58416319609f313">More...</a><br /></td></tr>
<tr class="separator:ad8d77cbd158befc1b58416319609f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5923637d87db593d1e24b088bbe6fa5c"><td class="memTemplParams" colspan="2">template&lt;typename Mutator , typename... Args&gt; </td></tr>
<tr class="memitem:a5923637d87db593d1e24b088bbe6fa5c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5923637d87db593d1e24b088bbe6fa5c">mutate_region</a> (Mutator *mutator, const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;bounds, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5923637d87db593d1e24b088bbe6fa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for mutator-like things to mutate regions.  <a href="namespace_halide_1_1_internal.html#a5923637d87db593d1e24b088bbe6fa5c">More...</a><br /></td></tr>
<tr class="separator:a5923637d87db593d1e24b088bbe6fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d0eaaf5222de9d1151bf81479beb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af11d0eaaf5222de9d1151bf81479beb9">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af11d0eaaf5222de9d1151bf81479beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants.">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#af11d0eaaf5222de9d1151bf81479beb9">More...</a><br /></td></tr>
<tr class="separator:af11d0eaaf5222de9d1151bf81479beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0438766d0040aa39c5f420f1a92b01b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad0438766d0040aa39c5f420f1a92b01b">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:ad0438766d0040aa39c5f420f1a92b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#ad0438766d0040aa39c5f420f1a92b01b">More...</a><br /></td></tr>
<tr class="separator:ad0438766d0040aa39c5f420f1a92b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f803a9899cc2d96a93179dba4bf21f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a98f803a9899cc2d96a93179dba4bf21f">as_const_int</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a98f803a9899cc2d96a93179dba4bf21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a98f803a9899cc2d96a93179dba4bf21f">More...</a><br /></td></tr>
<tr class="separator:a98f803a9899cc2d96a93179dba4bf21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c472a5cc4013b179510625b02bf6d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae2c472a5cc4013b179510625b02bf6d6">as_const_uint</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:ae2c472a5cc4013b179510625b02bf6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#ae2c472a5cc4013b179510625b02bf6d6">More...</a><br /></td></tr>
<tr class="separator:ae2c472a5cc4013b179510625b02bf6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6252d95fc57aad0465caf882eded56bb"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6252d95fc57aad0465caf882eded56bb">as_const_float</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a6252d95fc57aad0465caf882eded56bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a6252d95fc57aad0465caf882eded56bb">More...</a><br /></td></tr>
<tr class="separator:a6252d95fc57aad0465caf882eded56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f2b30c213250c3ba20c4d211f5b00f">is_const_power_of_two_integer</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, int *bits)</td></tr>
<tr class="memdesc:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="namespace_halide_1_1_internal.html#aa5f2b30c213250c3ba20c4d211f5b00f">More...</a><br /></td></tr>
<tr class="separator:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26b6233cff17bdbf097bfe981e096c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f26b6233cff17bdbf097bfe981e096c">is_positive_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a5f26b6233cff17bdbf097bfe981e096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a5f26b6233cff17bdbf097bfe981e096c">More...</a><br /></td></tr>
<tr class="separator:a5f26b6233cff17bdbf097bfe981e096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e57c1aaa1719ed42fac6dc6661ebe90">is_negative_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a0e57c1aaa1719ed42fac6dc6661ebe90">More...</a><br /></td></tr>
<tr class="separator:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb4bb1c7164222794e270f58c428eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0eb4bb1c7164222794e270f58c428eb7">is_undef</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0eb4bb1c7164222794e270f58c428eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="namespace_halide_1_1_internal.html#a0eb4bb1c7164222794e270f58c428eb7">More...</a><br /></td></tr>
<tr class="separator:a0eb4bb1c7164222794e270f58c428eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0490ee622445eeba11163a7a936177d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0490ee622445eeba11163a7a936177d7">is_const_zero</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0490ee622445eeba11163a7a936177d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a0490ee622445eeba11163a7a936177d7">More...</a><br /></td></tr>
<tr class="separator:a0490ee622445eeba11163a7a936177d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534f733e8b7b7c617fd03714ccca697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3534f733e8b7b7c617fd03714ccca697">is_const_one</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a3534f733e8b7b7c617fd03714ccca697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a3534f733e8b7b7c617fd03714ccca697">More...</a><br /></td></tr>
<tr class="separator:a3534f733e8b7b7c617fd03714ccca697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a916dccb9f4ad5763ce86721ab3187cfc">is_no_op</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a916dccb9f4ad5763ce86721ab3187cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> node of a constant)  <a href="namespace_halide_1_1_internal.html#a916dccb9f4ad5763ce86721ab3187cfc">More...</a><br /></td></tr>
<tr class="separator:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325254f314a3811cc5ebebf4497466d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">is_pure</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a8325254f314a3811cc5ebebf4497466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, and 2) Evaluating it has no side-effects.  <a href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">More...</a><br /></td></tr>
<tr class="separator:a8325254f314a3811cc5ebebf4497466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a5a057ef6ceb8462dbca18eb9020bc297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">More...</a><br /></td></tr>
<tr class="separator:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69927d11c0fe7c6cf4092a811f6676d7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="separator:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3a72bc2d5b95e6a43e803a9f7c4acea">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, double val)</td></tr>
<tr class="separator:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, bool val)</td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, float val)</td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1float16__t.html">float16_t</a> val)</td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee83b2e74ffd9ee144d046aebbf87cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aee83b2e74ffd9ee144d046aebbf87cca">make_signed_integer_overflow</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> type)</td></tr>
<tr class="memdesc:aee83b2e74ffd9ee144d046aebbf87cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unique signed_integer_overflow <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>.  <a href="namespace_halide_1_1_internal.html#aee83b2e74ffd9ee144d046aebbf87cca">More...</a><br /></td></tr>
<tr class="separator:aee83b2e74ffd9ee144d046aebbf87cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de10096d923cdc0f02582981b718854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">check_representable</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a2de10096d923cdc0f02582981b718854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">More...</a><br /></td></tr>
<tr class="separator:a2de10096d923cdc0f02582981b718854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2aa7992959c35ebe5895999b762b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:ace2aa7992959c35ebe5895999b762b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">More...</a><br /></td></tr>
<tr class="separator:ace2aa7992959c35ebe5895999b762b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">More...</a><br /></td></tr>
<tr class="separator:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e5ab6b1524fd81132823c77c35d717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a01e5ab6b1524fd81132823c77c35d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">More...</a><br /></td></tr>
<tr class="separator:a01e5ab6b1524fd81132823c77c35d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a14bdd8230cefd6bf9f84ac909311d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">More...</a><br /></td></tr>
<tr class="separator:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb413640f7f46493733fa33d95ea9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a5fb413640f7f46493733fa33d95ea9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">More...</a><br /></td></tr>
<tr class="separator:a5fb413640f7f46493733fa33d95ea9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ab94c84e726218144cf4c5d3a08b38f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">More...</a><br /></td></tr>
<tr class="separator:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">lossless_cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ae1e5b44f4f584318f9065bcf39c75c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">More...</a><br /></td></tr>
<tr class="separator:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626e40f7f540859a774c59d38a673bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa626e40f7f540859a774c59d38a673bd">lossless_negate</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x)</td></tr>
<tr class="memdesc:aa626e40f7f540859a774c59d38a673bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to negate x without introducing new IR and without overflow.  <a href="namespace_halide_1_1_internal.html#aa626e40f7f540859a774c59d38a673bd">More...</a><br /></td></tr>
<tr class="separator:aa626e40f7f540859a774c59d38a673bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365bfad96972abe9e008bb1b601223f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a365bfad96972abe9e008bb1b601223f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">More...</a><br /></td></tr>
<tr class="separator:a365bfad96972abe9e008bb1b601223f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdcef00b83af48e34920fd58d1da84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addfdcef00b83af48e34920fd58d1da84">match_types_bitwise</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b, const char *op_name)</td></tr>
<tr class="memdesc:addfdcef00b83af48e34920fd58d1da84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that both expressions are integer types and are either both signed or both unsigned.  <a href="namespace_halide_1_1_internal.html#addfdcef00b83af48e34920fd58d1da84">More...</a><br /></td></tr>
<tr class="separator:addfdcef00b83af48e34920fd58d1da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81818fbb02804a8e8f9056a0a24e0f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a81818fbb02804a8e8f9056a0a24e0f56">halide_log</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="memdesc:a81818fbb02804a8e8f9056a0a24e0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s vectorizable transcendentals.  <a href="namespace_halide_1_1_internal.html#a81818fbb02804a8e8f9056a0a24e0f56">More...</a><br /></td></tr>
<tr class="separator:a81818fbb02804a8e8f9056a0a24e0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f176922ae87268701a0234b48ead883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f176922ae87268701a0234b48ead883">halide_exp</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:a4f176922ae87268701a0234b48ead883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30907ab1fd2dfde808351ed05d262548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a30907ab1fd2dfde808351ed05d262548">halide_erf</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:a30907ab1fd2dfde808351ed05d262548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec662f503947166115071493eaa00780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aec662f503947166115071493eaa00780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">More...</a><br /></td></tr>
<tr class="separator:aec662f503947166115071493eaa00780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839473cf858ba53326b678db072411d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">split_into_ands</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a839473cf858ba53326b678db072411d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">More...</a><br /></td></tr>
<tr class="separator:a839473cf858ba53326b678db072411d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa6f512f02bfc12c8a4d1d87ab77bc0b6">strided_ramp_base</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, int stride=1)</td></tr>
<tr class="memdesc:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If e is a ramp expression with stride, default 1, return the base, otherwise undefined.  <a href="namespace_halide_1_1_internal.html#aa6f512f02bfc12c8a4d1d87ab77bc0b6">More...</a><br /></td></tr>
<tr class="separator:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  <a href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">More...</a><br /></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa13a82f37fe6336c154122f66d294523">div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3965c871f086a60fda2cc31e678d050a">div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df709582bdb9d7844efa9cd6b69625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7df709582bdb9d7844efa9cd6b69625">remove_likelies</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af7df709582bdb9d7844efa9cd6b69625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <a href="namespace_halide_1_1_internal.html#af7df709582bdb9d7844efa9cd6b69625">More...</a><br /></td></tr>
<tr class="separator:af7df709582bdb9d7844efa9cd6b69625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">remove_likelies</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <a href="namespace_halide_1_1_internal.html#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">More...</a><br /></td></tr>
<tr class="separator:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acf7ed2ca593eca53111eaf753a7fc9bf">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d7c2f51029190ae224290688b7c4c3b">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:a4d7c2f51029190ae224290688b7c4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adda140fdf727dfa11f6f3151fc4f7661">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:adda140fdf727dfa11f6f3151fc4f7661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da582526c949b1bd11ede8f20bce2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12da582526c949b1bd11ede8f20bce2e">requirement_failed_error</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a12da582526c949b1bd11ede8f20bce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082d3bda0d60128ae127d0879e7e38c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a082d3bda0d60128ae127d0879e7e38c9">memoize_tag_helper</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:a082d3bda0d60128ae127d0879e7e38c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75f4cdf56ac6f31a5f0870b66e3743e9">widening_add</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) + widen(b).  <a href="namespace_halide_1_1_internal.html#a75f4cdf56ac6f31a5f0870b66e3743e9">More...</a><br /></td></tr>
<tr class="separator:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa64fcd8d11f7e4bdf153ff760c73c46b">widening_mul</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) * widen(b).  <a href="namespace_halide_1_1_internal.html#aa64fcd8d11f7e4bdf153ff760c73c46b">More...</a><br /></td></tr>
<tr class="separator:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f14f11164b1390669a9ce151b57a3af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f14f11164b1390669a9ce151b57a3af">widening_sub</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a6f14f11164b1390669a9ce151b57a3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) - widen(b).  <a href="namespace_halide_1_1_internal.html#a6f14f11164b1390669a9ce151b57a3af">More...</a><br /></td></tr>
<tr class="separator:a6f14f11164b1390669a9ce151b57a3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4eb6ea1b5e17d86b611b69e97f9bbd18">widening_shift_left</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) &lt;&lt; b.  <a href="namespace_halide_1_1_internal.html#a4eb6ea1b5e17d86b611b69e97f9bbd18">More...</a><br /></td></tr>
<tr class="separator:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d54b8b13cf47de21ea8005decd03a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d54b8b13cf47de21ea8005decd03a14">widening_shift_right</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3d54b8b13cf47de21ea8005decd03a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) &gt;&gt; b.  <a href="namespace_halide_1_1_internal.html#a3d54b8b13cf47de21ea8005decd03a14">More...</a><br /></td></tr>
<tr class="separator:a3d54b8b13cf47de21ea8005decd03a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd47ddc60a5b16ebf7e68ae1ba2ba483">rounding_shift_left</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_add(a, (1 &gt;&gt; min(b, 0)) / 2) &lt;&lt; b.  <a href="namespace_halide_1_1_internal.html#abd47ddc60a5b16ebf7e68ae1ba2ba483">More...</a><br /></td></tr>
<tr class="separator:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d761851379580a9605f799491f933f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d761851379580a9605f799491f933f7">rounding_shift_right</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3d761851379580a9605f799491f933f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_add(a, (1 &lt;&lt; max(b, 0)) / 2) &gt;&gt; b.  <a href="namespace_halide_1_1_internal.html#a3d761851379580a9605f799491f933f7">More...</a><br /></td></tr>
<tr class="separator:a3d761851379580a9605f799491f933f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b125d7fefcbcf2962d41efd87248be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad6b125d7fefcbcf2962d41efd87248be">saturating_add</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ad6b125d7fefcbcf2962d41efd87248be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_narrow(widen(a) + widen(b))  <a href="namespace_halide_1_1_internal.html#ad6b125d7fefcbcf2962d41efd87248be">More...</a><br /></td></tr>
<tr class="separator:ad6b125d7fefcbcf2962d41efd87248be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ad280ea975ec61eeb27cb27c4f4024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55ad280ea975ec61eeb27cb27c4f4024">saturating_sub</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a55ad280ea975ec61eeb27cb27c4f4024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_narrow(widen(a) - widen(b))  <a href="namespace_halide_1_1_internal.html#a55ad280ea975ec61eeb27cb27c4f4024">More...</a><br /></td></tr>
<tr class="separator:a55ad280ea975ec61eeb27cb27c4f4024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31db44d292fd0875a78d40831feb81c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae31db44d292fd0875a78d40831feb81c">halving_add</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ae31db44d292fd0875a78d40831feb81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) + widen(b)) / 2)  <a href="namespace_halide_1_1_internal.html#ae31db44d292fd0875a78d40831feb81c">More...</a><br /></td></tr>
<tr class="separator:ae31db44d292fd0875a78d40831feb81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a17b5151e7b54f3743f35b0d1fe2a1112">rounding_halving_add</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) + widen(b) + 1) / 2)  <a href="namespace_halide_1_1_internal.html#a17b5151e7b54f3743f35b0d1fe2a1112">More...</a><br /></td></tr>
<tr class="separator:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3e3170f0ecff7b28a97b8f959879ddf5">halving_sub</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) - widen(b)) / 2)  <a href="namespace_halide_1_1_internal.html#a3e3170f0ecff7b28a97b8f959879ddf5">More...</a><br /></td></tr>
<tr class="separator:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992108a27232a3ccdf771112a4a296a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a992108a27232a3ccdf771112a4a296a0">rounding_halving_sub</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a992108a27232a3ccdf771112a4a296a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) - widen(b) + 1) / 2)  <a href="namespace_halide_1_1_internal.html#a992108a27232a3ccdf771112a4a296a0">More...</a><br /></td></tr>
<tr class="separator:a992108a27232a3ccdf771112a4a296a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90683a918dfa5840b97406468fef7501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90683a918dfa5840b97406468fef7501">promise_clamped</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;value, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>)</td></tr>
<tr class="memdesc:a90683a918dfa5840b97406468fef7501"><td class="mdescLeft">&#160;</td><td class="mdescRight">FOR INTERNAL USE ONLY.  <a href="namespace_halide_1_1_internal.html#a90683a918dfa5840b97406468fef7501">More...</a><br /></td></tr>
<tr class="separator:a90683a918dfa5840b97406468fef7501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe20393021d437778c0587afbc448d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83fe20393021d437778c0587afbc448d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;)</td></tr>
<tr class="memdesc:a83fe20393021d437778c0587afbc448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form.  <a href="namespace_halide_1_1_internal.html#a83fe20393021d437778c0587afbc448d">More...</a><br /></td></tr>
<tr class="separator:a83fe20393021d437778c0587afbc448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b530e690cbe977d889e0931f8933d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4e3b530e690cbe977d889e0931f8933d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;)</td></tr>
<tr class="memdesc:a4e3b530e690cbe977d889e0931f8933d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative op on an output stream (such as std::cout) in a human-readable form.  <a href="namespace_halide_1_1_internal.html#a4e3b530e690cbe977d889e0931f8933d">More...</a><br /></td></tr>
<tr class="separator:a4e3b530e690cbe977d889e0931f8933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a10cfea8acb4f311a9365e26a8f7de08f">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;)</td></tr>
<tr class="memdesc:a10cfea8acb4f311a9365e26a8f7de08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="namespace_halide_1_1_internal.html#a10cfea8acb4f311a9365e26a8f7de08f">More...</a><br /></td></tr>
<tr class="separator:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ff27763f50a990f499b422efc0c98b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0ff27763f50a990f499b422efc0c98b">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27">VectorReduce::Operator</a> &amp;)</td></tr>
<tr class="memdesc:aa0ff27763f50a990f499b422efc0c98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a horizontal vector reduction op in human-readable form.  <a href="namespace_halide_1_1_internal.html#aa0ff27763f50a990f499b422efc0c98b">More...</a><br /></td></tr>
<tr class="separator:aa0ff27763f50a990f499b422efc0c98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1f893faca900eef051b7c0c182fde5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e1f893faca900eef051b7c0c182fde5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;)</td></tr>
<tr class="memdesc:a6e1f893faca900eef051b7c0c182fde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide name mangling value in a human readable format.  <a href="namespace_halide_1_1_internal.html#a6e1f893faca900eef051b7c0c182fde5">More...</a><br /></td></tr>
<tr class="separator:a6e1f893faca900eef051b7c0c182fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f77f82c9290637ca0b5497f73a8f555"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f77f82c9290637ca0b5497f73a8f555">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;)</td></tr>
<tr class="memdesc:a6f77f82c9290637ca0b5497f73a8f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide linkage value in a human readable format.  <a href="namespace_halide_1_1_internal.html#a6f77f82c9290637ca0b5497f73a8f555">More...</a><br /></td></tr>
<tr class="separator:a6f77f82c9290637ca0b5497f73a8f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479bae94ae224d9d9180902627032a1b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a479bae94ae224d9d9180902627032a1b">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> &amp;)</td></tr>
<tr class="memdesc:a479bae94ae224d9d9180902627032a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide dimension type in human-readable format.  <a href="namespace_halide_1_1_internal.html#a479bae94ae224d9d9180902627032a1b">More...</a><br /></td></tr>
<tr class="separator:a479bae94ae224d9d9180902627032a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5168ee834a75949ecfb1f42d9cf54237"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5168ee834a75949ecfb1f42d9cf54237">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a> &amp;)</td></tr>
<tr class="separator:a5168ee834a75949ecfb1f42d9cf54237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ff2ba5a5794278afa0730aba7ff46e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a24ff2ba5a5794278afa0730aba7ff46e">get_symbol_address</a> (const char *s)</td></tr>
<tr class="separator:a24ff2ba5a5794278afa0730aba7ff46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ff6486a4d026c4a3a2813620d33328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac3ff6486a4d026c4a3a2813620d33328">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;weight)</td></tr>
<tr class="memdesc:ac3ff6486a4d026c4a3a2813620d33328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR that computes a lerp.  <a href="namespace_halide_1_1_internal.html#ac3ff6486a4d026c4a3a2813620d33328">More...</a><br /></td></tr>
<tr class="separator:ac3ff6486a4d026c4a3a2813620d33328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4933314cbff0bf637e348d5efc0a1499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4933314cbff0bf637e348d5efc0a1499">hoist_loop_invariant_values</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a4933314cbff0bf637e348d5efc0a1499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariants out of inner loops.  <a href="namespace_halide_1_1_internal.html#a4933314cbff0bf637e348d5efc0a1499">More...</a><br /></td></tr>
<tr class="separator:a4933314cbff0bf637e348d5efc0a1499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de2b04122d0ac7aba914d93c97b2589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3de2b04122d0ac7aba914d93c97b2589">hoist_loop_invariant_if_statements</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a3de2b04122d0ac7aba914d93c97b2589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just hoist loop-invariant if statements as far up as possible.  <a href="namespace_halide_1_1_internal.html#a3de2b04122d0ac7aba914d93c97b2589">More...</a><br /></td></tr>
<tr class="separator:a3de2b04122d0ac7aba914d93c97b2589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e9d2c57ff18ef709b6a4e444f4af5ff">iterator_to_pointer</a> (T iter) -&gt; decltype(&amp;*std::declval&lt; T &gt;())</td></tr>
<tr class="separator:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880810f84064e696c65e574223e8170a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a880810f84064e696c65e574223e8170a">get_llvm_function_name</a> (const llvm::Function *f)</td></tr>
<tr class="separator:a880810f84064e696c65e574223e8170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e2fec06de5b48f541b7a7b18d7bfb1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae2e2fec06de5b48f541b7a7b18d7bfb1">get_llvm_function_name</a> (const llvm::Function &amp;f)</td></tr>
<tr class="separator:ae2e2fec06de5b48f541b7a7b18d7bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26aedcbbf9449fa19edd76ad289ff26"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab26aedcbbf9449fa19edd76ad289ff26">get_llvm_struct_type_by_name</a> (llvm::Module *module, const char *name)</td></tr>
<tr class="separator:ab26aedcbbf9449fa19edd76ad289ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496ad11988df981c987a2557c3cd2d8c"><td class="memItemLeft" align="right" valign="top">llvm::Triple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a496ad11988df981c987a2557c3cd2d8c">get_triple_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a496ad11988df981c987a2557c3cd2d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>.  <a href="namespace_halide_1_1_internal.html#a496ad11988df981c987a2557c3cd2d8c">More...</a><br /></td></tr>
<tr class="separator:a496ad11988df981c987a2557c3cd2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2ac324e660b73262abdb4b0643451"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a30b2ac324e660b73262abdb4b0643451">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *, bool for_shared_jit_runtime=false, bool just_gpu=false)</td></tr>
<tr class="memdesc:a30b2ac324e660b73262abdb4b0643451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="namespace_halide_1_1_internal.html#a30b2ac324e660b73262abdb4b0643451">More...</a><br /></td></tr>
<tr class="separator:a30b2ac324e660b73262abdb4b0643451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e77b70f4bfb715115d8c3a690b2faa0">get_initial_module_for_ptx_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="namespace_halide_1_1_internal.html#a9e77b70f4bfb715115d8c3a690b2faa0">More...</a><br /></td></tr>
<tr class="separator:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2253813b438bcb811778d84b98e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af5c2253813b438bcb811778d84b98e94">add_bitcode_to_module</a> (llvm::LLVMContext *context, llvm::Module &amp;module, const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;bitcode, const std::string &amp;name)</td></tr>
<tr class="memdesc:af5c2253813b438bcb811778d84b98e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a block of llvm bitcode into an llvm module.  <a href="namespace_halide_1_1_internal.html#af5c2253813b438bcb811778d84b98e94">More...</a><br /></td></tr>
<tr class="separator:af5c2253813b438bcb811778d84b98e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb7795a6245d98b4acbda63678d436e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adcb7795a6245d98b4acbda63678d436e">link_with_wasm_jit_runtime</a> (llvm::LLVMContext *c, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, std::unique_ptr&lt; llvm::Module &gt; extra_module)</td></tr>
<tr class="memdesc:adcb7795a6245d98b4acbda63678d436e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the llvm::Module(s) in extra_modules (if any), add the runtime modules needed for the WASM JIT, and link into a single llvm::Module.  <a href="namespace_halide_1_1_internal.html#adcb7795a6245d98b4acbda63678d436e">More...</a><br /></td></tr>
<tr class="separator:adcb7795a6245d98b4acbda63678d436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1fc91c3863b2f3b6afe3902a717ff68b">loop_carry</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, int max_carried_values=8)</td></tr>
<tr class="memdesc:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load.  <a href="namespace_halide_1_1_internal.html#a1fc91c3863b2f3b6afe3902a717ff68b">More...</a><br /></td></tr>
<tr class="separator:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3120dac0bea3e48403dd0d63420e929c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3120dac0bea3e48403dd0d63420e929c">lower</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> linkage_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements=std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt;(), bool trace_pipeline=false, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:a3120dac0bea3e48403dd0d63420e929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> that evaluates it.  <a href="namespace_halide_1_1_internal.html#a3120dac0bea3e48403dd0d63420e929c">More...</a><br /></td></tr>
<tr class="separator:a3120dac0bea3e48403dd0d63420e929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6912ab26d3b04864d43af52502ebeb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa6912ab26d3b04864d43af52502ebeb7">lower_main_stmt</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;requirements=std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt;(), bool trace_pipeline=false, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:aa6912ab26d3b04864d43af52502ebeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="namespace_halide_1_1_internal.html#aa6912ab26d3b04864d43af52502ebeb7">More...</a><br /></td></tr>
<tr class="separator:aa6912ab26d3b04864d43af52502ebeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfe43201bab68cf4820993fe1469b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr class="separator:a4d3bfe43201bab68cf4820993fe1469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa573630ec30c63bc99cd46a4217cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7fa573630ec30c63bc99cd46a4217cbb">lower_warp_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a7fa573630ec30c63bc99cd46a4217cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions.  <a href="namespace_halide_1_1_internal.html#a7fa573630ec30c63bc99cd46a4217cbb">More...</a><br /></td></tr>
<tr class="separator:a7fa573630ec30c63bc99cd46a4217cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a57c1db8b5f97b8003a5271907bfdda"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a57c1db8b5f97b8003a5271907bfdda">define_matlab_wrapper</a> (llvm::Module *module, llvm::Function *pipeline_argv_wrapper, llvm::Function *metadata_getter)</td></tr>
<tr class="memdesc:a6a57c1db8b5f97b8003a5271907bfdda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name.  <a href="namespace_halide_1_1_internal.html#a6a57c1db8b5f97b8003a5271907bfdda">More...</a><br /></td></tr>
<tr class="separator:a6a57c1db8b5f97b8003a5271907bfdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66d64dd9cb646535816aff25b0d38ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac66d64dd9cb646535816aff25b0d38ad">inject_memoization</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:ac66d64dd9cb646535816aff25b0d38ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache.  <a href="namespace_halide_1_1_internal.html#ac66d64dd9cb646535816aff25b0d38ad">More...</a><br /></td></tr>
<tr class="separator:ac66d64dd9cb646535816aff25b0d38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af597feabae6ec97802ee2f800667a0f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af597feabae6ec97802ee2f800667a0f7">rewrite_memoized_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af597feabae6ec97802ee2f800667a0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called after Storage Flattening has added Allocation IR nodes.  <a href="namespace_halide_1_1_internal.html#af597feabae6ec97802ee2f800667a0f7">More...</a><br /></td></tr>
<tr class="separator:af597feabae6ec97802ee2f800667a0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484b5563138a3637d88adc3942494a99"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a484b5563138a3637d88adc3942494a99">get_output_info</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a484b5563138a3637d88adc3942494a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287e047c221ec0bd503eca610e59cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4287e047c221ec0bd503eca610e59cd1">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a4287e047c221ec0bd503eca610e59cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ed3e58311ee5699c067d4a6c53c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ade4ed3e58311ee5699c067d4a6c53c2d">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:ade4ed3e58311ee5699c067d4a6c53c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc51636317f397ae70e341f81805f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4fc51636317f397ae70e341f81805f8e">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a4fc51636317f397ae70e341f81805f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d56ea77b1fc65e72abc6025d15e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae26d56ea77b1fc65e72abc6025d15e2e">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:ae26d56ea77b1fc65e72abc6025d15e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc141be36f0586ef2dd5080befce47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a42bc141be36f0586ef2dd5080befce47">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;b)</td></tr>
<tr class="separator:a42bc141be36f0586ef2dd5080befce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad920f0d7b02a7331b8211d84e3f10208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad920f0d7b02a7331b8211d84e3f10208">operator+</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:ad920f0d7b02a7331b8211d84e3f10208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f39c3da5f8430464ac63973af1737ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9f39c3da5f8430464ac63973af1737ae">operator-</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9f39c3da5f8430464ac63973af1737ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e40311152e94d1bf520fa0a8eadafa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e40311152e94d1bf520fa0a8eadafa9">operator*</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a7e40311152e94d1bf520fa0a8eadafa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad30409f49c922a7b536de49b50abfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5ad30409f49c922a7b536de49b50abfa">operator/</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a5ad30409f49c922a7b536de49b50abfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5bf538dd23287f4a506afbe601b4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe5bf538dd23287f4a506afbe601b4a2">operator%</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:abe5bf538dd23287f4a506afbe601b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0244f4d3e877af92bb3326b5ba74d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1b0244f4d3e877af92bb3326b5ba74d2">modulus_remainder</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a1b0244f4d3e877af92bb3326b5ba74d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="namespace_halide_1_1_internal.html#a1b0244f4d3e877af92bb3326b5ba74d2">More...</a><br /></td></tr>
<tr class="separator:a1b0244f4d3e877af92bb3326b5ba74d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9e014546d86033dd6c81f699891267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aef9e014546d86033dd6c81f699891267">modulus_remainder</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:aef9e014546d86033dd6c81f699891267"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="namespace_halide_1_1_internal.html#aef9e014546d86033dd6c81f699891267">More...</a><br /></td></tr>
<tr class="separator:aef9e014546d86033dd6c81f699891267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789149daec96e933f8758f71f8474dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr class="separator:a789149daec96e933f8758f71f8474dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383c51a3621854507bf149283901fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3383c51a3621854507bf149283901fd8">gcd</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:a3383c51a3621854507bf149283901fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="namespace_halide_1_1_internal.html#a3383c51a3621854507bf149283901fd8">More...</a><br /></td></tr>
<tr class="separator:a3383c51a3621854507bf149283901fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d5d650979fec41ce02d02ac0b7c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea6d5d650979fec41ce02d02ac0b7c20">lcm</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:aea6d5d650979fec41ce02d02ac0b7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <a href="namespace_halide_1_1_internal.html#aea6d5d650979fec41ce02d02ac0b7c20">More...</a><br /></td></tr>
<tr class="separator:aea6d5d650979fec41ce02d02ac0b7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a191d0d4abe4a4d1019cad5cff62ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae2a191d0d4abe4a4d1019cad5cff62ca">is_monotonic</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;var, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &gt;::empty_scope())</td></tr>
<tr class="separator:ae2a191d0d4abe4a4d1019cad5cff62ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283407774a5c9a29ab30e9223dcb3580"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a283407774a5c9a29ab30e9223dcb3580">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &amp;m)</td></tr>
<tr class="memdesc:a283407774a5c9a29ab30e9223dcb3580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the monotonic class in human-readable form for debugging.  <a href="namespace_halide_1_1_internal.html#a283407774a5c9a29ab30e9223dcb3580">More...</a><br /></td></tr>
<tr class="separator:a283407774a5c9a29ab30e9223dcb3580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de4b237eafb498206aa2eb0c94b4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6de4b237eafb498206aa2eb0c94b4ad">is_monotonic_test</a> ()</td></tr>
<tr class="separator:af6de4b237eafb498206aa2eb0c94b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a87590be371b78913eaab20e563f335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a87590be371b78913eaab20e563f335">can_parallelize_rvar</a> (const std::string &amp;rvar, const std::string &amp;func, const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;r)</td></tr>
<tr class="memdesc:a9a87590be371b78913eaab20e563f335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable.  <a href="namespace_halide_1_1_internal.html#a9a87590be371b78913eaab20e563f335">More...</a><br /></td></tr>
<tr class="separator:a9a87590be371b78913eaab20e563f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce66817377fbb1918bbe7510ab47b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr class="memdesc:a0ce66817377fbb1918bbe7510ab47b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <a href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">More...</a><br /></td></tr>
<tr class="separator:a0ce66817377fbb1918bbe7510ab47b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4498b50bbce3ab2d9915233d648be38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa4498b50bbce3ab2d9915233d648be38">has_uncaptured_likely_tag</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:aa4498b50bbce3ab2d9915233d648be38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression uses a likely tag that isn't captured by an enclosing <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html" title="The lesser of two values.">Min</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a>.  <a href="namespace_halide_1_1_internal.html#aa4498b50bbce3ab2d9915233d648be38">More...</a><br /></td></tr>
<tr class="separator:aa4498b50bbce3ab2d9915233d648be38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd7d8d9eafda07ee9a314c3c869f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40fd7d8d9eafda07ee9a314c3c869f2d">has_likely_tag</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a40fd7d8d9eafda07ee9a314c3c869f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression uses a likely tag.  <a href="namespace_halide_1_1_internal.html#a40fd7d8d9eafda07ee9a314c3c869f2d">More...</a><br /></td></tr>
<tr class="separator:a40fd7d8d9eafda07ee9a314c3c869f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00fe3db9030d30827191d78c36fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d00fe3db9030d30827191d78c36fda5">partition_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a3d00fe3db9030d30827191d78c36fda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions loop bodies into a prologue, a steady state, and an epilogue.  <a href="namespace_halide_1_1_internal.html#a3d00fe3db9030d30827191d78c36fda5">More...</a><br /></td></tr>
<tr class="separator:a3d00fe3db9030d30827191d78c36fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e0c79704de005e7e9ca2283da97c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d9e0c79704de005e7e9ca2283da97c6">inject_placeholder_prefetch</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;prefetches)</td></tr>
<tr class="memdesc:a9d9e0c79704de005e7e9ca2283da97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject placeholder prefetches to 's'.  <a href="namespace_halide_1_1_internal.html#a9d9e0c79704de005e7e9ca2283da97c6">More...</a><br /></td></tr>
<tr class="separator:a9d9e0c79704de005e7e9ca2283da97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1427ae551e1c2cce79b7042c3fa4620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab1427ae551e1c2cce79b7042c3fa4620">inject_prefetch</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ab1427ae551e1c2cce79b7042c3fa4620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the actual region to be prefetched and place it to the placholder prefetch.  <a href="namespace_halide_1_1_internal.html#ab1427ae551e1c2cce79b7042c3fa4620">More...</a><br /></td></tr>
<tr class="separator:ab1427ae551e1c2cce79b7042c3fa4620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cbede92a4cd09354b032a40829a9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a23cbede92a4cd09354b032a40829a9d1">reduce_prefetch_dimension</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a23cbede92a4cd09354b032a40829a9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture).  <a href="namespace_halide_1_1_internal.html#a23cbede92a4cd09354b032a40829a9d1">More...</a><br /></td></tr>
<tr class="separator:a23cbede92a4cd09354b032a40829a9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ddfd891459204fae6afbcbdb6bac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa35ddfd891459204fae6afbcbdb6bac6">print_loop_nest</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs)</td></tr>
<tr class="memdesc:aa35ddfd891459204fae6afbcbdb6bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses.  <a href="namespace_halide_1_1_internal.html#aa35ddfd891459204fae6afbcbdb6bac6">More...</a><br /></td></tr>
<tr class="separator:aa35ddfd891459204fae6afbcbdb6bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bc0501d181c62936f9c544a206a18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab6bc0501d181c62936f9c544a206a18c">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::string &amp;)</td></tr>
<tr class="memdesc:ab6bc0501d181c62936f9c544a206a18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end.  <a href="namespace_halide_1_1_internal.html#ab6bc0501d181c62936f9c544a206a18c">More...</a><br /></td></tr>
<tr class="separator:ab6bc0501d181c62936f9c544a206a18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f0768e69428144a610e591c7d9796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a875f0768e69428144a610e591c7d9796">purify_index_math</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:a875f0768e69428144a610e591c7d9796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds inference and related stages can lift integer bounds expressions out of if statements that guard against those integer expressions doing side-effecty things like dividing or modding by zero.  <a href="namespace_halide_1_1_internal.html#a875f0768e69428144a610e591c7d9796">More...</a><br /></td></tr>
<tr class="separator:a875f0768e69428144a610e591c7d9796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aac0f12f161a6ba2a7b3476dbb1dbf809">qualify</a> (const std::string &amp;prefix, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;value)</td></tr>
<tr class="memdesc:aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <a href="namespace_halide_1_1_internal.html#aac0f12f161a6ba2a7b3476dbb1dbf809">More...</a><br /></td></tr>
<tr class="separator:aac0f12f161a6ba2a7b3476dbb1dbf809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f343747d7f716a33198907c3e7d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a795f343747d7f716a33198907c3e7d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <a href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">More...</a><br /></td></tr>
<tr class="separator:a795f343747d7f716a33198907c3e7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e64539c6d89123f6200b919ec28fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ae4e64539c6d89123f6200b919ec28fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers).  <a href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">More...</a><br /></td></tr>
<tr class="separator:ae4e64539c6d89123f6200b919ec28fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c33f7c870e8bd885383ccdc626112e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6c33f7c870e8bd885383ccdc626112e">lower_random</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;free_vars, int tag)</td></tr>
<tr class="memdesc:af6c33f7c870e8bd885383ccdc626112e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int.  <a href="namespace_halide_1_1_internal.html#af6c33f7c870e8bd885383ccdc626112e">More...</a><br /></td></tr>
<tr class="separator:af6c33f7c870e8bd885383ccdc626112e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310daae8e7f187c090b63aa3514d639c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::vector&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c">realization_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a310daae8e7f187c090b63aa3514d639c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine an order in which to do the scheduling.  <a href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c">More...</a><br /></td></tr>
<tr class="separator:a310daae8e7f187c090b63aa3514d639c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4634146d25cdc2f89c0501ad72ccde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5a4634146d25cdc2f89c0501ad72ccde">topological_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a5a4634146d25cdc2f89c0501ad72ccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule.  <a href="namespace_halide_1_1_internal.html#a5a4634146d25cdc2f89c0501ad72ccde">More...</a><br /></td></tr>
<tr class="separator:a5a4634146d25cdc2f89c0501ad72ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc74570e61290111488ef861e03d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aedcc74570e61290111488ef861e03d0f">split_predicate_test</a> ()</td></tr>
<tr class="separator:aedcc74570e61290111488ef861e03d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8bfb7d84886e922f43c911740f2b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6b8bfb7d84886e922f43c911740f2b1e">is_func_trivial_to_inline</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;func)</td></tr>
<tr class="memdesc:a6b8bfb7d84886e922f43c911740f2b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cost of inlining a function is equivalent to the cost of calling the function directly.  <a href="namespace_halide_1_1_internal.html#a6b8bfb7d84886e922f43c911740f2b1e">More...</a><br /></td></tr>
<tr class="separator:a6b8bfb7d84886e922f43c911740f2b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f341c9e3b9dd03353afdeacd6092db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af5f341c9e3b9dd03353afdeacd6092db">remove_dead_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:af5f341c9e3b9dd03353afdeacd6092db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <a href="namespace_halide_1_1_internal.html#af5f341c9e3b9dd03353afdeacd6092db">More...</a><br /></td></tr>
<tr class="separator:af5f341c9e3b9dd03353afdeacd6092db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7966c5570f5dfae1e45df7995c34a762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7966c5570f5dfae1e45df7995c34a762">remove_extern_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a7966c5570f5dfae1e45df7995c34a762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes placeholder loops for extern stages.  <a href="namespace_halide_1_1_internal.html#a7966c5570f5dfae1e45df7995c34a762">More...</a><br /></td></tr>
<tr class="separator:a7966c5570f5dfae1e45df7995c34a762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe646230de310959c4506c76de02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a078fe646230de310959c4506c76de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <a href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">More...</a><br /></td></tr>
<tr class="separator:a078fe646230de310959c4506c76de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9893105833167095e00bf8802a1294f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9893105833167095e00bf8802a1294f1">schedule_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool &amp;any_memoized)</td></tr>
<tr class="memdesc:a9893105833167095e00bf8802a1294f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> realizations at the appropriate places using the schedule.  <a href="namespace_halide_1_1_internal.html#a9893105833167095e00bf8802a1294f1">More...</a><br /></td></tr>
<tr class="separator:a9893105833167095e00bf8802a1294f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4242a0b28a7409d2a2489a74795914ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a4242a0b28a7409d2a2489a74795914ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c068fc071822f5554d35e8cce582f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3c068fc071822f5554d35e8cce582f54">select_gpu_api</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a3c068fc071822f5554d35e8cce582f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target.  <a href="namespace_halide_1_1_internal.html#a3c068fc071822f5554d35e8cce582f54">More...</a><br /></td></tr>
<tr class="separator:a3c068fc071822f5554d35e8cce582f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b93d357d959c8f75e22e4dedea6da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1b93d357d959c8f75e22e4dedea6da7">simplify</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, bool remove_dead_let_stmts=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af1b93d357d959c8f75e22e4dedea6da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="namespace_halide_1_1_internal.html#af1b93d357d959c8f75e22e4dedea6da7">More...</a><br /></td></tr>
<tr class="separator:af1b93d357d959c8f75e22e4dedea6da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac350731ef3d9028927a72f455f28922f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac350731ef3d9028927a72f455f28922f">simplify</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;, bool remove_dead_let_stmts=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="separator:ac350731ef3d9028927a72f455f28922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5068393c9b9f8b58f7e1c164bee99f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5068393c9b9f8b58f7e1c164bee99f0b">can_prove</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a5068393c9b9f8b58f7e1c164bee99f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to statically prove an expression is true using the simplifier.  <a href="namespace_halide_1_1_internal.html#a5068393c9b9f8b58f7e1c164bee99f0b">More...</a><br /></td></tr>
<tr class="separator:a5068393c9b9f8b58f7e1c164bee99f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0918e7154f0624c9f1a15d34f4776c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0918e7154f0624c9f1a15d34f4776c54">simplify_exprs</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a0918e7154f0624c9f1a15d34f4776c54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a> expressions found in a statement, but don't simplify across different statements.  <a href="namespace_halide_1_1_internal.html#a0918e7154f0624c9f1a15d34f4776c54">More...</a><br /></td></tr>
<tr class="separator:a0918e7154f0624c9f1a15d34f4776c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145896c0b84da47b601412c7f451cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9145896c0b84da47b601412c7f451cb4">simplify_correlated_differences</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a9145896c0b84da47b601412c7f451cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic interval arithmetic can be extremely conservative in cases where we analyze the difference between two correlated expressions.  <a href="namespace_halide_1_1_internal.html#a9145896c0b84da47b601412c7f451cb4">More...</a><br /></td></tr>
<tr class="separator:a9145896c0b84da47b601412c7f451cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4259425c64a0a9b25760e1c38123c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af4259425c64a0a9b25760e1c38123c13">simplify_specializations</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af4259425c64a0a9b25760e1c38123c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the RHS/LHS of a function's definition based on its specializations.  <a href="namespace_halide_1_1_internal.html#af4259425c64a0a9b25760e1c38123c13">More...</a><br /></td></tr>
<tr class="separator:af4259425c64a0a9b25760e1c38123c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">skip_stages</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; std::string &gt; &amp;order)</td></tr>
<tr class="memdesc:a8489422fe4da6e486b5fd7831aab8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <a href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">More...</a><br /></td></tr>
<tr class="separator:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3db85e95026207aa687c6f56c53cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e3db85e95026207aa687c6f56c53cba">sliding_window</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a6e3db85e95026207aa687c6f56c53cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="namespace_halide_1_1_internal.html#a6e3db85e95026207aa687c6f56c53cba">More...</a><br /></td></tr>
<tr class="separator:a6e3db85e95026207aa687c6f56c53cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ed8a60a9ef19bd666e8f12a11f269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a285ed8a60a9ef19bd666e8f12a11f269">solve_expression</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const std::string &amp;variable, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a285ed8a60a9ef19bd666e8f12a11f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e.  <a href="namespace_halide_1_1_internal.html#a285ed8a60a9ef19bd666e8f12a11f269">More...</a><br /></td></tr>
<tr class="separator:a285ed8a60a9ef19bd666e8f12a11f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa500a3f20519d9a27d718f77e1c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01aa500a3f20519d9a27d718f77e1c1e">solve_for_outer_interval</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a01aa500a3f20519d9a27d718f77e1c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it.  <a href="namespace_halide_1_1_internal.html#a01aa500a3f20519d9a27d718f77e1c1e">More...</a><br /></td></tr>
<tr class="separator:a01aa500a3f20519d9a27d718f77e1c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af37b4f0075b3dcd203546133878d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6af37b4f0075b3dcd203546133878d54">solve_for_inner_interval</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a6af37b4f0075b3dcd203546133878d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it.  <a href="namespace_halide_1_1_internal.html#a6af37b4f0075b3dcd203546133878d54">More...</a><br /></td></tr>
<tr class="separator:a6af37b4f0075b3dcd203546133878d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4e051947dc094f3136a7b1e69a1e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1fe4e051947dc094f3136a7b1e69a1e1">and_condition_over_domain</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;c, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;varying)</td></tr>
<tr class="memdesc:a1fe4e051947dc094f3136a7b1e69a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables.  <a href="namespace_halide_1_1_internal.html#a1fe4e051947dc094f3136a7b1e69a1e1">More...</a><br /></td></tr>
<tr class="separator:a1fe4e051947dc094f3136a7b1e69a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e1e287e68d69ec35fd8a1e62d1c30ed">solve_test</a> ()</td></tr>
<tr class="separator:a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8dbe6ebbf9e99beda91f45eead442f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e8dbe6ebbf9e99beda91f45eead442f">split_tuples</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a1e8dbe6ebbf9e99beda91f45eead442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions.  <a href="namespace_halide_1_1_internal.html#a1e8dbe6ebbf9e99beda91f45eead442f">More...</a><br /></td></tr>
<tr class="separator:a1e8dbe6ebbf9e99beda91f45eead442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f1d389af9c9074589d868f106ab1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7d4f1d389af9c9074589d868f106ab1a">print_to_html</a> (const std::string &amp;filename, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a7d4f1d389af9c9074589d868f106ab1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> to filename.  <a href="namespace_halide_1_1_internal.html#a7d4f1d389af9c9074589d868f106ab1a">More...</a><br /></td></tr>
<tr class="separator:a7d4f1d389af9c9074589d868f106ab1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6219802c50d1b296c9053344abe66b1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6219802c50d1b296c9053344abe66b1e">print_to_html</a> (const std::string &amp;filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m)</td></tr>
<tr class="memdesc:a6219802c50d1b296c9053344abe66b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> to filename.  <a href="namespace_halide_1_1_internal.html#a6219802c50d1b296c9053344abe66b1e">More...</a><br /></td></tr>
<tr class="separator:a6219802c50d1b296c9053344abe66b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac8cb6fe2cb6171bf79124c2c1b1e867f">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> nodes respectively.  <a href="namespace_halide_1_1_internal.html#ac8cb6fe2cb6171bf79124c2c1b1e867f">More...</a><br /></td></tr>
<tr class="separator:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a328a1d6d3f0c78ffdc58ac5df812f05a">storage_folding</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="namespace_halide_1_1_internal.html#a328a1d6d3f0c78ffdc58ac5df812f05a">More...</a><br /></td></tr>
<tr class="separator:a328a1d6d3f0c78ffdc58ac5df812f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5dab8c12346254d9348060878045c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad8a5dab8c12346254d9348060878045c">strictify_float</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:ad8a5dab8c12346254d9348060878045c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions.  <a href="namespace_halide_1_1_internal.html#ad8a5dab8c12346254d9348060878045c">More...</a><br /></td></tr>
<tr class="separator:ad8a5dab8c12346254d9348060878045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77fafc3670bd07362c388820dd10c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab77fafc3670bd07362c388820dd10c11">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab77fafc3670bd07362c388820dd10c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="namespace_halide_1_1_internal.html#ab77fafc3670bd07362c388820dd10c11">More...</a><br /></td></tr>
<tr class="separator:ab77fafc3670bd07362c388820dd10c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953484f8812539e108a6c4e137ebfc62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a953484f8812539e108a6c4e137ebfc62">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a953484f8812539e108a6c4e137ebfc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="namespace_halide_1_1_internal.html#a953484f8812539e108a6c4e137ebfc62">More...</a><br /></td></tr>
<tr class="separator:a953484f8812539e108a6c4e137ebfc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d044309ede4782cabce475570934a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a92d044309ede4782cabce475570934a8">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a92d044309ede4782cabce475570934a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="namespace_halide_1_1_internal.html#a92d044309ede4782cabce475570934a8">More...</a><br /></td></tr>
<tr class="separator:a92d044309ede4782cabce475570934a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ebb6536c3233e6466073757f0e59e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14ebb6536c3233e6466073757f0e59e7">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="separator:a14ebb6536c3233e6466073757f0e59e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07967ab74e22a0103d6af67ec62cc3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07967ab74e22a0103d6af67ec62cc3b7">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a07967ab74e22a0103d6af67ec62cc3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="namespace_halide_1_1_internal.html#a07967ab74e22a0103d6af67ec62cc3b7">More...</a><br /></td></tr>
<tr class="separator:a07967ab74e22a0103d6af67ec62cc3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b12ab6ef3f59e897315145d1e996e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1b12ab6ef3f59e897315145d1e996e2">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="separator:ae1b12ab6ef3f59e897315145d1e996e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e67268c787fe55a7bc5e3559f43cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a457e67268c787fe55a7bc5e3559f43cc">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a457e67268c787fe55a7bc5e3559f43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="namespace_halide_1_1_internal.html#a457e67268c787fe55a7bc5e3559f43cc">More...</a><br /></td></tr>
<tr class="separator:a457e67268c787fe55a7bc5e3559f43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a95627cc6470e3f8975ab3b1fa2048e3e">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="separator:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219abd8f63bb237e29a7b878a445836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8219abd8f63bb237e29a7b878a445836">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a8219abd8f63bb237e29a7b878a445836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1d8e9db71fa11a9eb45590a8fd5ff774">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="separator:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafce6d574b476cf9c9acd5f622450ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaafce6d574b476cf9c9acd5f622450ab">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aaafce6d574b476cf9c9acd5f622450ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <a href="namespace_halide_1_1_internal.html#aaafce6d574b476cf9c9acd5f622450ab">More...</a><br /></td></tr>
<tr class="separator:aaafce6d574b476cf9c9acd5f622450ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a57aa0cf600e63ac832ea799f354acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a57aa0cf600e63ac832ea799f354acc">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="separator:a6a57aa0cf600e63ac832ea799f354acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca85eaf8baf3957bda33b83b20c694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae0ca85eaf8baf3957bda33b83b20c694">target_test</a> ()</td></tr>
<tr class="separator:ae0ca85eaf8baf3957bda33b83b20c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f1bcce3709f5f726b4a791d555a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a402f1bcce3709f5f726b4a791d555a99">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::string &amp;pipeline_name, bool trace_pipeline, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;<a class="el" href="struct_halide_1_1_target.html">Target</a>)</td></tr>
<tr class="memdesc:a402f1bcce3709f5f726b4a791d555a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="namespace_halide_1_1_internal.html#a402f1bcce3709f5f726b4a791d555a99">More...</a><br /></td></tr>
<tr class="separator:a402f1bcce3709f5f726b4a791d555a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">trim_no_ops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate loop bounds to the region over which they actually do something.  <a href="namespace_halide_1_1_internal.html#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">More...</a><br /></td></tr>
<tr class="separator:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803d2593422e45d64b2d15429cfde0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8803d2593422e45d64b2d15429cfde0d">unify_duplicate_lets</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a8803d2593422e45d64b2d15429cfde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <a href="namespace_halide_1_1_internal.html#a8803d2593422e45d64b2d15429cfde0d">More...</a><br /></td></tr>
<tr class="separator:a8803d2593422e45d64b2d15429cfde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400b238529ddcab092d8bfa88ad33880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a400b238529ddcab092d8bfa88ad33880">uniquify_variable_names</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a400b238529ddcab092d8bfa88ad33880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="namespace_halide_1_1_internal.html#a400b238529ddcab092d8bfa88ad33880">More...</a><br /></td></tr>
<tr class="separator:a400b238529ddcab092d8bfa88ad33880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ff22da036ee4307f0963aadc7fa9fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a60ff22da036ee4307f0963aadc7fa9fe">uniquify_variable_names_test</a> ()</td></tr>
<tr class="separator:a60ff22da036ee4307f0963aadc7fa9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffc3710f4a568f3e626e253bc758c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a49ffc3710f4a568f3e626e253bc758c2">unpack_buffers</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a49ffc3710f4a568f3e626e253bc758c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates let stmts for the various buffer components (e.g.  <a href="namespace_halide_1_1_internal.html#a49ffc3710f4a568f3e626e253bc758c2">More...</a><br /></td></tr>
<tr class="separator:a49ffc3710f4a568f3e626e253bc758c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f57de73c898a70875fff4fad5cbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada0f57de73c898a70875fff4fad5cbf3">unroll_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:ada0f57de73c898a70875fff4fad5cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="namespace_halide_1_1_internal.html#ada0f57de73c898a70875fff4fad5cbf3">More...</a><br /></td></tr>
<tr class="separator:ada0f57de73c898a70875fff4fad5cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b7ac6d7399bf2ba00640fe7aa794f7f">lower_unsafe_promises</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all unsafe promises into either assertions or unchecked code, depending on the target.  <a href="namespace_halide_1_1_internal.html#a0b7ac6d7399bf2ba00640fe7aa794f7f">More...</a><br /></td></tr>
<tr class="separator:a0b7ac6d7399bf2ba00640fe7aa794f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d28d6c47ed91864a2f92e8b2868128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0d28d6c47ed91864a2f92e8b2868128">lower_safe_promises</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:aa0d28d6c47ed91864a2f92e8b2868128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all safe promises by just stripping them.  <a href="namespace_halide_1_1_internal.html#aa0d28d6c47ed91864a2f92e8b2868128">More...</a><br /></td></tr>
<tr class="separator:aa0d28d6c47ed91864a2f92e8b2868128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplParams" colspan="2">template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplItemLeft" align="right" valign="top">DST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">safe_numeric_cast</a> (SRC s)</td></tr>
<tr class="memdesc:ab7501900efa7660edf445ed1b14c020c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible.  <a href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">More...</a><br /></td></tr>
<tr class="separator:ab7501900efa7660edf445ed1b14c020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">More...</a><br /></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d7dfc983d7a320ea1510c24bc55625"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr class="memdesc:a18d7dfc983d7a320ea1510c24bc55625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">More...</a><br /></td></tr>
<tr class="separator:a18d7dfc983d7a320ea1510c24bc55625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">get_env_variable</a> (char const *env_var_name)</td></tr>
<tr class="memdesc:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <a href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">More...</a><br /></td></tr>
<tr class="separator:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">running_program_name</a> ()</td></tr>
<tr class="memdesc:ab4b793745b048fa1fd344907ec4ec9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <a href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">More...</a><br /></td></tr>
<tr class="separator:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd490221160a7206bb151d6eae65624"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:aabd490221160a7206bb151d6eae65624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">More...</a><br /></td></tr>
<tr class="separator:aabd490221160a7206bb151d6eae65624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0bd73d997ddc50f3523a21448471f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7ec0bd73d997ddc50f3523a21448471f">unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a7ec0bd73d997ddc50f3523a21448471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ca52c958b993ebd766f4b83de2cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af26ca52c958b993ebd766f4b83de2cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string.  <a href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">More...</a><br /></td></tr>
<tr class="separator:af26ca52c958b993ebd766f4b83de2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a290fb244405de2c014ebdc3cd1fc8f08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string.  <a href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">More...</a><br /></td></tr>
<tr class="separator:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9c06bf852ad18eb3e9014495f5816c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <a href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">More...</a><br /></td></tr>
<tr class="separator:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403191721c99e2a88864db3bafbf7b0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a403191721c99e2a88864db3bafbf7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <a href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">More...</a><br /></td></tr>
<tr class="separator:a403191721c99e2a88864db3bafbf7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <a href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">More...</a><br /></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <a href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">More...</a><br /></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <a href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">More...</a><br /></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a4f8aad349dd3bfc69483b792fcab0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <a href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">More...</a><br /></td></tr>
<tr class="separator:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">dir_make_temp</a> ()</td></tr>
<tr class="memdesc:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <a href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">More...</a><br /></td></tr>
<tr class="separator:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a323363444e3d16237848f6f8715b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aff2a323363444e3d16237848f6f8715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <a href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">More...</a><br /></td></tr>
<tr class="separator:aff2a323363444e3d16237848f6f8715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034796c3683c3301a09c0102c6adb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">assert_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a034796c3683c3301a09c0102c6adb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file doesn't exist.  <a href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">More...</a><br /></td></tr>
<tr class="separator:a034796c3683c3301a09c0102c6adb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">assert_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file DOES exist.  <a href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">More...</a><br /></td></tr>
<tr class="separator:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <a href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">More...</a><br /></td></tr>
<tr class="separator:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c611b7403f5613f08fb701ea6eed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">ensure_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a947c611b7403f5613f08fb701ea6eed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that no file with this path exists.  <a href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">More...</a><br /></td></tr>
<tr class="separator:a947c611b7403f5613f08fb701ea6eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710588d377ce398aa366fc00f6d436aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a710588d377ce398aa366fc00f6d436aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <a href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">More...</a><br /></td></tr>
<tr class="separator:a710588d377ce398aa366fc00f6d436aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f41b4199ab2236fb4056661f20cc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa0f41b4199ab2236fb4056661f20cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <a href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">More...</a><br /></td></tr>
<tr class="separator:aa0f41b4199ab2236fb4056661f20cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad702fdea527abbf0f987c72aaacf9b69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad702fdea527abbf0f987c72aaacf9b69">read_entire_file</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:ad702fdea527abbf0f987c72aaacf9b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire contents of a file into a vector&lt;char&gt;.  <a href="namespace_halide_1_1_internal.html#ad702fdea527abbf0f987c72aaacf9b69">More...</a><br /></td></tr>
<tr class="separator:ad702fdea527abbf0f987c72aaacf9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a74e2116e6583961430bb9f96dc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">write_entire_file</a> (const std::string &amp;pathname, const void *source, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> source_len)</td></tr>
<tr class="memdesc:a4a0a74e2116e6583961430bb9f96dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or replace the contents of a file with a given pointer-and-length of memory.  <a href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">More...</a><br /></td></tr>
<tr class="separator:a4a0a74e2116e6583961430bb9f96dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a41c09f705e2859eea67df0e04501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a687a41c09f705e2859eea67df0e04501">write_entire_file</a> (const std::string &amp;pathname, const std::vector&lt; char &gt; &amp;source)</td></tr>
<tr class="separator:a687a41c09f705e2859eea67df0e04501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">More...</a><br /></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342a753f8441a0b29418b0d22cbda86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">halide_tic_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:ae342a753f8441a0b29418b0d22cbda86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">halide_toc_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad2a455f3f5fbe779f6de0acbec1bfa44">c_print_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a version of a string that is a valid identifier in C (.  <a href="namespace_halide_1_1_internal.html#ad2a455f3f5fbe779f6de0acbec1bfa44">More...</a><br /></td></tr>
<tr class="separator:ad2a455f3f5fbe779f6de0acbec1bfa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a591746c6ae0cd3e8d24c2c2420772d8a">get_llvm_version</a> ()</td></tr>
<tr class="memdesc:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVM_VERSION against which this libHalide is compiled.  <a href="namespace_halide_1_1_internal.html#a591746c6ae0cd3e8d24c2c2420772d8a">More...</a><br /></td></tr>
<tr class="separator:a591746c6ae0cd3e8d24c2c2420772d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7006f0b4b15257feedd9e57d1288dc97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7006f0b4b15257feedd9e57d1288dc97">make_argument_list</a> (int dimensionality)</td></tr>
<tr class="memdesc:a7006f0b4b15257feedd9e57d1288dc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of unique arguments for definitions with unnamed arguments.  <a href="namespace_halide_1_1_internal.html#a7006f0b4b15257feedd9e57d1288dc97">More...</a><br /></td></tr>
<tr class="separator:a7006f0b4b15257feedd9e57d1288dc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67bb97b08ab82cba4e520c1f48a0821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af67bb97b08ab82cba4e520c1f48a0821">vectorize_loops</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:af67bb97b08ab82cba4e520c1f48a0821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="namespace_halide_1_1_internal.html#af67bb97b08ab82cba4e520c1f48a0821">More...</a><br /></td></tr>
<tr class="separator:af67bb97b08ab82cba4e520c1f48a0821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a47ba0a978ebdc5f1866290752bd76e6d">wrap_func_calls</a> (const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a47ba0a978ebdc5f1866290752bd76e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions.  <a href="namespace_halide_1_1_internal.html#a47ba0a978ebdc5f1866290752bd76e6d">More...</a><br /></td></tr>
<tr class="separator:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d57ef08d50b32cd0f947c699a7508"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abb9d57ef08d50b32cd0f947c699a7508">get_test_tmp_dir</a> ()</td></tr>
<tr class="memdesc:abb9d57ef08d50b32cd0f947c699a7508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path to a directory that can be safely written to when running tests; the contents directory may or may not outlast the lifetime of test itself (ie, the files may be cleaned up after test execution).  <a href="namespace_halide_1_1_internal.html#abb9d57ef08d50b32cd0f947c699a7508">More...</a><br /></td></tr>
<tr class="separator:abb9d57ef08d50b32cd0f947c699a7508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a38df81db6d9aef92f0b8132a6cbdbdd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a38df81db6d9aef92f0b8132a6cbdbdd4">lower_int_uint_div</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a38df81db6d9aef92f0b8132a6cbdbdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary.  <a href="namespace_halide_1_1_internal.html#a38df81db6d9aef92f0b8132a6cbdbdd4">More...</a><br /></td></tr>
<tr class="separator:a38df81db6d9aef92f0b8132a6cbdbdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44815561924377a690cf1d967bd19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3b44815561924377a690cf1d967bd19f">lower_int_uint_mod</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a3b44815561924377a690cf1d967bd19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary.  <a href="namespace_halide_1_1_internal.html#a3b44815561924377a690cf1d967bd19f">More...</a><br /></td></tr>
<tr class="separator:a3b44815561924377a690cf1d967bd19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7a4f18b650b23e1e6ed980d1feebcf5">lower_euclidean_div</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="namespace_halide_1_1_internal.html#ab7a4f18b650b23e1e6ed980d1feebcf5">More...</a><br /></td></tr>
<tr class="separator:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d78fd7f3115750e17167ebf0fe920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae81d78fd7f3115750e17167ebf0fe920">lower_euclidean_mod</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ae81d78fd7f3115750e17167ebf0fe920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="namespace_halide_1_1_internal.html#ae81d78fd7f3115750e17167ebf0fe920">More...</a><br /></td></tr>
<tr class="separator:ae81d78fd7f3115750e17167ebf0fe920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ce06cce9e67778758fd7090bd991421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ce06cce9e67778758fd7090bd991421">lower_signed_shift_left</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a9ce06cce9e67778758fd7090bd991421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts.  <a href="namespace_halide_1_1_internal.html#a9ce06cce9e67778758fd7090bd991421">More...</a><br /></td></tr>
<tr class="separator:a9ce06cce9e67778758fd7090bd991421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2637f42ac63c862b5f2a279164d640d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2637f42ac63c862b5f2a279164d640d1">lower_signed_shift_right</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a2637f42ac63c862b5f2a279164d640d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts.  <a href="namespace_halide_1_1_internal.html#a2637f42ac63c862b5f2a279164d640d1">More...</a><br /></td></tr>
<tr class="separator:a2637f42ac63c862b5f2a279164d640d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a371a9e04b6a14f9897b94bc78437023d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a371a9e04b6a14f9897b94bc78437023d">eliminate_bool_vectors</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a371a9e04b6a14f9897b94bc78437023d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="namespace_halide_1_1_internal.html#a371a9e04b6a14f9897b94bc78437023d">More...</a><br /></td></tr>
<tr class="separator:a371a9e04b6a14f9897b94bc78437023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320940955c9bdcced50b4f31ddd3f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6320940955c9bdcced50b4f31ddd3f18">eliminate_bool_vectors</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;s)</td></tr>
<tr class="memdesc:a6320940955c9bdcced50b4f31ddd3f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="namespace_halide_1_1_internal.html#a6320940955c9bdcced50b4f31ddd3f18">More...</a><br /></td></tr>
<tr class="separator:a6320940955c9bdcced50b4f31ddd3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a560a698db966dbc2d5edcb7896e56d4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a560a698db966dbc2d5edcb7896e56d4d">reduce_expr_modulo</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> modulus, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *remainder)</td></tr>
<tr class="memdesc:a560a698db966dbc2d5edcb7896e56d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="namespace_halide_1_1_internal.html#a560a698db966dbc2d5edcb7896e56d4d">More...</a><br /></td></tr>
<tr class="separator:a560a698db966dbc2d5edcb7896e56d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99da5cb047c88b9a411ce79ca672059a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a99da5cb047c88b9a411ce79ca672059a">reduce_expr_modulo</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> modulus, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *remainder, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a99da5cb047c88b9a411ce79ca672059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="namespace_halide_1_1_internal.html#a99da5cb047c88b9a411ce79ca672059a">More...</a><br /></td></tr>
<tr class="separator:a99da5cb047c88b9a411ce79ca672059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac4e8d52841afa71f1f7bac7ce9611159"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4e8d52841afa71f1f7bac7ce9611159">unknown</a> = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;::<a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>()</td></tr>
<tr class="separator:ac4e8d52841afa71f1f7bac7ce9611159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf1a96be9fadff5521559de5f72935c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4bf1a96be9fadff5521559de5f72935c">StrongestExprNodeType</a> = <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">IRNodeType::VectorReduce</a></td></tr>
<tr class="separator:a4bf1a96be9fadff5521559de5f72935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abff8dba5612d856cc2acfab99e3cf479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff8dba5612d856cc2acfab99e3cf479">&#9670;&nbsp;</a></span>DimBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">Halide::Internal::DimBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00020">20</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
<a id="aaa0611a86047e2c583dd061a620dcc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0611a86047e2c583dd061a620dcc6e">&#9670;&nbsp;</a></span>FuncValueBounds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_bounds_8h_source.html#l00017">17</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a id="ae0c76d77a93240aaabd916abf0b10beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c76d77a93240aaabd916abf0b10beb">&#9670;&nbsp;</a></span>add_const_if_T_is_const</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ae0c76d77a93240aaabd916abf0b10beb">Halide::Internal::add_const_if_T_is_const</a> = typedef typename std::conditional&lt;std::is_const&lt;T&gt;::value, const T2, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00079">79</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a40a4f8fc5c4fcce2e0b5656bd6c831bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4f8fc5c4fcce2e0b5656bd6c831bb">&#9670;&nbsp;</a></span>GeneratorParamImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a40a4f8fc5c4fcce2e0b5656bd6c831bb">Halide::Internal::GeneratorParamImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_target.html">Target</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a>&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, std::string&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___string.html">GeneratorParam_String</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_type.html">Type</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, bool&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_enum&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a>&lt;T&gt; &gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00950">950</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="aaebc4e1b658e316d9738ac723778525e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebc4e1b658e316d9738ac723778525e">&#9670;&nbsp;</a></span>GeneratorInputImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#aaebc4e1b658e316d9738ac723778525e">Halide::Internal::GeneratorInputImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;TBase, <a class="el" href="class_halide_1_1_func.html">Func</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_scalar&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a>&lt;T&gt; &gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02094">2094</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ab3efc8f40050501582a4dc9dafcd18a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3efc8f40050501582a4dc9dafcd18a9">&#9670;&nbsp;</a></span>GeneratorOutputImplBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ab3efc8f40050501582a4dc9dafcd18a9">Halide::Internal::GeneratorOutputImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;TBase, <a class="el" href="class_halide_1_1_func.html">Func</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a>&lt;T&gt; &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a>&lt;T&gt; &gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02629">2629</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a6bc4779d7bb27645f2fc95ab5aaab4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc4779d7bb27645f2fc95ab5aaab4d8">&#9670;&nbsp;</a></span>GeneratorFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a6bc4779d7bb27645f2fc95ab5aaab4d8">Halide::Internal::GeneratorFactory</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a>&gt;(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02975">2975</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a9e4e2eb6b31542f36a2c879aa18c48a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e2eb6b31542f36a2c879aa18c48a7">&#9670;&nbsp;</a></span>GeneratorParamsMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a9e4e2eb6b31542f36a2c879aa18c48a7">Halide::Internal::GeneratorParamsMap</a> = typedef std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02992">2992</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="ab837f22cfa4bfe22dba01f4908e839ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab837f22cfa4bfe22dba01f4908e839ff">&#9670;&nbsp;</a></span>halide_task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Halide::Internal::halide_task) (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_j_i_t_module_8h_source.html#l00140">140</a> of file <a class="el" href="_j_i_t_module_8h_source.html">JITModule.h</a>.</p>

</div>
</div>
<a id="a7114c2dcec2af79da28735c5b11c0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7114c2dcec2af79da28735c5b11c0916">&#9670;&nbsp;</a></span>LLVMOStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef llvm::raw_pwrite_stream <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Halide::Internal::LLVMOStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___output_8h_source.html#l00027">27</a> of file <a class="el" href="_l_l_v_m___output_8h_source.html">LLVM_Output.h</a>.</p>

</div>
</div>
<a id="af7acd6f64d4adf2c1b53c8931c3d0b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7acd6f64d4adf2c1b53c8931c3d0b87">&#9670;&nbsp;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">Halide::Internal::make_integer_sequence</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a>&lt;T, 0, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00397">397</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ac5d7a7bcb6b4a7de95e27c3234a36c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d7a7bcb6b4a7de95e27c3234a36c68">&#9670;&nbsp;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ac5d7a7bcb6b4a7de95e27c3234a36c68">Halide::Internal::index_sequence</a> = typedef <a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a>&lt;<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00400">400</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a77432e592449f569978b6aabd58831f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77432e592449f569978b6aabd58831f0">&#9670;&nbsp;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a77432e592449f569978b6aabd58831f0">Halide::Internal::make_index_sequence</a> = typedef <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a>&lt;<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00403">403</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8548315fd4d13ccebe45a8123369f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8548315fd4d13ccebe45a8123369f7ca">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Halide::Internal::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a varying expression, try to find a constant that is either: An upper bound (always greater than or equal to the expression), or A lower bound (always less than or equal to the expression) If it fails, returns an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec"></a>Upper&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93"></a>Lower&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_bounds_8h_source.html#l00042">42</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a id="aee9e0b8e5376e2294d74ded8e7de9ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9e0b8e5376e2294d74ded8e7de9ef2">&#9670;&nbsp;</a></span>IRNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">Halide::Internal::IRNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All our IR node types get unique IDs for the purposes of RTTI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417"></a>IntImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8"></a>UIntImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07"></a>FloatImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73"></a>StringImm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842"></a>Broadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c"></a>Cast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9"></a>Variable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2"></a>Sub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0"></a>NE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b"></a>LT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6"></a>LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020"></a>GT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9"></a>GE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff"></a>Select&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb"></a>Load&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb"></a>Ramp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e"></a>Call&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6"></a>Let&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083"></a>Shuffle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5"></a>VectorReduce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2"></a>LetStmt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742"></a>AssertStmt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0"></a>ProducerConsumer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11"></a>For&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a993ca650a85e8e69b8f7eaa4809c4862"></a>Acquire&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72"></a>Store&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7"></a>Provide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f"></a>Allocate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594"></a>Free&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc"></a>Realize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a36c81967df3424f919e89b09ed34c90d"></a>Fork&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f"></a>Evaluate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e"></a>Prefetch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee9e0b8e5376e2294d74ded8e7de9ef2a557eccd321b7f10f5127c1ef27aaac7d"></a>Atomic&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00025">25</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a6a8761f129e6554b9ea03de31bf066f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8761f129e6554b9ea03de31bf066f1">&#9670;&nbsp;</a></span>ForType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">Halide::Internal::ForType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of loop traversal. </p>
<p>Used in schedules, and in the <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> loop IR node. Serial is a conventional ordered for loop. Iterations occur in increasing order, and each iteration must appear to have finished before the next begins. Parallel, GPUBlock, and GPUThread are parallel and unordered: iterations may occur in any order, and multiple iterations may occur simultaneously. Vectorized and GPULane are parallel and synchronous: they act as if all iterations occur at the same time in lockstep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493"></a>Serial&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a498ab78ee0b25ce33c83714c1a453831"></a>Extern&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28"></a>GPUBlock&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d"></a>GPUThread&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642"></a>GPULane&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00395">395</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="ae02ee070dfadab621e55f3b3dd971e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ee070dfadab621e55f3b3dd971e18">&#9670;&nbsp;</a></span>IOKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18">Halide::Internal::IOKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae02ee070dfadab621e55f3b3dd971e18af60357a8d17e45793298323f1b372a74"></a>Scalar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261"></a>Function&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02ee070dfadab621e55f3b3dd971e18a7e62bc342f41c946868f0ea6f0b712d8"></a>Buffer&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l01260">1260</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a43770c59ec0f13935f4b33502ba7e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43770c59ec0f13935f4b33502ba7e817">&#9670;&nbsp;</a></span>SyntheticParamType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817">Halide::Internal::SyntheticParamType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508"></a>Type&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9"></a>Dim&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c"></a>ArraySize&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02716">2716</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a id="a7dc0c8c1adc38d2c5a80979948f0007c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc0c8c1adc38d2c5a80979948f0007c">&#9670;&nbsp;</a></span>Monotonic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Halide::Internal::Monotonic</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd"></a>Increasing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b"></a>Decreasing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_monotonic_8h_source.html#l00021">21</a> of file <a class="el" href="_monotonic_8h_source.html">Monotonic.h</a>.</p>

</div>
</div>
<a id="a5b8c72fcb8800b47e313c62f5416a4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c72fcb8800b47e313c62f5416a4fe">&#9670;&nbsp;</a></span>DimType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fe">Halide::Internal::DimType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each <a class="el" href="struct_halide_1_1_internal_1_1_dim.html" title="The Dim struct represents one loop in the schedule&#39;s representation of a loop nest.">Dim</a> below has a dim_type, which tells you what transformations are legal on it. </p>
<p>When you combine two Dims of distinct DimTypes (e.g. with <a class="el" href="class_halide_1_1_stage.html#a8e29492266ca6c310199a0ba1b0c2c41">Stage::fuse</a>), the combined result has the greater enum value of the two types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4feafbbbe5ac592bfdafcfa397cd609d8117"></a>PureVar&#160;</td><td class="fielddoc"><p>This dim originated from a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>. </p>
<p>You can evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> in any order over an interval that's at least as large as the interval required. In pure definitions you can even redundantly re-evaluate points. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4fead117eadbd7c1c4d821b3a598d54d03f2"></a>PureRVar&#160;</td><td class="fielddoc"><p>The dim originated from an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. </p>
<p>You can evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in any order (including in parallel) over exactly the interval specified in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>. PureRVars can also be reordered arbitrarily in the dims list, as there are no data hazards between the evaluation of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>.</p>
<p>The most common case where an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> is considered pure is RVars that are used in a way which obeys all the syntactic constraints that a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> does, e.g:</p>
<div class="fragment"><div class="line">RDom r(0, 100);</div>
<div class="line">f(r.x) = f(r.x) + 5;</div>
</div><!-- fragment --><p>Other cases where RVars are pure are where the sites being written to by the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> evaluated at one value of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> couldn't possibly collide with the sites being written or read by the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at a distinct value of the <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, r.x is pure in the following three definitions:</p>
<div class="fragment"><div class="line"><span class="comment">// This definition writes to even coordinates and reads from the</span></div>
<div class="line"><span class="comment">// same site (which no other value of r.x is writing to) and odd</span></div>
<div class="line"><span class="comment">// sites (which no other value of r.x is writing to):</span></div>
<div class="line">f(2*r.x) = <a class="code" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(2*r.x), f(2*r.x + 7));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This definition writes to scanline zero and reads from the the</span></div>
<div class="line"><span class="comment">// same site and scanline one:</span></div>
<div class="line">f(r.x, 0) += f(r.x, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This definition reads and writes over non-overlapping ranges:</span></div>
<div class="line">f(r.x + 100) += f(r.x);</div>
<div class="ttc" id="anamespace_halide_html_aea2c7f5fe6c79a49dcbb28951cf8405d"><div class="ttname"><a href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">Halide::max</a></div><div class="ttdeci">Expr max(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00581">Func.h:581</a></div></div>
</div><!-- fragment --><p>To give two counterexamples, r.x is not pure in the following definitions:</p>
<div class="fragment"><div class="line"><span class="comment">// The same site is written by distinct values of the RVar</span></div>
<div class="line"><span class="comment">// (write-after-write hazard):</span></div>
<div class="line">f(r.x / 2) += f(r.x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// One value of r.x reads from a site that another value of r.x</span></div>
<div class="line"><span class="comment">// is writing to (read-after-write hazard):</span></div>
<div class="line">f(r.x) += f(r.x + 1);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a5b8c72fcb8800b47e313c62f5416a4feac2ab1e3a4730b5543c84be4a4a223b83"></a>ImpureRVar&#160;</td><td class="fielddoc"><p>The dim originated from an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>. </p>
<p>You must evaluate a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> at distinct values of this <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in increasing order over precisely the interval specified in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>. ImpureRVars may not be reordered with respect to other ImpureRVars.</p>
<p>All RVars are impure by default. Those for which we can prove no data hazards exist get promoted to PureRVar. There are two instances in which ImpureRVars may be parallelized or reordered even in the presence of hazards:</p>
<p>1) In the case of an update definition that has been proven to be an associative and commutative reduction, reordering of ImpureRVars is allowed, and parallelizing them is allowed if the update has been made atomic.</p>
<p>2) ImpureRVars can also be reordered and parallelized if <a class="el" href="class_halide_1_1_func.html#a1a4e3036be68507f07d1c952560a7a6f" title="Specify that race conditions are permitted for this Func, which enables parallelizing over RVars even...">Func::allow_race_conditions()</a> has been set. This is the escape hatch for when there are no hazards but the checks above failed to prove that (<a class="el" href="class_halide_1_1_r_dom.html#ab412e453375071f67584442a0dc71dd8" title="Add a predicate to the RDom.">RDom::where</a> can encode arbitrary facts about non-linear integer arithmetic, which is undecidable), or for when you don't actually care about the non-determinism introduced by data hazards (e.g. in the algorithm HOGWILD!). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_schedule_8h_source.html#l00293">293</a> of file <a class="el" href="_schedule_8h_source.html">Schedule.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d0ab1dd42e03181bf0320902e233995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0ab1dd42e03181bf0320902e233995">&#9670;&nbsp;</a></span>add_atomic_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_atomic_mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe5c6a19891ace3a590f49ba456ca1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5c6a19891ace3a590f49ba456ca1d6">&#9670;&nbsp;</a></span>add_image_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_image_checks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>will_inject_host_copies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g. </p>
<p>stride.0 must be 1). </p>

</div>
</div>
<a id="af1610da9bbdeab59ba5d7724231352ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1610da9bbdeab59ba5d7724231352ab">&#9670;&nbsp;</a></span>add_parameter_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_parameter_checks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure that all referenced parameters meet their constraints. </p>
<p>Also injects any custom requirements provided by the user. </p>

</div>
</div>
<a id="a1e4111f5909dc405a5d564c7c0c2c4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4111f5909dc405a5d564c7c0c2c4a4">&#9670;&nbsp;</a></span>align_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::align_loads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors. </p>

</div>
</div>
<a id="a410eac3ad68dfb697c5ee97100f2053f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410eac3ad68dfb697c5ee97100f2053f">&#9670;&nbsp;</a></span>allocation_bounds_inference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::allocation_bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a id="aab98c44d7a462e3217c6a4f6ddbe3bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab98c44d7a462e3217c6a4f6ddbe3bc7">&#9670;&nbsp;</a></span>apply_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a>&gt; Halide::Internal::apply_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_extent_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let). </p>

</div>
</div>
<a id="a639111963bc0698b1b724299ec35b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639111963bc0698b1b724299ec35b840">&#9670;&nbsp;</a></span>compute_loop_bounds_after_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; &gt; Halide::Internal::compute_loop_bounds_after_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions. </p>

</div>
</div>
<a id="a43db81cbccaa74354f14e7f902094ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43db81cbccaa74354f14e7f902094ed8">&#9670;&nbsp;</a></span>get_ops_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a>&gt;&amp; Halide::Internal::get_ops_table </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf049bd392c948b161c1435e23184a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf049bd392c948b161c1435e23184a20">&#9670;&nbsp;</a></span>prove_associativity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> Halide::Internal::prove_associativity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any. </p>
<p>'is_associative' indicates if the operation was successfuly proven as associative. </p>

</div>
</div>
<a id="a74a6050713d80d82d1ba201fc9f709b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a6050713d80d82d1ba201fc9f709b7">&#9670;&nbsp;</a></span>associativity_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::associativity_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0092d026f554bbd98a3c603e58e6e46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0092d026f554bbd98a3c603e58e6e46e">&#9670;&nbsp;</a></span>fork_async_producers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fork_async_producers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdf8e17b611c700b1a41969a8dc7c1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf8e17b611c700b1a41969a8dc7c1e1">&#9670;&nbsp;</a></span>string_to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an int representation of 's'. </p>
<p>Throw an error on failure. </p>

</div>
</div>
<a id="a553a170f5d655144a90d342f46bb5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553a170f5d655144a90d342f46bb5bc7">&#9670;&nbsp;</a></span>substitute_var_estimates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> with its estimate if specified. </p>

</div>
</div>
<a id="a78c43260020b62213bc2383cb13f7aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c43260020b62213bc2383cb13f7aeb">&#9670;&nbsp;</a></span>substitute_var_estimates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f09ed39b20fb0f51fbda5a7b14c7f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09ed39b20fb0f51fbda5a7b14c7f93">&#9670;&nbsp;</a></span>get_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::get_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an interval. </p>
<p>Return an undefined expr if the interval is unbounded. </p>

</div>
</div>
<a id="a09ce3144d60aa2f3abdb127b3750cb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce3144d60aa2f3abdb127b3750cb73">&#9670;&nbsp;</a></span>box_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::box_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an n-d box. </p>

</div>
</div>
<a id="a5f30fc5e0c64f2e3f32ffe1416f045b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f30fc5e0c64f2e3f32ffe1416f045b0">&#9670;&nbsp;</a></span>disp_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::disp_regions </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to print the bounds of a region. </p>

</div>
</div>
<a id="a4cf44d2ab2c8eca7437d770011107830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf44d2ab2c8eca7437d770011107830">&#9670;&nbsp;</a></span>get_stage_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::get_stage_definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding definition of a function given the stage. </p>
<p>This will throw an assertion if the function is an extern function (Extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> does not have definition). </p>

</div>
</div>
<a id="a12964871a49b9d9eb81fb01991771150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12964871a49b9d9eb81fb01991771150">&#9670;&nbsp;</a></span>get_stage_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a>&gt;&amp; Halide::Internal::get_stage_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding loop dimensions of a function given the stage. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, this will return a list of size 1 containing the dummy __outermost loop dimension. </p>

</div>
</div>
<a id="a753561dbe4e01ef75c2af4ce17d3dfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753561dbe4e01ef75c2af4ce17d3dfb1">&#9670;&nbsp;</a></span>combine_load_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::combine_load_costs </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> partial load costs to the corresponding function in the result costs. </p>

</div>
</div>
<a id="a2f47061da7dd7653e9d9058b850d94e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f47061da7dd7653e9d9058b850d94e5">&#9670;&nbsp;</a></span>get_stage_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>pure_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions. </p>

</div>
</div>
<a id="a20b43d784b088d341d5cb7b465da9e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b43d784b088d341d5cb7b465da9e68">&#9670;&nbsp;</a></span>get_stage_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a>&gt; Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>pure_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds for all the stages of the function 'f'. </p>
<p>Each entry in the returned vector corresponds to a stage. </p>

</div>
</div>
<a id="a1d7faaf922e66ac6f7367697d18fd1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7faaf922e66ac6f7367697d18fd1cd">&#9670;&nbsp;</a></span>perform_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::perform_inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>inlines</em> = <code>std::set&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression. </p>
<p>If 'order' is passed, inlining will be done in the reverse order of function realization to avoid extra inlining works. </p>

</div>
</div>
<a id="a5f6d082a8fe5678245509867a53372c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6d082a8fe5678245509867a53372c3">&#9670;&nbsp;</a></span>get_parents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; Halide::Internal::get_parents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all functions that are directly called by a function stage (f, stage). </p>

</div>
</div>
<a id="a765c203107b702636e6f2cf5ba896f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c203107b702636e6f2cf5ba896f95">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value of element within a map. </p>
<p>This will assert if the element is not in the map. </p>

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00101">101</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<a id="a525a46ec18d54c5534ccccc9e21ac262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525a46ec18d54c5534ccccc9e21ac262">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V&amp; Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00108">108</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<a id="a976aabd7126fce7f9d7a46daeee8fd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976aabd7126fce7f9d7a46daeee8fd40">&#9670;&nbsp;</a></span>inline_all_trivial_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_trivial_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Return true of any of the Funcs is inlined. </p>

</div>
</div>
<a id="a120045d61aae3bbe15e3da7b81bbb821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120045d61aae3bbe15e3da7b81bbb821">&#9670;&nbsp;</a></span>is_func_called_element_wise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::is_func_called_element_wise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> (order[index]) is only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner. </p>
<p>If it is, return the name of the consumer <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>; otherwise, return an empty string. </p>

</div>
</div>
<a id="adb0e38c670066041490103529f6c5707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e38c670066041490103529f6c5707">&#9670;&nbsp;</a></span>inline_all_element_wise_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_element_wise_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in element-wise manner. </p>

</div>
</div>
<a id="a654878c752bfbc9f2aa979007ff80037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654878c752bfbc9f2aa979007ff80037">&#9670;&nbsp;</a></span>propagate_estimate_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::propagate_estimate_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaff82b6f1aebe05e4b73da31dd6d6c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff82b6f1aebe05e4b73da31dd6d6c69">&#9670;&nbsp;</a></span>empty_func_value_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&amp; Halide::Internal::empty_func_value_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a963b0883bbda1c2664341158fce0b030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963b0883bbda1c2664341158fce0b030">&#9670;&nbsp;</a></span>bounds_of_expr_in_scope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::bounds_of_expr_in_scope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>const_bound</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a> or min may be undefined expressions if the value is not bounded above or below. If the expression is a vector, also takes the bounds across the vector lanes and returns a scalar result.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a id="a61f08062dfc06a1816ce78793faf5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f08062dfc06a1816ce78793faf5477">&#9670;&nbsp;</a></span>find_constant_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_constant_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa34593e7612bf139260707200b6dacb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34593e7612bf139260707200b6dacb3">&#9670;&nbsp;</a></span>find_constant_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::find_constant_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bounds for a varying expression that are either constants or +/-inf. </p>

</div>
</div>
<a id="ac2f62c0ee3ace8de2be57a9db369a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f62c0ee3ace8de2be57a9db369a3e4">&#9670;&nbsp;</a></span>merge_boxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::merge_boxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand box a to encompass box b. </p>

</div>
</div>
<a id="ac9641dd947fdf6352ccd5e34548db35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9641dd947fdf6352ccd5e34548db35e">&#9670;&nbsp;</a></span>boxes_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::boxes_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a could possibly overlap box b. </p>

</div>
</div>
<a id="af86d8a9b260b097d115182e4b8488f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86d8a9b260b097d115182e4b8488f09">&#9670;&nbsp;</a></span>box_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of two boxes. </p>

</div>
</div>
<a id="a8c57c8cff1c0ff811a01724b58086bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c57c8cff1c0ff811a01724b58086bdc">&#9670;&nbsp;</a></span>box_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intersection of two boxes. </p>

</div>
</div>
<a id="a9198438916c78b87c90e665d665a18cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9198438916c78b87c90e665d665a18cd">&#9670;&nbsp;</a></span>box_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::box_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if box a provably contains box b. </p>

</div>
</div>
<a id="a2207eb7ea627a6c40ef9112d5992e58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2207eb7ea627a6c40ef9112d5992e58e">&#9670;&nbsp;</a></span>boxes_required() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a id="a08f1f17003b595e2ce4fdf3b20028f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f1f17003b595e2ce4fdf3b20028f1f">&#9670;&nbsp;</a></span>boxes_required() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a835e975cd27bec85e3b6eba41818ed51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835e975cd27bec85e3b6eba41818ed51">&#9670;&nbsp;</a></span>boxes_provided() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a id="a888d5a8e9f3f2571477f2a79257bb725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888d5a8e9f3f2571477f2a79257bb725">&#9670;&nbsp;</a></span>boxes_provided() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a068250f17aa862eac84cfdaf439c9a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068250f17aa862eac84cfdaf439c9a8c">&#9670;&nbsp;</a></span>boxes_touched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a id="a8b0ccd7d9bbf3e0868391038fd0f6401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0ccd7d9bbf3e0868391038fd0f6401">&#9670;&nbsp;</a></span>boxes_touched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6463d6b6c8c2d39485ca75d70bf7b246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6463d6b6c8c2d39485ca75d70bf7b246">&#9670;&nbsp;</a></span>box_required() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a id="a98c9b1c2da827d6cb5394a0bb7e34533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9b1c2da827d6cb5394a0bb7e34533">&#9670;&nbsp;</a></span>box_required() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48514c5115221230858e6e5b8584877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48514c5115221230858e6e5b8584877">&#9670;&nbsp;</a></span>box_provided() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f44cfeb8474bb0aaa36e526fd65e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f44cfeb8474bb0aaa36e526fd65e35">&#9670;&nbsp;</a></span>box_provided() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4b563d3cf1a063d9c85a584f796d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b563d3cf1a063d9c85a584f796d032">&#9670;&nbsp;</a></span>box_touched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d3eadf5a7fa994f622e31c373bcf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3eadf5a7fa994f622e31c373bcf3d3">&#9670;&nbsp;</a></span>box_touched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaff82b6f1aebe05e4b73da31dd6d6c69">empty_func_value_bounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b807d0d1524fb2f20b1533d05032c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b807d0d1524fb2f20b1533d05032c02">&#9670;&nbsp;</a></span>compute_function_value_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> Halide::Internal::compute_function_value_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a id="a439ef9127bf30f5e2a67963eb8db0323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ef9127bf30f5e2a67963eb8db0323">&#9670;&nbsp;</a></span>bounds_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::bounds_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2369df82ba80121eb935e5ac7076de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2369df82ba80121eb935e5ac7076de5">&#9670;&nbsp;</a></span>bounds_inference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a id="a7428f5e071a4f8c2d89a79afc6b426a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7428f5e071a4f8c2d89a79afc6b426a0">&#9670;&nbsp;</a></span>bound_small_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bound_small_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b58338c6b3553965f8360efe1d31788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b58338c6b3553965f8360efe1d31788">&#9670;&nbsp;</a></span>buffer_accessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::buffer_accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00574">Halide::Buffer&lt; T &gt;::operator()()</a>.</p>

</div>
</div>
<a id="aefca0281fde1b4caf8d1d188d4bd809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefca0281fde1b4caf8d1d188d4bd809d">&#9670;&nbsp;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00040">40</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00055">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a id="ae3480ee712c4aecb9425a7e5c540889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3480ee712c4aecb9425a7e5c540889f">&#9670;&nbsp;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00044">44</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a016a8762a4f14a3d708461f0d1616bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016a8762a4f14a3d708461f0d1616bc2">&#9670;&nbsp;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00048">48</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a70ab4586f42653c6b16a6e0ad186f1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ab4586f42653c6b16a6e0ad186f1e5">&#9670;&nbsp;</a></span>get_name_from_end_of_parameter_pack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00055">55</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00040">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a id="ab882d8987fcdb737d28066db1130b509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab882d8987fcdb737d28066db1130b509">&#9670;&nbsp;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00059">59</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00072">get_shape_from_start_of_parameter_pack()</a>, and <a class="el" href="_buffer_8h_source.html#l00066">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="a352d23994d86bd76a8167c6144f3a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352d23994d86bd76a8167c6144f3a3dc">&#9670;&nbsp;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00062">62</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="afc82b2d635d098a40d4b87018edd0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc82b2d635d098a40d4b87018edd0a73">&#9670;&nbsp;</a></span>get_shape_from_start_of_parameter_pack_helper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00066">66</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00059">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="ae7ed87b50654371fbd0e1415c8d52e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ed87b50654371fbd0e1415c8d52e4e">&#9670;&nbsp;</a></span>get_shape_from_start_of_parameter_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Halide::Internal::get_shape_from_start_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00072">72</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p class="reference">References <a class="el" href="_buffer_8h_source.html#l00059">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a id="a844f5db8861adba47dc2dc0e38666407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844f5db8861adba47dc2dc0e38666407">&#9670;&nbsp;</a></span>buffer_type_name_non_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::buffer_type_name_non_const </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00085">85</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a7f55fb27359093d52c4c4447db053edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f55fb27359093d52c4c4447db053edc">&#9670;&nbsp;</a></span>buffer_type_name_non_const&lt; void &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a844f5db8861adba47dc2dc0e38666407">Halide::Internal::buffer_type_name_non_const</a>&lt; void &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00090">90</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="ab14638fa4f1475b6b6acb22a9419afea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14638fa4f1475b6b6acb22a9419afea">&#9670;&nbsp;</a></span>buffer_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::buffer_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_buffer_8h_source.html#l00095">95</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a id="a5eefe960250b26cc13e38cb734803057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eefe960250b26cc13e38cb734803057">&#9670;&nbsp;</a></span>canonicalize_gpu_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::canonicalize_gpu_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize GPU var names into some pre-determined block/thread names (i.e. </p>
<p>__block_id_x, __thread_id_x, etc.). The x/y/z/w order is determined by the nesting order: innermost is assigned to x and so on. </p>

</div>
</div>
<a id="afb8e82dcdf95ffc30f75298421434b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8e82dcdf95ffc30f75298421434b23">&#9670;&nbsp;</a></span>new_CodeGen_D3D12Compute_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a>&gt; Halide::Internal::new_CodeGen_D3D12Compute_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af34de426bebece420150ce4122a60984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34de426bebece420150ce4122a60984">&#9670;&nbsp;</a></span>new_CodeGen_Hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a>&gt; Halide::Internal::new_CodeGen_Hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22cff24ff522c4d1603ab6d068096937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cff24ff522c4d1603ab6d068096937">&#9670;&nbsp;</a></span>build_closure_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType* Halide::Internal::build_closure_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>halide_buffer_t_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures.">Closure</a>. </p>

</div>
</div>
<a id="a7d846909bbfed031801337b1a8203ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d846909bbfed031801337b1a8203ed3">&#9670;&nbsp;</a></span>pack_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::pack_closure </td>
          <td>(</td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>halide_buffer_t_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that builds a struct containing all the externally referenced state. </p>
<p>Requires you to pass it a type and struct to fill in, a scope to retrieve the llvm values from and a builder to place the packing code. </p>

</div>
</div>
<a id="a0822c4fa8fbb5790406eb22d2d5849ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0822c4fa8fbb5790406eb22d2d5849ca">&#9670;&nbsp;</a></span>unpack_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::unpack_closure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that unpacks a struct containing all the externally referenced state into a symbol table. </p>
<p>Requires you to pass it a state struct type and value, a scope to fill, and a builder to place the unpacking code. </p>

</div>
</div>
<a id="a71f10140e29131153c3be98d2899b090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f10140e29131153c3be98d2899b090">&#9670;&nbsp;</a></span>llvm_type_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

</div>
</div>
<a id="ad99e3563cd430c42905e547bfb02082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99e3563cd430c42905e547bfb02082b">&#9670;&nbsp;</a></span>get_vector_num_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::get_vector_num_elements </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements in an llvm vector type, or return 1 if it's not a vector type. </p>

</div>
</div>
<a id="a1df32a68c28abfa75e1a5e397817a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df32a68c28abfa75e1a5e397817a674">&#9670;&nbsp;</a></span>get_vector_element_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::get_vector_element_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scalar type of an llvm vector type. </p>
<p>Returns the argument if it's not a vector type. </p>

</div>
</div>
<a id="a1915d1d0235eef96e4d9988a169a9f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1915d1d0235eef96e4d9988a169a9f7d">&#9670;&nbsp;</a></span>element_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::element_count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e666b9660ff646f788264bf2f08b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e666b9660ff646f788264bf2f08b95">&#9670;&nbsp;</a></span>get_vector_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::get_vector_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc60421b682a09ea4c4dcaaaa3e105e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc60421b682a09ea4c4dcaaaa3e105e2">&#9670;&nbsp;</a></span>function_takes_user_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::function_takes_user_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Which built-in functions require a user-context first argument? </p>

</div>
</div>
<a id="a4abe6b887804e86f403f0af16d5a2ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abe6b887804e86f403f0af16d5a2ba1">&#9670;&nbsp;</a></span>can_allocation_fit_on_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_allocation_fit_on_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False. </p>
<p>This routine asserts if size is non-positive. </p>

</div>
</div>
<a id="a14294d4d56333f9579e1cb083347df30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14294d4d56333f9579e1cb083347df30">&#9670;&nbsp;</a></span>long_div_mod_round_to_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::long_div_mod_round_to_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td>
          <td class="paramname"><em>max_abs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a {div/mod}_round_to_zero using binary long division for int/uint. </p>
<p>max_abs is the maximum absolute value of (a/b). Returns the pair {div_round_to_zero, mod_round_to_zero}. </p>

</div>
</div>
<a id="a38df81db6d9aef92f0b8132a6cbdbdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df81db6d9aef92f0b8132a6cbdbdd4">&#9670;&nbsp;</a></span>lower_int_uint_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_int_uint_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary. </p>
<p>Can introduce mulhi_shr and sorted_avg intrinsics as well as those from the lower_euclidean_ operation &ndash; div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="a3b44815561924377a690cf1d967bd19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b44815561924377a690cf1d967bd19f">&#9670;&nbsp;</a></span>lower_int_uint_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_int_uint_mod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, do constant optimizations and possibly call lower_euclidean_div/lower_euclidean_mod if necessary. </p>
<p>Can introduce mulhi_shr and sorted_avg intrinsics as well as those from the lower_euclidean_ operation &ndash; div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="ab7a4f18b650b23e1e6ed980d1feebcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a4f18b650b23e1e6ed980d1feebcf5">&#9670;&nbsp;</a></span>lower_euclidean_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="ae81d78fd7f3115750e17167ebf0fe920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d78fd7f3115750e17167ebf0fe920">&#9670;&nbsp;</a></span>lower_euclidean_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a id="a9ce06cce9e67778758fd7090bd991421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce06cce9e67778758fd7090bd991421">&#9670;&nbsp;</a></span>lower_signed_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_signed_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts. </p>

</div>
</div>
<a id="a2637f42ac63c862b5f2a279164d640d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2637f42ac63c862b5f2a279164d640d1">&#9670;&nbsp;</a></span>lower_signed_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_signed_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> shift operation with a signed shift amount (may be negative), define an equivalent expression using only shifts by unsigned amounts. </p>

</div>
</div>
<a id="a7a110889396502096d2b5e3995734ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a110889396502096d2b5e3995734ef6">&#9670;&nbsp;</a></span>lower_mux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_mux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *&#160;</td>
          <td class="paramname"><em>mux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a mux intrinsic to a select tree. </p>

</div>
</div>
<a id="a7b4fa94b1f3a877eb3387824c09df826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4fa94b1f3a877eb3387824c09df826">&#9670;&nbsp;</a></span>get_target_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mcpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mattrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, set llvm:TargetOptions, cpu and attr information. </p>

</div>
</div>
<a id="a1b16d175882e16f544bf4bf92ec931b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b16d175882e16f544bf4bf92ec931b5">&#9670;&nbsp;</a></span>clone_target_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::clone_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two llvm::Modules, clone target options from one to the other. </p>

</div>
</div>
<a id="af1e20aff45028d266f854487159df341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e20aff45028d266f854487159df341">&#9670;&nbsp;</a></span>make_target_machine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::TargetMachine&gt; Halide::Internal::make_target_machine </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, get or create an llvm:TargetMachine. </p>

</div>
</div>
<a id="a01e7008bc30f56a6cbfb69a120ccf0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e7008bc30f56a6cbfb69a120ccf0d0">&#9670;&nbsp;</a></span>set_function_attributes_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::set_function_attributes_for_target </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="a36fd598253847fcd510e32b107aeb2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fd598253847fcd510e32b107aeb2f3">&#9670;&nbsp;</a></span>embed_bitcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::embed_bitcode </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>halide_command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a copy of the llvm IR currently represented by the module as data in the __LLVM,__bitcode section. </p>
<p>Emulates clang's -fembed-bitcode flag and is useful to satisfy Apple's bitcode inclusion requirements. <br  />
 </p>

</div>
</div>
<a id="ab57913c1a65cd4c4a6ccb3aeef5cccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57913c1a65cd4c4a6ccb3aeef5cccef">&#9670;&nbsp;</a></span>new_CodeGen_Metal_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a>&gt; Halide::Internal::new_CodeGen_Metal_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeed8645ab46a91ec69efb386bf6f9fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed8645ab46a91ec69efb386bf6f9fec">&#9670;&nbsp;</a></span>new_CodeGen_OpenCL_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a>&gt; Halide::Internal::new_CodeGen_OpenCL_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd129afe2e75e5f434b573290cf50149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd129afe2e75e5f434b573290cf50149">&#9670;&nbsp;</a></span>new_CodeGen_OpenGLCompute_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a>&gt; Halide::Internal::new_CodeGen_OpenGLCompute_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1088b9db437ecb80a185a8250a6196a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1088b9db437ecb80a185a8250a6196a8">&#9670;&nbsp;</a></span>new_CodeGen_PTX_Dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a>&gt; Halide::Internal::new_CodeGen_PTX_Dev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a735759322b0f8490b0d550f4b10f4000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735759322b0f8490b0d550f4b10f4000">&#9670;&nbsp;</a></span>set_compiler_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a>&gt; Halide::Internal::set_compiler_logger </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> &gt;&#160;</td>
          <td class="paramname"><em>compiler_logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object, replacing any existing one. </p>
<p>It is legal to pass in a nullptr (which means "don't do any compiler logging"). Returns the previous <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> (if any). </p>

</div>
</div>
<a id="a58ba1f88f3490dd824db2fb31bbe6339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba1f88f3490dd824db2fb31bbe6339">&#9670;&nbsp;</a></span>get_compiler_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a>* Halide::Internal::get_compiler_logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently active <a class="el" href="class_halide_1_1_internal_1_1_compiler_logger.html">CompilerLogger</a> object. </p>
<p>If <a class="el" href="namespace_halide_1_1_internal.html#a735759322b0f8490b0d550f4b10f4000" title="Set the active CompilerLogger object, replacing any existing one.">set_compiler_logger()</a> has never been called, a nullptr implementation will be returned. Do not save the pointer returned! It is intended to be used for immediate calls only. </p>

</div>
</div>
<a id="a9170638fdb8e1cb975e1ff7fb561a560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9170638fdb8e1cb975e1ff7fb561a560">&#9670;&nbsp;</a></span>cplusplus_function_mangled_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::cplusplus_function_mangled_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mangled C++ name for a function. </p>
<p>The target parameter is used to decide on the C++ ABI/mangling style to use. </p>

</div>
</div>
<a id="a67d63fc361474a95f58c2839461cc7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d63fc361474a95f58c2839461cc7df">&#9670;&nbsp;</a></span>cplusplus_mangle_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cplusplus_mangle_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f2af44447b9269918e9d63d948ea8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2af44447b9269918e9d63d948ea8bd">&#9670;&nbsp;</a></span>common_subexpression_elimination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lift_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> an example of a such a case, see test/code_explosion.cpp</p>
<p>The last parameter determines whether all common subexpressions are lifted, or only those that the simplifier would not subsitute back in (e.g. addition of a constant). </p>

</div>
</div>
<a id="ac03dcb48bcb8e81238a1c6cfea195e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03dcb48bcb8e81238a1c6cfea195e1a">&#9670;&nbsp;</a></span>common_subexpression_elimination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lift_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a id="a88cbc086e9926046bdb9f4ade681111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cbc086e9926046bdb9f4ade681111a">&#9670;&nbsp;</a></span>cse_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cse_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab98f0a702bd775e67baed5bcd986ae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98f0a702bd775e67baed5bcd986ae27">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="a029791644c90ea7a194d58fc87ab41bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029791644c90ea7a194d58fc87ab41bf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> in a human readable format. </p>

</div>
</div>
<a id="a866d7f181b8a337d445a1df28de18384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d7f181b8a337d445a1df28de18384">&#9670;&nbsp;</a></span>debug_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::debug_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function.">LoweredFunc</a> that describe the target and arguments. </p>
<p>Mutates the given func. </p>

</div>
</div>
<a id="aaea2b563fa94726a65b596979b9d2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea2b563fa94726a65b596979b9d2f85">&#9670;&nbsp;</a></span>debug_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::debug_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a id="a949dd909bf5d0b5aadc590c5dd2a61d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949dd909bf5d0b5aadc590c5dd2a61d0">&#9670;&nbsp;</a></span>extract_odd_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_odd_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a id="ad52cdf2d45822985407927e4a553dbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52cdf2d45822985407927e4a553dbe8">&#9670;&nbsp;</a></span>extract_even_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_even_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a id="a24fea986b372b2a3932ae617ca62116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fea986b372b2a3932ae617ca62116d">&#9670;&nbsp;</a></span>extract_lane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_lane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a id="acba806ef5f80bcc7ad6905f7789906cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba806ef5f80bcc7ad6905f7789906cd">&#9670;&nbsp;</a></span>rewrite_interleavings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_interleavings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a id="a8dc1b0ff156c8b0ca5fd26956ee482a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc1b0ff156c8b0ca5fd26956ee482a9">&#9670;&nbsp;</a></span>deinterleave_vector_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::deinterleave_vector_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8d3c39b97b822e2c3e50a1c977441aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d3c39b97b822e2c3e50a1c977441aa">&#9670;&nbsp;</a></span>remove_let_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_let_definitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all let definitions of expr. </p>

</div>
</div>
<a id="a9ce9e5a21138e54d3b6ceb6e8d28b37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce9e5a21138e54d3b6ceb6e8d28b37a">&#9670;&nbsp;</a></span>gather_variables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variables' indices that expr depends on and are in the filter. </p>

</div>
</div>
<a id="a75348e972a1020930f674670a8a95673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75348e972a1020930f674670a8a95673">&#9670;&nbsp;</a></span>gather_variables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48cd0b2aa2de8bdaedec76acedad6fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd0b2aa2de8bdaedec76acedad6fed">&#9670;&nbsp;</a></span>gather_rvariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a>&gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab20174955742327f92120c99ab2d3bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20174955742327f92120c99ab2d3bed">&#9670;&nbsp;</a></span>gather_rvariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a>&gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b66032c9826d25bfa470c4c974081d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66032c9826d25bfa470c4c974081d5">&#9670;&nbsp;</a></span>add_let_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::add_let_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> necessary let expressions to expr. </p>

</div>
</div>
<a id="a8422615887974b7d347d7b069e592ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8422615887974b7d347d7b069e592ced">&#9670;&nbsp;</a></span>sort_expressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::sort_expressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topologically sort the expression graph expressed by expr. </p>

</div>
</div>
<a id="a723b068d50849e69fc7f255d5716ed72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723b068d50849e69fc7f255d5716ed72">&#9670;&nbsp;</a></span>inference_bounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bounds of funcs. </p>
<p>The bounds represent a conservative region that is used by the "consumers" of the function, except of itself. </p>

</div>
</div>
<a id="a45bf1fdad80911ade94da1a53f58f2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bf1fdad80911ade94da1a53f58f2a5">&#9670;&nbsp;</a></span>inference_bounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>output_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeff30be2f05a33246906cb93c5ef840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeff30be2f05a33246906cb93c5ef840">&#9670;&nbsp;</a></span>box_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; &gt; Halide::Internal::box_to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension.">Box</a> to vector of (min, extent) </p>

</div>
</div>
<a id="a44d062e9354cd14001f47cd01e82b93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d062e9354cd14001f47cd01e82b93a">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if bounds0 and bounds1 represent the same bounds. </p>

<p class="reference">Referenced by <a class="el" href="_associative_ops_table_8h_source.html#l00050">Halide::Internal::AssociativePattern::operator==()</a>, and <a class="el" href="_associativity_8h_source.html#l00072">Halide::Internal::AssociativeOp::Replacement::operator==()</a>.</p>

</div>
</div>
<a id="a9e35493cbdbaecbf87027d1b3474a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e35493cbdbaecbf87027d1b3474a5b8">&#9670;&nbsp;</a></span>vars_to_strings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::vars_to_strings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variable names. </p>

</div>
</div>
<a id="a96c20a455c5f2aed48623d012438b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c20a455c5f2aed48623d012438b99d">&#9670;&nbsp;</a></span>extract_rdom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> Halide::Internal::extract_rdom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reduction domain used by expr. </p>

</div>
</div>
<a id="ab3c553025a28a2d63ed43f8875bf4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c553025a28a2d63ed43f8875bf4c18">&#9670;&nbsp;</a></span>solve_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::solve_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expr is new_var == f(var), solve for var == g(new_var) if multiple new_var corresponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> </p>

</div>
</div>
<a id="ae6436cf62347fbab1ff9e413ec61caf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6436cf62347fbab1ff9e413ec61caf9">&#9670;&nbsp;</a></span>find_buffer_param_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a>&gt; Halide::Internal::find_buffer_param_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac07d22606b612c93b460aee695063291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07d22606b612c93b460aee695063291">&#9670;&nbsp;</a></span>find_implicit_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; Halide::Internal::find_implicit_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all implicit variables in expr. </p>

</div>
</div>
<a id="aea7c0a6c9d1ffb171d4343876021f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7c0a6c9d1ffb171d4343876021f604">&#9670;&nbsp;</a></span>substitute_rdom_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_rdom_predicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the variable. </p>
<p>Also replace all occurrences in rdom.where() predicates. </p>

</div>
</div>
<a id="a4b228248e212d4e140a3b7499f65a8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b228248e212d4e140a3b7499f65a8c4">&#9670;&nbsp;</a></span>is_calling_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr contains call to func_name. </p>

</div>
</div>
<a id="add1be017ee388aad7a1cb19fa653e300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1be017ee388aad7a1cb19fa653e300">&#9670;&nbsp;</a></span>is_calling_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr depends on any function or buffer. </p>

</div>
</div>
<a id="a038d35b4053c243832706da480e78f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038d35b4053c243832706da480e78f80">&#9670;&nbsp;</a></span>substitute_call_arg_with_pure_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_call_arg_with_pure_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>variable_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces call to <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f in <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e such that the call argument at variable_id is the pure argument. </p>

</div>
</div>
<a id="adb129e599eb08042ff95446b7e040233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb129e599eb08042ff95446b7e040233">&#9670;&nbsp;</a></span>make_device_interface_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_device_interface_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9">MemoryType</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespace_halide.html#af28f02315017283b26196866c92d4da9a06b9281e396db002010bde1de57262eb">MemoryType::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> which evaluates to the device interface for the given device api at runtime. </p>

</div>
</div>
<a id="a9a4af08fdc8caf03891015c7dec4c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4af08fdc8caf03891015c7dec4c8c9">&#9670;&nbsp;</a></span>inject_early_frees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_early_frees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> node. </p>

</div>
</div>
<a id="a371a9e04b6a14f9897b94bc78437023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371a9e04b6a14f9897b94bc78437023d">&#9670;&nbsp;</a></span>eliminate_bool_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a> node. This also converts any intrinsics that operate on vectorized conditions to a *_mask equivalent (if_then_else, require). Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a id="a6320940955c9bdcced50b4f31ddd3f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320940955c9bdcced50b4f31ddd3f18">&#9670;&nbsp;</a></span>eliminate_bool_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a> node. This also converts any intrinsics that operate on vectorized conditions to a *_mask equivalent (if_then_else, require). Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a id="a0747a9e54d0da5a37c1530162121942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0747a9e54d0da5a37c1530162121942f">&#9670;&nbsp;</a></span>eliminated_bool_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::eliminated_bool_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>bool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors. </p>

<p class="definition">Definition at line <a class="el" href="_eliminate_bool_vectors_8h_source.html#l00032">32</a> of file <a class="el" href="_eliminate_bool_vectors_8h_source.html">EliminateBoolVectors.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00331">Halide::Type::bits()</a>, <a class="el" href="_type_8h_source.html#l00277">Halide::Type::Int</a>, <a class="el" href="_type_8h_source.html#l00381">Halide::Type::is_vector()</a>, <a class="el" href="_type_8h_source.html#l00348">Halide::Type::with_bits()</a>, and <a class="el" href="_type_8h_source.html#l00342">Halide::Type::with_code()</a>.</p>

</div>
</div>
<a id="a860e1020025973b3e49f515e57e126d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e1020025973b3e49f515e57e126d5">&#9670;&nbsp;</a></span>is_float16_transcendental()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_float16_transcendental </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a call is a float16 transcendental (e.g. </p>
<p>sqrt_f16) </p>

</div>
</div>
<a id="a4cd9ff6cdf658b71397ad57ada686d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9ff6cdf658b71397ad57ada686d8f">&#9670;&nbsp;</a></span>lower_float16_transcendental_to_float32_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_float16_transcendental_to_float32_equivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement a float16 transcendental using the float32 equivalent. </p>

</div>
</div>
<a id="a7c0d9776355fa799b71816c0ab2e97e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d9776355fa799b71816c0ab2e97e6">&#9670;&nbsp;</a></span>float32_to_bfloat16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float32_to_bfloat16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> to/from float and bfloat using bitwise math. </p>

</div>
</div>
<a id="aa8bc1fe74ae6a148b8e7ee57f26c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bc1fe74ae6a148b8e7ee57f26c994d">&#9670;&nbsp;</a></span>float32_to_float16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float32_to_float16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386f43e07f78c9b4be57358b183150ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386f43e07f78c9b4be57358b183150ce">&#9670;&nbsp;</a></span>float16_to_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::float16_to_float32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfc4c96649e436c9f67531779788b077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc4c96649e436c9f67531779788b077">&#9670;&nbsp;</a></span>bfloat16_to_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::bfloat16_to_float32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79be785c18917d142a0fa55c86ab3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79be785c18917d142a0fa55c86ab3a87">&#9670;&nbsp;</a></span>lower_float16_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_float16_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63523f83489f292e9ac11d247dba7718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63523f83489f292e9ac11d247dba7718">&#9670;&nbsp;</a></span>ref_count&lt; IRNode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#abbc100b5bea312321ff79baff93ee558">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00115">115</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="ad3d80243a2f3de47f613df12b48475c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d80243a2f3de47f613df12b48475c3">&#9670;&nbsp;</a></span>destroy&lt; IRNode &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a11ca920b642ef490aeac2b4e864d6254">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00120">120</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a id="a89b46f80479d5e41ff7ebf80ced31267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b46f80479d5e41ff7ebf80ced31267">&#9670;&nbsp;</a></span>is_unordered_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_unordered_parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a>&#160;</td>
          <td class="paramname"><em>for_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if for_type executes for loop iterations in parallel and unordered. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_8h_source.html#l00732">Halide::Internal::For::is_unordered_parallel()</a>, and <a class="el" href="_schedule_8h_source.html#l00411">Halide::Internal::Dim::is_unordered_parallel()</a>.</p>

</div>
</div>
<a id="aa25b9bc3a80bac033c05e5178ab5a4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25b9bc3a80bac033c05e5178ab5a4c7">&#9670;&nbsp;</a></span>is_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a>&#160;</td>
          <td class="paramname"><em>for_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if for_type executes for loop iterations in parallel. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_8h_source.html#l00735">Halide::Internal::For::is_parallel()</a>, and <a class="el" href="_schedule_8h_source.html#l00419">Halide::Internal::Dim::is_parallel()</a>.</p>

</div>
</div>
<a id="a16792c0d67cebb47fe0a30377c3e7212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16792c0d67cebb47fe0a30377c3e7212">&#9670;&nbsp;</a></span>stmt_or_expr_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const StmtOrExpr &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00101">101</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00093">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

<p class="reference">Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00143">expr_uses_vars()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00153">stmt_uses_vars()</a>.</p>

</div>
</div>
<a id="a5d94fcb5a93f4d4ddc839dc3f7631e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d94fcb5a93f4d4ddc839dc3f7631e5e">&#9670;&nbsp;</a></span>stmt_or_expr_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">const StmtOrExpr &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement or expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00113">113</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_scope_8h_source.html#l00181">Halide::Internal::Scope&lt; T &gt;::push()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00124">expr_uses_var()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00133">stmt_uses_var()</a>.</p>

</div>
</div>
<a id="af734ee6c4861fe4be70badd557199d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af734ee6c4861fe4be70badd557199d84">&#9670;&nbsp;</a></span>expr_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00124">124</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00113">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a id="a0fdd19ef6ec57aee5d5bea413bed3452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdd19ef6ec57aee5d5bea413bed3452">&#9670;&nbsp;</a></span>stmt_uses_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00133">133</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a217ecb18a8f8e5f1889339c3fa093fc3">Halide::stmt</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00113">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a id="ae31bec6d9fdbb014d4e6b82549452065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31bec6d9fdbb014d4e6b82549452065">&#9670;&nbsp;</a></span>expr_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if an expression references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00143">143</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="_expr_uses_var_8h_source.html#l00101">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a id="a3d8bcd8e6cf2ad8368c7f106f5852f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8bcd8e6cf2ad8368c7f106f5852f1e">&#9670;&nbsp;</a></span>stmt_uses_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_vars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if a statement references or defines any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>'s in the scope provided in the final argument. </p>

<p class="definition">Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00153">153</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4a217ecb18a8f8e5f1889339c3fa093fc3">Halide::stmt</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00101">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a id="a16b42e90ad180f1254cdd3be0ae7be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b42e90ad180f1254cdd3be0ae7be89">&#9670;&nbsp;</a></span>find_direct_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_direct_calls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents. </p>
<p>This map <em>does not</em> include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a id="a770da2a7374eb2a8ac60f5c9d90b88ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770da2a7374eb2a8ac60f5c9d90b88ad">&#9670;&nbsp;</a></span>find_transitive_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_transitive_calls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always <em>includes</em> the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f. </p>

</div>
</div>
<a id="a896238d54e6f7d94171698d1c4296b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896238d54e6f7d94171698d1c4296b97">&#9670;&nbsp;</a></span>populate_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::populate_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all Functions transitively referenced by f in any way and add them to the given map. </p>

</div>
</div>
<a id="a543f298be9b8105946543dd390b374ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f298be9b8105946543dd390b374ff">&#9670;&nbsp;</a></span>lower_widening_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement intrinsics with non-intrinsic using equivalents. </p>

</div>
</div>
<a id="ab8ae1b99eee51f16210b3d97effc25bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ae1b99eee51f16210b3d97effc25bd">&#9670;&nbsp;</a></span>lower_widening_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaac43abd869f41381772e6bb7d2c6e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac43abd869f41381772e6bb7d2c6e5d">&#9670;&nbsp;</a></span>lower_widening_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49839698df68c878972d04abb2f0c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49839698df68c878972d04abb2f0c2e5">&#9670;&nbsp;</a></span>lower_widening_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72390cac65d124349c7e74677aa87167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72390cac65d124349c7e74677aa87167">&#9670;&nbsp;</a></span>lower_widening_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_widening_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1e70aeecd9a6473b07d533436feee25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e70aeecd9a6473b07d533436feee25">&#9670;&nbsp;</a></span>lower_rounding_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_shift_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c3c2f27463a8c2007fb94474a7d31e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3c2f27463a8c2007fb94474a7d31e6">&#9670;&nbsp;</a></span>lower_rounding_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_shift_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52903c4a764166671b47c1bee5972657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52903c4a764166671b47c1bee5972657">&#9670;&nbsp;</a></span>lower_saturating_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_saturating_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc65673b59449764669bf6424de17481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc65673b59449764669bf6424de17481">&#9670;&nbsp;</a></span>lower_saturating_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_saturating_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cb06df309ffae62a414ff80f298064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb06df309ffae62a414ff80f298064c">&#9670;&nbsp;</a></span>lower_halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_halving_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ab3fa4ef1d631a29d7440487960a6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab3fa4ef1d631a29d7440487960a6e1">&#9670;&nbsp;</a></span>lower_halving_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_halving_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a433d347c813cf72a9fff938583a277f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433d347c813cf72a9fff938583a277f0">&#9670;&nbsp;</a></span>lower_rounding_halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_halving_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cb95301fa111daaa29ab989cd1ce974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb95301fa111daaa29ab989cd1ce974">&#9670;&nbsp;</a></span>lower_rounding_halving_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_rounding_halving_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4767c0dccb944d87678d84e2eae8c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4767c0dccb944d87678d84e2eae8c7a">&#9670;&nbsp;</a></span>lower_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace one of the above ops with equivalent arithmetic. </p>

</div>
</div>
<a id="ab09931c2014b2d9371646a16e8f70040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09931c2014b2d9371646a16e8f70040">&#9670;&nbsp;</a></span>find_intrinsics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::find_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace common arithmetic patterns with intrinsics. </p>

</div>
</div>
<a id="ac549d8172be01dcee56b59f1b78801ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac549d8172be01dcee56b59f1b78801ef">&#9670;&nbsp;</a></span>find_intrinsics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a771bb6d2ec214f749b0c1b294d5c5a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771bb6d2ec214f749b0c1b294d5c5a90">&#9670;&nbsp;</a></span>lower_intrinsics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reverse of find_intrinsics. </p>

</div>
</div>
<a id="a24a93dc6272bd86b8d10c171d0c1e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a93dc6272bd86b8d10c171d0c1e26d">&#9670;&nbsp;</a></span>lower_intrinsics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_intrinsics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdf714a588746f3f1017dc77dad68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf714a588746f3f1017dc77dad68a67">&#9670;&nbsp;</a></span>flatten_nested_ramps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::flatten_nested_ramps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement/expression and replace nested ramps and broadcasts. </p>

</div>
</div>
<a id="a2729ffaedee0544f9b584f53bc91954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2729ffaedee0544f9b584f53bc91954b">&#9670;&nbsp;</a></span>flatten_nested_ramps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::flatten_nested_ramps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b98bf6f8f3475caaa691d7884a31d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b98bf6f8f3475caaa691d7884a31d45">&#9670;&nbsp;</a></span>check_types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02454">2454</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00015">user_assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02463">check_types()</a>, <a class="el" href="_func_8h_source.html#l02499">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02544">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="abec0560d55ceb7384483f00da38ad73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec0560d55ceb7384483f00da38ad73f">&#9670;&nbsp;</a></span>check_types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02463">2463</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02454">check_types()</a>.</p>

</div>
</div>
<a id="a32bce2836846aa0286859b005b6aa015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bce2836846aa0286859b005b6aa015">&#9670;&nbsp;</a></span>assign_results() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02469">2469</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02475">assign_results()</a>, <a class="el" href="_func_8h_source.html#l02499">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02544">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="acdc822256984ddc07c031b230ce2b8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc822256984ddc07c031b230ce2b8ae">&#9670;&nbsp;</a></span>assign_results() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02475">2475</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l02469">assign_results()</a>.</p>

</div>
</div>
<a id="a1f9bfb55aa0058e51d72037fde785fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9bfb55aa0058e51d72037fde785fb0">&#9670;&nbsp;</a></span>schedule_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::schedule_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l02510">2510</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">Halide::get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#ad622b7218b4a44fea6823cc0ae81c092">Halide::Func::gpu_single_thread()</a>, <a class="el" href="struct_halide_1_1_target.html#a512386389886e2fa0ec57383b0ed6af0">Halide::Target::has_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#a0907e311b4e669cbd108f650ec7d4e00">Halide::Func::hexagon()</a>, and <a class="el" href="_target_8h_source.html#l00096">Halide::Target::HVX</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02528">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a id="aad946e0645ead551baee06d6c39e6552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad946e0645ead551baee06d6c39e6552">&#9670;&nbsp;</a></span>deep_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt;, std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; &gt; Halide::Internal::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> DAG. </p>

</div>
</div>
<a id="a4235fdb540be5dde3f9942604be666f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235fdb540be5dde3f9942604be666f0">&#9670;&nbsp;</a></span>zero_gpu_loop_mins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::zero_gpu_loop_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all GPU loops to have a min of zero. </p>

</div>
</div>
<a id="a0081752824625e87b5e95bfae979499f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0081752824625e87b5e95bfae979499f">&#9670;&nbsp;</a></span>fuse_gpu_thread_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuse_gpu_thread_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Push if conditions between GPU blocks to the innermost GPU threads. Also injects synchronization points as needed, and hoists shared allocations at the block level out into a single shared memory array, and heap allocations into a slice of a global pool allocated outside the kernel. </p>

</div>
</div>
<a id="a5f235cf0feb61ceabb0ad10573d85f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f235cf0feb61ceabb0ad10573d85f84">&#9670;&nbsp;</a></span>fuzz_float_stores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuzz_float_stores </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On every store of a floating point value, mask off the least-significant-bit of the mantissa. </p>
<p>We've found that whether or not this dramatically changes the output of a pipeline correlates very well with whether or not a pipeline will produce very different outputs on different architectures (e.g. with and without FMA). It's also a useful way to detect bad tests, such as those that expect exact floating point equality across platforms. </p>

</div>
</div>
<a id="ac4be7daed1a8c6cd914be946f22ea4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4be7daed1a8c6cd914be946f22ea4df">&#9670;&nbsp;</a></span>generator_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::generator_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2672948a0299d09a067ec4dbb862723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2672948a0299d09a067ec4dbb862723">&#9670;&nbsp;</a></span>parameter_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::parameter_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b54f450e1cd03c240743907e45487ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b54f450e1cd03c240743907e45487ce">&#9670;&nbsp;</a></span>enum_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string Halide::Internal::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>enum_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00329">329</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00007">user_error</a>.</p>

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00872">Halide::Internal::GeneratorParam_Enum&lt; T &gt;::get_default_value()</a>, and <a class="el" href="_generator_8h_source.html#l00347">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a id="afd2308d89d4a9b9eef0803e92c383b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2308d89d4a9b9eef0803e92c383b0c">&#9670;&nbsp;</a></span>enum_from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::enum_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>enum_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00340">340</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00015">user_assert</a>.</p>

</div>
</div>
<a id="aebb90b52661557ff81407bc45cbdf3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb90b52661557ff81407bc45cbdf3e6">&#9670;&nbsp;</a></span>get_halide_type_enum_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&gt;&amp; Halide::Internal::get_halide_type_enum_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00347">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a id="a2cc7c793b324e02e15a109f1e8af548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc7c793b324e02e15a109f1e8af548c">&#9670;&nbsp;</a></span>halide_type_to_enum_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_enum_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l00347">347</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_generator_8h_source.html#l00329">enum_to_string()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">get_halide_type_enum_map()</a>.</p>

</div>
</div>
<a id="a600136fc73541f81f75ee07095a62025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600136fc73541f81f75ee07095a62025">&#9670;&nbsp;</a></span>halide_type_to_c_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l00917">Halide::Internal::GeneratorParam_Type&lt; T &gt;::get_default_value()</a>.</p>

</div>
</div>
<a id="a9e8f71298de4ece7dc2e59ae811c3fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8f71298de4ece7dc2e59ae811c3fd2">&#9670;&nbsp;</a></span>halide_type_to_c_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_generator_8h_source.html#l01657">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;::get_c_type()</a>, and <a class="el" href="_generator_8h_source.html#l02440">Halide::Internal::GeneratorOutput_Buffer&lt; T &gt;::get_c_type()</a>.</p>

</div>
</div>
<a id="ad032a99a32ca261c475b4335ece416dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032a99a32ca261c475b4335ece416dd">&#9670;&nbsp;</a></span>generate_filter_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a1288db81d996c1d930c57ec8031a6527">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation. </p>

</div>
</div>
<a id="ae47fa4b8f49636c214b214f5d0f4ed34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47fa4b8f49636c214b214f5d0f4ed34">&#9670;&nbsp;</a></span>parse_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::parse_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_generator_8h_source.html#l02706">2706</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p class="reference">References <a class="el" href="_errors_8h_source.html#l00015">user_assert</a>.</p>

</div>
</div>
<a id="a7682395f90f7229826df771f8c286fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7682395f90f7229826df771f8c286fac">&#9670;&nbsp;</a></span>parse_halide_type_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_type.html">Type</a>&gt; Halide::Internal::parse_halide_type_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8696c48228f0cb335255ae46954909e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8696c48228f0cb335255ae46954909e1">&#9670;&nbsp;</a></span>inject_hexagon_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_hexagon_rpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>host_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module. </p>

</div>
</div>
<a id="a55a0c1dd9c3f33e07eb6df7b59850286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a0c1dd9c3f33e07eb6df7b59850286">&#9670;&nbsp;</a></span>compile_module_to_hexagon_shared_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;<a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&gt; Halide::Internal::compile_module_to_hexagon_shared_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>device_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9944b3d2cbfb0262a46b72ec515ab130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9944b3d2cbfb0262a46b72ec515ab130">&#9670;&nbsp;</a></span>optimize_hexagon_shuffles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_shuffles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lut_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace indirect and other loads with simple loads + vlut calls. </p>

</div>
</div>
<a id="ad61e99863aa9fd2833e535440b632093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e99863aa9fd2833e535440b632093">&#9670;&nbsp;</a></span>scatter_gather_generator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::scatter_gather_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2278e803f98fc7b6e2b382ace8052975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2278e803f98fc7b6e2b382ace8052975">&#9670;&nbsp;</a></span>optimize_hexagon_instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_instructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations. </p>
<p>This pass rewrites widenings/narrowings to be explicit in the IR, and attempts to simplify away most of the interleaving/deinterleaving. </p>

</div>
</div>
<a id="a33a62ca468e067e12843e66cfa0fb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a62ca468e067e12843e66cfa0fb33d">&#9670;&nbsp;</a></span>native_deinterleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a id="ad90cfab6d9f71632c8e4b712c7c400e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90cfab6d9f71632c8e4b712c7c400e8">&#9670;&nbsp;</a></span>native_interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_interleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5ab59246b78ff782aceed334637e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5ab59246b78ff782aceed334637e4c">&#9670;&nbsp;</a></span>is_native_deinterleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa264f8cbd16a2062c62a731ef88a261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa264f8cbd16a2062c62a731ef88a261">&#9670;&nbsp;</a></span>is_native_interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_interleave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada5b91e32017e38df05ae28f39a8b78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5b91e32017e38df05ae28f39a8b78c">&#9670;&nbsp;</a></span>type_suffix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signed_variants</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6edb350d77a097d5b1dce8ba2a9890cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edb350d77a097d5b1dce8ba2a9890cf">&#9670;&nbsp;</a></span>type_suffix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signed_variants</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b52d96bb5a9b758cbaf557e35f4695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b52d96bb5a9b758cbaf557e35f4695">&#9670;&nbsp;</a></span>type_suffix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signed_variants</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d49ddfaea99d3ddf07425940e67dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d49ddfaea99d3ddf07425940e67dd0">&#9670;&nbsp;</a></span>type_suffix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::type_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>signed_variants</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af522a6ad40733cb252fc7547a8af7dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af522a6ad40733cb252fc7547a8af7dce">&#9670;&nbsp;</a></span>infer_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a>&gt; Halide::Internal::infer_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50f932b31fe791a7b2002b829c8e5364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f932b31fe791a7b2002b829c8e5364">&#9670;&nbsp;</a></span>call_extern_and_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::call_extern_and_assert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to call an extern function, and assert that it returns 0. </p>

</div>
</div>
<a id="a9fa15ced2f13142e6c4b5e5f4649aa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa15ced2f13142e6c4b5e5f4649aa15">&#9670;&nbsp;</a></span>inject_host_dev_buffer_copies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_host_dev_buffer_copies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed. </p>

</div>
</div>
<a id="a983e110a8277167d2764e231d1dbebf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e110a8277167d2764e231d1dbebf5">&#9670;&nbsp;</a></span>inline_function() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a id="a7114825936949569e0a72294236a775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7114825936949569e0a72294236a775c">&#9670;&nbsp;</a></span>inline_function() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a720ad50bc88a71450138fcec77b3b73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720ad50bc88a71450138fcec77b3b73c">&#9670;&nbsp;</a></span>inline_function() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6883343b90964967cb0bafb2551f5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6883343b90964967cb0bafb2551f5c3">&#9670;&nbsp;</a></span>validate_schedule_inlined_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::validate_schedule_inlined_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the schedule of an inlined function is legal, throwing an error if it is not. </p>

</div>
</div>
<a id="abbc100b5bea312321ff79baff93ee558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc100b5bea312321ff79baff93ee558">&#9670;&nbsp;</a></span>ref_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; Halide::Internal::ref_count </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) noexcept {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a id="a11ca920b642ef490aeac2b4e864d6254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca920b642ef490aeac2b4e864d6254">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::destroy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1074fbd76b40a9cc210fbd22fdcda914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1074fbd76b40a9cc210fbd22fdcda914">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a7addfa445fa68c6e196b581749fa5857">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a id="a705ef4763a82b7907112099a01604d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705ef4763a82b7907112099a01604d0d">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fad2884f65d9bbb20c6cdcc65e08d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fad2884f65d9bbb20c6cdcc65e08d47">&#9670;&nbsp;</a></span>graph_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b5e9d7137c035d913570030d474bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b5e9d7137c035d913570030d474bac">&#9670;&nbsp;</a></span>graph_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac59065f04bcf4e664007d95affa7ce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59065f04bcf4e664007d95affa7ce3f">&#9670;&nbsp;</a></span>ir_equality_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ir_equality_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad10452d8940fd9d44b657a915b7cea42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10452d8940fd9d44b657a915b7cea42">&#9670;&nbsp;</a></span>expr_match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p>Wildcards require the types to match. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the type bits and width, a 0 indicates "match anything". So an Int(8, 0) will match 8-bit integer vectors of any width (including scalars), and a UInt(0, 0) will match any unsigned integer type.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p><div class="fragment"><div class="line">Expr x = <a class="code" href="struct_halide_1_1_internal_1_1_variable.html#abf38bc7c87ec8fdc8dabad8eebf2939c">Variable::make</a>(<a class="code" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);</div>
<div class="line">match(x + x, 3 + (2*k), result)</div>
<div class="ttc" id="anamespace_halide_html_a70a0c034814a65d55bb848fe9c96653b"><div class="ttname"><a href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Halide::Int</a></div><div class="ttdeci">Type Int(int bits, int lanes=1)</div><div class="ttdoc">Constructing a signed integer type.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8h_source.html#l00498">Type.h:498</a></div></div>
<div class="ttc" id="astruct_halide_1_1_internal_1_1_variable_html_abf38bc7c87ec8fdc8dabad8eebf2939c"><div class="ttname"><a href="struct_halide_1_1_internal_1_1_variable.html#abf38bc7c87ec8fdc8dabad8eebf2939c">Halide::Internal::Variable::make</a></div><div class="ttdeci">static Expr make(Type type, const std::string &amp;name)</div><div class="ttdef"><b>Definition:</b> <a href="_i_r_8h_source.html#l00689">IR.h:689</a></div></div>
</div><!-- fragment --><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a id="ad8d77cbd158befc1b58416319609f313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d77cbd158befc1b58416319609f313">&#9670;&nbsp;</a></span>expr_match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables are matched consistently. </p>
<p>The first time a variable is matched, it assumes the value of the matching part of the second expression. Subsequent matches must be equal to the first match.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p><div class="fragment"><div class="line">Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">match(x*(x + y), a*(a + b), result)</div>
</div><!-- fragment --><p> should return true, and set result["x"] = a, and result["y"] = b. </p>

</div>
</div>
<a id="a1eed932bc0eb3a15edcb20795bfb8c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eed932bc0eb3a15edcb20795bfb8c2f">&#9670;&nbsp;</a></span>expr_match_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::expr_match_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5923637d87db593d1e24b088bbe6fa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5923637d87db593d1e24b088bbe6fa5c">&#9670;&nbsp;</a></span>mutate_region()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a>, bool&gt; Halide::Internal::mutate_region </td>
          <td>(</td>
          <td class="paramtype">Mutator *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#adac6d1605235bf518c12a05ed6850d43">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function for mutator-like things to mutate regions. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_mutator_8h_source.html#l00109">109</a> of file <a class="el" href="_i_r_mutator_8h_source.html">IRMutator.h</a>.</p>

<p class="reference">References <a class="el" href="_intrusive_ptr_8h_source.html#l00168">Halide::Internal::IntrusivePtr&lt; T &gt;::same_as()</a>.</p>

</div>
</div>
<a id="af11d0eaaf5222de9d1151bf81479beb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d0eaaf5222de9d1151bf81479beb9">&#9670;&nbsp;</a></span>is_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants.">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

</div>
</div>
<a id="ad0438766d0040aa39c5f420f1a92b01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0438766d0040aa39c5f420f1a92b01b">&#9670;&nbsp;</a></span>is_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>

</div>
</div>
<a id="a98f803a9899cc2d96a93179dba4bf21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f803a9899cc2d96a93179dba4bf21f">&#9670;&nbsp;</a></span>as_const_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>* Halide::Internal::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

</div>
</div>
<a id="ae2c472a5cc4013b179510625b02bf6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c472a5cc4013b179510625b02bf6d6">&#9670;&nbsp;</a></span>as_const_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>* Halide::Internal::as_const_uint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

</div>
</div>
<a id="a6252d95fc57aad0465caf882eded56bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6252d95fc57aad0465caf882eded56bb">&#9670;&nbsp;</a></span>as_const_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* Halide::Internal::as_const_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

</div>
</div>
<a id="aa5f2b30c213250c3ba20c4d211f5b00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f2b30c213250c3ba20c4d211f5b00f">&#9670;&nbsp;</a></span>is_const_power_of_two_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. Only returns true for integer types. </p>

</div>
</div>
<a id="a5f26b6233cff17bdbf097bfe981e096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f26b6233cff17bdbf097bfe981e096c">&#9670;&nbsp;</a></span>is_positive_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a id="a0e57c1aaa1719ed42fac6dc6661ebe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e57c1aaa1719ed42fac6dc6661ebe90">&#9670;&nbsp;</a></span>is_negative_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a id="a0eb4bb1c7164222794e270f58c428eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb4bb1c7164222794e270f58c428eb7">&#9670;&nbsp;</a></span>is_undef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_undef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an undef. </p>

</div>
</div>
<a id="a0490ee622445eeba11163a7a936177d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0490ee622445eeba11163a7a936177d7">&#9670;&nbsp;</a></span>is_const_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01903">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::match()</a>.</p>

</div>
</div>
<a id="a3534f733e8b7b7c617fd03714ccca697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3534f733e8b7b7c617fd03714ccca697">&#9670;&nbsp;</a></span>is_const_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02202">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;::make_folded_const()</a>.</p>

</div>
</div>
<a id="a916dccb9f4ad5763ce86721ab3187cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916dccb9f4ad5763ce86721ab3187cfc">&#9670;&nbsp;</a></span>is_no_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> node of a constant) </p>

</div>
</div>
<a id="a8325254f314a3811cc5ebebf4497466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8325254f314a3811cc5ebebf4497466d">&#9670;&nbsp;</a></span>is_pure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_pure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, and 2) Evaluating it has no side-effects. </p>

</div>
</div>
<a id="a5a057ef6ceb8462dbca18eb9020bc297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a057ef6ceb8462dbca18eb9020bc297">&#9670;&nbsp;</a></span>make_const() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l02460">Halide::Internal::IRMatcher::fuzz_test_rule()</a>, <a class="el" href="_i_r_match_8h_source.html#l00563">Halide::Internal::IRMatcher::IntLiteral::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00078">make_const()</a>, <a class="el" href="_generator_8h_source.html#l00518">Halide::Internal::GeneratorParamImpl&lt; T &gt;::operator Expr()</a>, and <a class="el" href="_i_r_match_8h_source.html#l02680">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;::operator()()</a>.</p>

</div>
</div>
<a id="a69927d11c0fe7c6cf4092a811f6676d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69927d11c0fe7c6cf4092a811f6676d7">&#9670;&nbsp;</a></span>make_const() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3a72bc2d5b95e6a43e803a9f7c4acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a72bc2d5b95e6a43e803a9f7c4acea">&#9670;&nbsp;</a></span>make_const() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae8ca905f0ce9cde74cc0897a61c4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae8ca905f0ce9cde74cc0897a61c4e7">&#9670;&nbsp;</a></span>make_const() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00078">78</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a70b64c00a450c92807011cdc02f8b29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b64c00a450c92807011cdc02f8b29b">&#9670;&nbsp;</a></span>make_const() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00081">81</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a4df9ef655a78f9fb233fa0322525496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df9ef655a78f9fb233fa0322525496c">&#9670;&nbsp;</a></span>make_const() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00084">84</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="af14e2dade91eb04482b4b5ffdfc920dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14e2dade91eb04482b4b5ffdfc920dd">&#9670;&nbsp;</a></span>make_const() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00087">87</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a5231b80b8e1a7904cdd4fcac7b89a98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5231b80b8e1a7904cdd4fcac7b89a98d">&#9670;&nbsp;</a></span>make_const() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00090">90</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="ae9a1ece36d20a64a59c92bf7f8c4e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">&#9670;&nbsp;</a></span>make_const() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00093">93</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="addbd965eccbcfc1f5b80eaa0607f698c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbd965eccbcfc1f5b80eaa0607f698c">&#9670;&nbsp;</a></span>make_const() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00096">96</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="aa90929bcfb18413ffd527152bb8580de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90929bcfb18413ffd527152bb8580de">&#9670;&nbsp;</a></span>make_const() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00099">99</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="a6592ef00a06a1d8f017b48359099c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592ef00a06a1d8f017b48359099c16d">&#9670;&nbsp;</a></span>make_const() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1float16__t.html">float16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00102">102</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a id="aee83b2e74ffd9ee144d046aebbf87cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee83b2e74ffd9ee144d046aebbf87cca">&#9670;&nbsp;</a></span>make_signed_integer_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_signed_integer_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a unique signed_integer_overflow <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00145">Halide::Internal::IRMatcher::make_const_special_expr()</a>.</p>

</div>
</div>
<a id="a2de10096d923cdc0f02582981b718854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de10096d923cdc0f02582981b718854">&#9670;&nbsp;</a></span>check_representable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_representable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a constant value can be correctly represented as the given type. </p>

</div>
</div>
<a id="ace2aa7992959c35ebe5895999b762b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2aa7992959c35ebe5895999b762b34">&#9670;&nbsp;</a></span>make_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_bool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a id="a0e4b9c03c76d9a19a0d7a7de2036f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4b9c03c76d9a19a0d7a7de2036f1b6">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01918">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::make()</a>.</p>

</div>
</div>
<a id="a01e5ab6b1524fd81132823c77c35d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e5ab6b1524fd81132823c77c35d717">&#9670;&nbsp;</a></span>make_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of one in the given type. </p>

</div>
</div>
<a id="a14bdd8230cefd6bf9f84ac909311d87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bdd8230cefd6bf9f84ac909311d87e">&#9670;&nbsp;</a></span>make_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_two </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a id="a5fb413640f7f46493733fa33d95ea9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb413640f7f46493733fa33d95ea9fc">&#9670;&nbsp;</a></span>const_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a lanes argument is given. </p>

</div>
</div>
<a id="ab94c84e726218144cf4c5d3a08b38f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94c84e726218144cf4c5d3a08b38f8d">&#9670;&nbsp;</a></span>const_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a lanes argument is given. </p>

</div>
</div>
<a id="ae1e5b44f4f584318f9065bcf39c75c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e5b44f4f584318f9065bcf39c75c84">&#9670;&nbsp;</a></span>lossless_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cast an expression to a smaller type while provably not losing information. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

</div>
</div>
<a id="aa626e40f7f540859a774c59d38a673bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa626e40f7f540859a774c59d38a673bd">&#9670;&nbsp;</a></span>lossless_negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_negate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to negate x without introducing new IR and without overflow. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

</div>
</div>
<a id="a365bfad96972abe9e008bb1b601223f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365bfad96972abe9e008bb1b601223f9">&#9670;&nbsp;</a></span>match_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::match_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

</div>
</div>
<a id="addfdcef00b83af48e34920fd58d1da84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfdcef00b83af48e34920fd58d1da84">&#9670;&nbsp;</a></span>match_types_bitwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::match_types_bitwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that both expressions are integer types and are either both signed or both unsigned. </p>
<p>If one argument is scalar and the other a vector, the scalar is broadcasted to have the same number of lanes as the vector. If one expression is of narrower type than the other, it is widened to the bit width of the wider. </p>

</div>
</div>
<a id="a81818fbb02804a8e8f9056a0a24e0f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81818fbb02804a8e8f9056a0a24e0f56">&#9670;&nbsp;</a></span>halide_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a id="a4f176922ae87268701a0234b48ead883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f176922ae87268701a0234b48ead883">&#9670;&nbsp;</a></span>halide_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30907ab1fd2dfde808351ed05d262548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30907ab1fd2dfde808351ed05d262548">&#9670;&nbsp;</a></span>halide_erf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec662f503947166115071493eaa00780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec662f503947166115071493eaa00780">&#9670;&nbsp;</a></span>raise_to_integer_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::raise_to_integer_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

</div>
</div>
<a id="a839473cf858ba53326b678db072411d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839473cf858ba53326b678db072411d2">&#9670;&nbsp;</a></span>split_into_ands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_into_ands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs. </p>
<p>If 'cond' is undefined, return an empty vector. </p>

</div>
</div>
<a id="aa6f512f02bfc12c8a4d1d87ab77bc0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f512f02bfc12c8a4d1d87ab77bc0b6">&#9670;&nbsp;</a></span>strided_ramp_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::strided_ramp_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If e is a ramp expression with stride, default 1, return the base, otherwise undefined. </p>

</div>
</div>
<a id="a6cd3908859c82249a2c7f10158883a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd3908859c82249a2c7f10158883a97">&#9670;&nbsp;</a></span>mod_imp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::mod_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code when b != 0, (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode</p>
<p>Additionally, mod by zero returns zero, and div by zero returns zero. This makes mod and div total functions. </p>

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00236">236</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00394">Halide::Type::is_float()</a>, and <a class="el" href="_type_8h_source.html#l00406">Halide::Type::is_int()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01092">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;()</a>, and <a class="el" href="_simplify___internal_8h_source.html#l00044">Halide::Internal::Simplify::ExprInfo::trim_bounds_using_alignment()</a>.</p>

</div>
</div>
<a id="a0442f9a0450f45683938a69ce0273974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0442f9a0450f45683938a69ce0273974">&#9670;&nbsp;</a></span>div_imp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::div_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00257">257</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00394">Halide::Type::is_float()</a>, and <a class="el" href="_type_8h_source.html#l00406">Halide::Type::is_int()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01063">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;()</a>.</p>

</div>
</div>
<a id="adff5495089b812474881ee939c4701c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff5495089b812474881ee939c4701c4">&#9670;&nbsp;</a></span>mod_imp&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00282">282</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="ac9a60708c880da445554b8eeb778c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a60708c880da445554b8eeb778c034">&#9670;&nbsp;</a></span>mod_imp&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00288">288</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">Halide::floor()</a>.</p>

</div>
</div>
<a id="aa13a82f37fe6336c154122f66d294523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13a82f37fe6336c154122f66d294523">&#9670;&nbsp;</a></span>div_imp&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00294">294</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="a3965c871f086a60fda2cc31e678d050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965c871f086a60fda2cc31e678d050a">&#9670;&nbsp;</a></span>div_imp&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00298">298</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

</div>
</div>
<a id="af7df709582bdb9d7844efa9cd6b69625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7df709582bdb9d7844efa9cd6b69625">&#9670;&nbsp;</a></span>remove_likelies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_likelies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed. </p>

</div>
</div>
<a id="a1bcf82ffcc64c0c61b7cb7fc6ac7c916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">&#9670;&nbsp;</a></span>remove_likelies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_likelies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed. </p>

</div>
</div>
<a id="acf7ed2ca593eca53111eaf753a7fc9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7ed2ca593eca53111eaf753a7fc9bf">&#9670;&nbsp;</a></span>collect_print_args() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00311">311</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_pipeline_8h_source.html#l00567">Halide::Pipeline::add_requirement()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00315">collect_print_args()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01247">Halide::print()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01260">Halide::print_when()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01293">Halide::require()</a>.</p>

</div>
</div>
<a id="a4d7c2f51029190ae224290688b7c4c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c2f51029190ae224290688b7c4c3b">&#9670;&nbsp;</a></span>collect_print_args() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00315">315</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00311">collect_print_args()</a>.</p>

</div>
</div>
<a id="adda140fdf727dfa11f6f3151fc4f7661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda140fdf727dfa11f6f3151fc4f7661">&#9670;&nbsp;</a></span>collect_print_args() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00321">321</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p class="reference">References <a class="el" href="_i_r_operator_8h_source.html#l00311">collect_print_args()</a>.</p>

</div>
</div>
<a id="a12da582526c949b1bd11ede8f20bce2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da582526c949b1bd11ede8f20bce2e">&#9670;&nbsp;</a></span>requirement_failed_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::requirement_failed_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a082d3bda0d60128ae127d0879e7e38c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082d3bda0d60128ae127d0879e7e38c9">&#9670;&nbsp;</a></span>memoize_tag_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::memoize_tag_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache_key_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01353">Halide::memoize_tag()</a>.</p>

</div>
</div>
<a id="a75f4cdf56ac6f31a5f0870b66e3743e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f4cdf56ac6f31a5f0870b66e3743e9">&#9670;&nbsp;</a></span>widening_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::widening_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute widen(a) + widen(b). </p>
<p>The result is always signed. </p>

</div>
</div>
<a id="aa64fcd8d11f7e4bdf153ff760c73c46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64fcd8d11f7e4bdf153ff760c73c46b">&#9670;&nbsp;</a></span>widening_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::widening_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute widen(a) * widen(b). </p>
<p>a and b may have different signedness. </p>

</div>
</div>
<a id="a6f14f11164b1390669a9ce151b57a3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f14f11164b1390669a9ce151b57a3af">&#9670;&nbsp;</a></span>widening_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::widening_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute widen(a) - widen(b). </p>
<p>The result is always signed. </p>

</div>
</div>
<a id="a4eb6ea1b5e17d86b611b69e97f9bbd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb6ea1b5e17d86b611b69e97f9bbd18">&#9670;&nbsp;</a></span>widening_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::widening_shift_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute widen(a) &lt;&lt; b. </p>

</div>
</div>
<a id="a3d54b8b13cf47de21ea8005decd03a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d54b8b13cf47de21ea8005decd03a14">&#9670;&nbsp;</a></span>widening_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::widening_shift_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute widen(a) &gt;&gt; b. </p>

</div>
</div>
<a id="abd47ddc60a5b16ebf7e68ae1ba2ba483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd47ddc60a5b16ebf7e68ae1ba2ba483">&#9670;&nbsp;</a></span>rounding_shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::rounding_shift_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute saturating_add(a, (1 &gt;&gt; min(b, 0)) / 2) &lt;&lt; b. </p>
<p>When b is positive indicating a left shift, the rounding term is zero. </p>

</div>
</div>
<a id="a3d761851379580a9605f799491f933f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d761851379580a9605f799491f933f7">&#9670;&nbsp;</a></span>rounding_shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::rounding_shift_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute saturating_add(a, (1 &lt;&lt; max(b, 0)) / 2) &gt;&gt; b. </p>
<p>When b is negative indicating a left shift, the rounding term is zero. </p>

</div>
</div>
<a id="ad6b125d7fefcbcf2962d41efd87248be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b125d7fefcbcf2962d41efd87248be">&#9670;&nbsp;</a></span>saturating_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::saturating_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute saturating_narrow(widen(a) + widen(b)) </p>

</div>
</div>
<a id="a55ad280ea975ec61eeb27cb27c4f4024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ad280ea975ec61eeb27cb27c4f4024">&#9670;&nbsp;</a></span>saturating_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::saturating_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute saturating_narrow(widen(a) - widen(b)) </p>

</div>
</div>
<a id="ae31db44d292fd0875a78d40831feb81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31db44d292fd0875a78d40831feb81c">&#9670;&nbsp;</a></span>halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halving_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute narrow((widen(a) + widen(b)) / 2) </p>

</div>
</div>
<a id="a17b5151e7b54f3743f35b0d1fe2a1112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b5151e7b54f3743f35b0d1fe2a1112">&#9670;&nbsp;</a></span>rounding_halving_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::rounding_halving_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute narrow((widen(a) + widen(b) + 1) / 2) </p>

</div>
</div>
<a id="a3e3170f0ecff7b28a97b8f959879ddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3170f0ecff7b28a97b8f959879ddf5">&#9670;&nbsp;</a></span>halving_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halving_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute narrow((widen(a) - widen(b)) / 2) </p>

</div>
</div>
<a id="a992108a27232a3ccdf771112a4a296a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992108a27232a3ccdf771112a4a296a0">&#9670;&nbsp;</a></span>rounding_halving_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::rounding_halving_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute narrow((widen(a) - widen(b) + 1) / 2) </p>

</div>
</div>
<a id="a90683a918dfa5840b97406468fef7501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90683a918dfa5840b97406468fef7501">&#9670;&nbsp;</a></span>promise_clamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::promise_clamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FOR INTERNAL USE ONLY. </p>
<p>An entirely unchecked version of unsafe_promise_clamped, used inside the compiler as an annotation of the known bounds of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> when it has proved something is bounded and wants to record that fact for later passes (notably bounds inference) to exploit. This gets introduced by GuardWithIf tail strategies, because the bounds machinery has a hard time exploiting if statement conditions.</p>
<p>Unlike unsafe_promise_clamped, this expression is context-dependent, because 'value' might be statically bounded at some point in the IR (e.g. due to a containing if statement), but not elsewhere. </p>

</div>
</div>
<a id="a83fe20393021d437778c0587afbc448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fe20393021d437778c0587afbc448d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="a4e3b530e690cbe977d889e0931f8933d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3b530e690cbe977d889e0931f8933d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative op on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a id="a10cfea8acb4f311a9365e26a8f7de08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cfea8acb4f311a9365e26a8f7de08f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a id="aa0ff27763f50a990f499b422efc0c98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ff27763f50a990f499b422efc0c98b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_vector_reduce.html#ac69e8c35807dae662432c7964ae77f27">VectorReduce::Operator</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a horizontal vector reduction op in human-readable form. </p>

</div>
</div>
<a id="a6e1f893faca900eef051b7c0c182fde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1f893faca900eef051b7c0c182fde5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide name mangling value in a human readable format. </p>

</div>
</div>
<a id="a6f77f82c9290637ca0b5497f73a8f555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f77f82c9290637ca0b5497f73a8f555">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide linkage value in a human readable format. </p>

</div>
</div>
<a id="a479bae94ae224d9d9180902627032a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479bae94ae224d9d9180902627032a1b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#a5b8c72fcb8800b47e313c62f5416a4fe">DimType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide dimension type in human-readable format. </p>

</div>
</div>
<a id="a5168ee834a75949ecfb1f42d9cf54237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5168ee834a75949ecfb1f42d9cf54237">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_indentation.html">Indentation</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24ff2ba5a5794278afa0730aba7ff46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ff2ba5a5794278afa0730aba7ff46e">&#9670;&nbsp;</a></span>get_symbol_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Halide::Internal::get_symbol_address </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3ff6486a4d026c4a3a2813620d33328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ff6486a4d026c4a3a2813620d33328">&#9670;&nbsp;</a></span>lower_lerp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a id="a4933314cbff0bf637e348d5efc0a1499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4933314cbff0bf637e348d5efc0a1499">&#9670;&nbsp;</a></span>hoist_loop_invariant_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::hoist_loop_invariant_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariants out of inner loops. </p>
<p>This is especially important in cases where LLVM would not do it for us automatically. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it hoists loop invariants out of cuda kernels. </p>

</div>
</div>
<a id="a3de2b04122d0ac7aba914d93c97b2589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2b04122d0ac7aba914d93c97b2589">&#9670;&nbsp;</a></span>hoist_loop_invariant_if_statements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::hoist_loop_invariant_if_statements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just hoist loop-invariant if statements as far up as possible. </p>
<p>Does not lift other values. It's useful to run this earlier in lowering to simplify the IR. </p>

</div>
</div>
<a id="a6e9d2c57ff18ef709b6a4e444f4af5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9d2c57ff18ef709b6a4e444f4af5ff">&#9670;&nbsp;</a></span>iterator_to_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::iterator_to_pointer </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> -&gt; decltype(&amp;*std::declval&lt;T&gt;()) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00105">105</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="a880810f84064e696c65e574223e8170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880810f84064e696c65e574223e8170a">&#9670;&nbsp;</a></span>get_llvm_function_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_llvm_function_name </td>
          <td>(</td>
          <td class="paramtype">const llvm::Function *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00109">109</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="ae2e2fec06de5b48f541b7a7b18d7bfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e2fec06de5b48f541b7a7b18d7bfb1">&#9670;&nbsp;</a></span>get_llvm_function_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_llvm_function_name </td>
          <td>(</td>
          <td class="paramtype">const llvm::Function &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00117">117</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="ab26aedcbbf9449fa19edd76ad289ff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26aedcbbf9449fa19edd76ad289ff26">&#9670;&nbsp;</a></span>get_llvm_struct_type_by_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType* Halide::Internal::get_llvm_struct_type_by_name </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00125">125</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a id="a496ad11988df981c987a2557c3cd2d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496ad11988df981c987a2557c3cd2d8c">&#9670;&nbsp;</a></span>get_triple_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Triple Halide::Internal::get_triple_for_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a>. </p>

</div>
</div>
<a id="a30b2ac324e660b73262abdb4b0643451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b2ac324e660b73262abdb4b0643451">&#9670;&nbsp;</a></span>get_initial_module_for_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_shared_jit_runtime</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_gpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a id="a9e77b70f4bfb715115d8c3a690b2faa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e77b70f4bfb715115d8c3a690b2faa0">&#9670;&nbsp;</a></span>get_initial_module_for_ptx_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_ptx_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a id="af5c2253813b438bcb811778d84b98e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c2253813b438bcb811778d84b98e94">&#9670;&nbsp;</a></span>add_bitcode_to_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::add_bitcode_to_module </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a block of llvm bitcode into an llvm module. </p>

</div>
</div>
<a id="adcb7795a6245d98b4acbda63678d436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb7795a6245d98b4acbda63678d436e">&#9670;&nbsp;</a></span>link_with_wasm_jit_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::link_with_wasm_jit_runtime </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>extra_module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the llvm::Module(s) in extra_modules (if any), add the runtime modules needed for the WASM JIT, and link into a single llvm::Module. </p>

</div>
</div>
<a id="a1fc91c3863b2f3b6afe3902a717ff68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc91c3863b2f3b6afe3902a717ff68b">&#9670;&nbsp;</a></span>loop_carry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::loop_carry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_carried_values</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load. </p>
<p>If the loads are predicated, the predicates need to match. Can be an optimization or pessimization depending on how good the L1 cache is on the architecture and how many memory issue slots there are. Currently only intended for Hexagon. </p>

</div>
</div>
<a id="a3120dac0bea3e48403dd0d63420e929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3120dac0bea3e48403dd0d63420e929c">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_module.html">Module</a> Halide::Internal::lower </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a>&#160;</td>
          <td class="paramname"><em>linkage_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requirements</em> = <code>std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trace_pipeline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a>&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. The <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> may contain submodules for computation offloaded to another execution engine or API as well as buffers that are used in the passed in <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>. </p>

</div>
</div>
<a id="aa6912ab26d3b04864d43af52502ebeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6912ab26d3b04864d43af52502ebeb7">&#9670;&nbsp;</a></span>lower_main_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_main_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requirements</em> = <code>std::vector&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trace_pipeline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a>&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. Mostly used as a convenience function in tests that wish to assert some property of the lowered IR. </p>

</div>
</div>
<a id="a4d3bfe43201bab68cf4820993fe1469b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3bfe43201bab68cf4820993fe1469b">&#9670;&nbsp;</a></span>lower_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fa573630ec30c63bc99cd46a4217cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa573630ec30c63bc99cd46a4217cbb">&#9670;&nbsp;</a></span>lower_warp_shuffles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_warp_shuffles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions. </p>

</div>
</div>
<a id="a6a57c1db8b5f97b8003a5271907bfdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a57c1db8b5f97b8003a5271907bfdda">&#9670;&nbsp;</a></span>define_matlab_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* Halide::Internal::define_matlab_wrapper </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>pipeline_argv_wrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>metadata_getter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name. </p>
<p>Returns the mexFunction definition. </p>

</div>
</div>
<a id="ac66d64dd9cb646535816aff25b0d38ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66d64dd9cb646535816aff25b0d38ad">&#9670;&nbsp;</a></span>inject_memoization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_memoization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache. </p>
<p>Should leave non-memoized Funcs unchanged. </p>

</div>
</div>
<a id="af597feabae6ec97802ee2f800667a0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af597feabae6ec97802ee2f800667a0f7">&#9670;&nbsp;</a></span>rewrite_memoized_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_memoized_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be called after Storage Flattening has added Allocation IR nodes. </p>
<p>It connects the memoization cache lookups to the Allocations so they point to the buffers from the memoization cache and those buffers are released when no longer used. Should not affect allocations for non-memoized Funcs. </p>

</div>
</div>
<a id="a484b5563138a3637d88adc3942494a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484b5563138a3637d88adc3942494a99">&#9670;&nbsp;</a></span>get_output_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespace_halide.html#afdb8b92dac95804211c0a875302da5f4">Output</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_output_info.html">OutputInfo</a>&gt; Halide::Internal::get_output_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4287e047c221ec0bd503eca610e59cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287e047c221ec0bd503eca610e59cd1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade4ed3e58311ee5699c067d4a6c53c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4ed3e58311ee5699c067d4a6c53c2d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fc51636317f397ae70e341f81805f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc51636317f397ae70e341f81805f8e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26d56ea77b1fc65e72abc6025d15e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d56ea77b1fc65e72abc6025d15e2e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42bc141be36f0586ef2dd5080befce47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc141be36f0586ef2dd5080befce47">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad920f0d7b02a7331b8211d84e3f10208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad920f0d7b02a7331b8211d84e3f10208">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f39c3da5f8430464ac63973af1737ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f39c3da5f8430464ac63973af1737ae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e40311152e94d1bf520fa0a8eadafa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e40311152e94d1bf520fa0a8eadafa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad30409f49c922a7b536de49b50abfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad30409f49c922a7b536de49b50abfa">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5bf538dd23287f4a506afbe601b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5bf538dd23287f4a506afbe601b4a2">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b0244f4d3e877af92bb3326b5ba74d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0244f4d3e877af92bb3326b5ba74d2">&#9670;&nbsp;</a></span>modulus_remainder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a id="aef9e014546d86033dd6c81f699891267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9e014546d86033dd6c81f699891267">&#9670;&nbsp;</a></span>modulus_remainder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a id="a560a698db966dbc2d5edcb7896e56d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560a698db966dbc2d5edcb7896e56d4d">&#9670;&nbsp;</a></span>reduce_expr_modulo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a id="a99da5cb047c88b9a411ce79ca672059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99da5cb047c88b9a411ce79ca672059a">&#9670;&nbsp;</a></span>reduce_expr_modulo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td>
          <td class="paramname"><em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a id="a789149daec96e933f8758f71f8474dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789149daec96e933f8758f71f8474dd6">&#9670;&nbsp;</a></span>modulus_remainder_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::modulus_remainder_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3383c51a3621854507bf149283901fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3383c51a3621854507bf149283901fd8">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest common divisor of two integers. </p>

<p class="reference">Referenced by <a class="el" href="_function_d_a_g_8h_source.html#l00042">Halide::Internal::Autoscheduler::OptionalRational::operator+=()</a>.</p>

</div>
</div>
<a id="aea6d5d650979fec41ce02d02ac0b7c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d5d650979fec41ce02d02ac0b7c20">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::lcm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least common multiple of two integers. </p>

<p class="reference">Referenced by <a class="el" href="_function_d_a_g_8h_source.html#l00042">Halide::Internal::Autoscheduler::OptionalRational::operator+=()</a>.</p>

</div>
</div>
<a id="ae2a191d0d4abe4a4d1019cad5cff62ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a191d0d4abe4a4d1019cad5cff62ca">&#9670;&nbsp;</a></span>is_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a283407774a5c9a29ab30e9223dcb3580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283407774a5c9a29ab30e9223dcb3580">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the monotonic class in human-readable form for debugging. </p>

</div>
</div>
<a id="af6de4b237eafb498206aa2eb0c94b4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de4b237eafb498206aa2eb0c94b4ad">&#9670;&nbsp;</a></span>is_monotonic_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::is_monotonic_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a87590be371b78913eaab20e563f335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a87590be371b78913eaab20e563f335">&#9670;&nbsp;</a></span>can_parallelize_rvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_parallelize_rvar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable. </p>
<p>If this returns true, it's definitely safe. If this returns false, it may still be safe, but <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> couldn't prove it. </p>

</div>
</div>
<a id="a0ce66817377fbb1918bbe7510ab47b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce66817377fbb1918bbe7510ab47b29">&#9670;&nbsp;</a></span>check_call_arg_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_call_arg_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a id="aa4498b50bbce3ab2d9915233d648be38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4498b50bbce3ab2d9915233d648be38">&#9670;&nbsp;</a></span>has_uncaptured_likely_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_uncaptured_likely_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression uses a likely tag that isn't captured by an enclosing <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator.">Select</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html" title="The lesser of two values.">Min</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a>. </p>

</div>
</div>
<a id="a40fd7d8d9eafda07ee9a314c3c869f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fd7d8d9eafda07ee9a314c3c869f2d">&#9670;&nbsp;</a></span>has_likely_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_likely_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression uses a likely tag. </p>

</div>
</div>
<a id="a3d00fe3db9030d30827191d78c36fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d00fe3db9030d30827191d78c36fda5">&#9670;&nbsp;</a></span>partition_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::partition_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions loop bodies into a prologue, a steady state, and an epilogue. </p>
<p>Finds the steady state by hunting for use of clamped ramps, or the 'likely' intrinsic. </p>

</div>
</div>
<a id="a9d9e0c79704de005e7e9ca2283da97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e0c79704de005e7e9ca2283da97c6">&#9670;&nbsp;</a></span>inject_placeholder_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_placeholder_prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefetches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject placeholder prefetches to 's'. </p>
<p>This placholder prefetch does not have explicit region to be prefetched yet. It will be computed during call to <a class="el" href="namespace_halide_1_1_internal.html#ab1427ae551e1c2cce79b7042c3fa4620">inject_prefetch</a>. </p>

</div>
</div>
<a id="ab1427ae551e1c2cce79b7042c3fa4620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1427ae551e1c2cce79b7042c3fa4620">&#9670;&nbsp;</a></span>inject_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the actual region to be prefetched and place it to the placholder prefetch. </p>
<p>Wrap the prefetch call with condition when applicable. </p>

</div>
</div>
<a id="a23cbede92a4cd09354b032a40829a9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cbede92a4cd09354b032a40829a9d1">&#9670;&nbsp;</a></span>reduce_prefetch_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::reduce_prefetch_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture). </p>
<p>This keeps the 'max_dim' innermost dimensions and adds loops for the rest of the dimensions. If maximum prefetched-byte-size is specified (depending on the architecture), this also adds an outer loops that tile the prefetches. </p>

</div>
</div>
<a id="aa35ddfd891459204fae6afbcbdb6bac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35ddfd891459204fae6afbcbdb6bac6">&#9670;&nbsp;</a></span>print_loop_nest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::print_loop_nest </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses. </p>

</div>
</div>
<a id="ab6bc0501d181c62936f9c544a206a18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bc0501d181c62936f9c544a206a18c">&#9670;&nbsp;</a></span>inject_profiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_profiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a id="a875f0768e69428144a610e591c7d9796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875f0768e69428144a610e591c7d9796">&#9670;&nbsp;</a></span>purify_index_math()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::purify_index_math </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounds inference and related stages can lift integer bounds expressions out of if statements that guard against those integer expressions doing side-effecty things like dividing or modding by zero. </p>
<p>In those cases, if the lowering passes are functional, the value resulting from the division or mod is evaluated but not used. This mutator rewrites divs and mods in such expressions to fail silently (evaluate to undef) when the denominator is zero. </p>

</div>
</div>
<a id="aac0f12f161a6ba2a7b3476dbb1dbf809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f12f161a6ba2a7b3476dbb1dbf809">&#9670;&nbsp;</a></span>qualify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::qualify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a id="a795f343747d7f716a33198907c3e7d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795f343747d7f716a33198907c3e7d25">&#9670;&nbsp;</a></span>random_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_float </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a id="ae4e64539c6d89123f6200b919ec28fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e64539c6d89123f6200b919ec28fbb">&#9670;&nbsp;</a></span>random_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers). </p>

</div>
</div>
<a id="af6c33f7c870e8bd885383ccdc626112e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c33f7c870e8bd885383ccdc626112e">&#9670;&nbsp;</a></span>lower_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a id="a310daae8e7f187c090b63aa3514d639c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310daae8e7f187c090b63aa3514d639c">&#9670;&nbsp;</a></span>realization_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; Halide::Internal::realization_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine an order in which to do the scheduling. </p>
<p>This in turn influences the order in which stages are computed when there's no strict dependency between them. Currently just some arbitrary depth-first traversal of the call graph. In addition, determine grouping of functions with fused computation loops. The functions within the fused groups are sorted based on realization order. There should not be any dependencies among functions within a fused group. This pass will also populate the 'fused_pairs' list in the function's schedule. Return a pair of the realization order and the fused groups in that order. </p>

</div>
</div>
<a id="a5a4634146d25cdc2f89c0501ad72ccde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4634146d25cdc2f89c0501ad72ccde">&#9670;&nbsp;</a></span>topological_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::topological_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule. </p>
<p>This ordering adheres to the producer-consumer dependencies, i.e. producer will come before its consumers in that order </p>

</div>
</div>
<a id="aedcc74570e61290111488ef861e03d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcc74570e61290111488ef861e03d0f">&#9670;&nbsp;</a></span>split_predicate_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_predicate_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b8bfb7d84886e922f43c911740f2b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8bfb7d84886e922f43c911740f2b1e">&#9670;&nbsp;</a></span>is_func_trivial_to_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_func_trivial_to_inline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the cost of inlining a function is equivalent to the cost of calling the function directly. </p>

</div>
</div>
<a id="af5f341c9e3b9dd03353afdeacd6092db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f341c9e3b9dd03353afdeacd6092db">&#9670;&nbsp;</a></span>remove_dead_allocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_dead_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>. </p>
<p>This doesn't touch Realize/Call nodes and so must be called after storage_flattening. </p>

</div>
</div>
<a id="a7966c5570f5dfae1e45df7995c34a762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7966c5570f5dfae1e45df7995c34a762">&#9670;&nbsp;</a></span>remove_extern_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_extern_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes placeholder loops for extern stages. </p>

</div>
</div>
<a id="a078fe646230de310959c4506c76de02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078fe646230de310959c4506c76de02e">&#9670;&nbsp;</a></span>remove_undef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_undef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a id="a9893105833167095e00bf8802a1294f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9893105833167095e00bf8802a1294f1">&#9670;&nbsp;</a></span>schedule_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::schedule_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>any_memoized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> realizations at the appropriate places using the schedule. </p>
<p>Returns a flag indicating whether memoization passes need to be run. </p>

</div>
</div>
<a id="a4242a0b28a7409d2a2489a74795914ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4242a0b28a7409d2a2489a74795914ef">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_scope_8h_source.html#l00253">253</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p class="reference">References <a class="el" href="_scope_8h_source.html#l00238">Halide::Internal::Scope&lt; T &gt;::cbegin()</a>, <a class="el" href="_scope_8h_source.html#l00242">Halide::Internal::Scope&lt; T &gt;::cend()</a>, and <a class="el" href="_scope_8h_source.html#l00223">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a id="a3c068fc071822f5554d35e8cce582f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c068fc071822f5554d35e8cce582f54">&#9670;&nbsp;</a></span>select_gpu_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::select_gpu_api </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target. </p>
<p>Choose the first of the following: opencl, cuda, openglcompute, opengl </p>

</div>
</div>
<a id="af1b93d357d959c8f75e22e4dedea6da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b93d357d959c8f75e22e4dedea6da7">&#9670;&nbsp;</a></span>simplify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_let_stmts</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a id="ac350731ef3d9028927a72f455f28922f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac350731ef3d9028927a72f455f28922f">&#9670;&nbsp;</a></span>simplify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_let_stmts</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5068393c9b9f8b58f7e1c164bee99f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5068393c9b9f8b58f7e1c164bee99f0b">&#9670;&nbsp;</a></span>can_prove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_prove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to statically prove an expression is true using the simplifier. </p>

</div>
</div>
<a id="a0918e7154f0624c9f1a15d34f4776c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0918e7154f0624c9f1a15d34f4776c54">&#9670;&nbsp;</a></span>simplify_exprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_exprs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_internal_1_1_simplify.html">Simplify</a> expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a id="a9145896c0b84da47b601412c7f451cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145896c0b84da47b601412c7f451cb4">&#9670;&nbsp;</a></span>simplify_correlated_differences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_correlated_differences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic interval arithmetic can be extremely conservative in cases where we analyze the difference between two correlated expressions. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, consider:</p>
<p>for x in [0, 10]: let y = x + 3 let z = y - x</p>
<p>x lies within [0, 10]. <a class="el" href="struct_halide_1_1_internal_1_1_interval.html" title="A class to represent ranges of Exprs.">Interval</a> arithmetic will correctly determine that y lies within [3, 13]. When z is encountered, it is treated as a difference of two independent variables, and gives [3 - 10, 13 - 0] = [-7, 13] instead of the tighter interval [3, 3]. It doesn't understand that y and x are correlated.</p>
<p>In practice, this problem causes problems for unrolling, and arbitrarily-bad overconservative behavior in bounds inference (e.g. <a href="https://github.com/halide/Halide/issues/3697">https://github.com/halide/Halide/issues/3697</a> )</p>
<p>The function below attempts to address this by walking the IR, remembering whether each let variable is monotonic increasing, decreasing, unknown, or constant w.r.t each loop var. When it encounters a subtract node where both sides have the same monotonicity it substitutes, solves, and attempts to generally simplify as aggressively as possible to try to cancel out the repeated dependence on the loop var. The same is done for addition nodes with arguments of opposite monotonicity.</p>
<p>Bounds inference is particularly sensitive to these false dependencies, but removing false dependencies also helps other lowering passes. E.g. if this simplification means a value no longer depends on a loop variable, it can remain scalar during vectorization of that loop, or we can lift it out as a loop invariant, or it might avoid some of the complex paths in GPU codegen that trigger when values depend on the block index (e.g. warp shuffles).</p>
<p>This pass is safe to use on code with repeated instances of the same variable name (it must be, because we want to run it before allocation bounds inference). </p>

</div>
</div>
<a id="af4259425c64a0a9b25760e1c38123c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4259425c64a0a9b25760e1c38123c13">&#9670;&nbsp;</a></span>simplify_specializations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::simplify_specializations </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the RHS/LHS of a function's definition based on its specializations. </p>

</div>
</div>
<a id="a8489422fe4da6e486b5fd7831aab8bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8489422fe4da6e486b5fd7831aab8bfb">&#9670;&nbsp;</a></span>skip_stages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::skip_stages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by analyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a id="a6e3db85e95026207aa687c6f56c53cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3db85e95026207aa687c6f56c53cba">&#9670;&nbsp;</a></span>sliding_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::sliding_window </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a id="a285ed8a60a9ef19bd666e8f12a11f269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285ed8a60a9ef19bd666e8f12a11f269">&#9670;&nbsp;</a></span>solve_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a> Halide::Internal::solve_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e. </p>
<p>outside most parentheses). If the expression is an equality or comparison, this 'solves' the equation. Returns a pair of <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and bool. The <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> is the mutated expression, and the bool indicates whether there is a single instance of the variable in the result. If it is false, the expression has only been partially solved, and there are still multiple instances of the variable. </p>

</div>
</div>
<a id="a01aa500a3f20519d9a27d718f77e1c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aa500a3f20519d9a27d718f77e1c1e">&#9670;&nbsp;</a></span>solve_for_outer_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_outer_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it. </p>
<p>Never returns undefined Exprs, instead it uses variables called "pos_inf" and "neg_inf" to represent positive and negative infinity. </p>

</div>
</div>
<a id="a6af37b4f0075b3dcd203546133878d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af37b4f0075b3dcd203546133878d54">&#9670;&nbsp;</a></span>solve_for_inner_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_inner_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it. </p>

</div>
</div>
<a id="a1fe4e051947dc094f3136a7b1e69a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4e051947dc094f3136a7b1e69a1e1">&#9670;&nbsp;</a></span>and_condition_over_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::and_condition_over_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>varying</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables. </p>
<p>Formally, the output expr implies the input expr.</p>
<p>The condition may be a vector condition, in which case we also 'and' over the vector lanes, and return a scalar result. </p>

</div>
</div>
<a id="a6e1e287e68d69ec35fd8a1e62d1c30ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1e287e68d69ec35fd8a1e62d1c30ed">&#9670;&nbsp;</a></span>solve_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::solve_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e8dbe6ebbf9e99beda91f45eead442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8dbe6ebbf9e99beda91f45eead442f">&#9670;&nbsp;</a></span>split_tuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::split_tuples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions. </p>

</div>
</div>
<a id="a7d4f1d389af9c9074589d868f106ab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4f1d389af9c9074589d868f106ab1a">&#9670;&nbsp;</a></span>print_to_html() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> to filename. </p>

</div>
</div>
<a id="a6219802c50d1b296c9053344abe66b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6219802c50d1b296c9053344abe66b1e">&#9670;&nbsp;</a></span>print_to_html() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module.">Module</a> to filename. </p>

</div>
</div>
<a id="ac8cb6fe2cb6171bf79124c2c1b1e867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cb6fe2cb6171bf79124c2c1b1e867f">&#9670;&nbsp;</a></span>storage_flattening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_flattening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true.">Load</a> nodes respectively. </p>

</div>
</div>
<a id="a328a1d6d3f0c78ffdc58ac5df812f05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328a1d6d3f0c78ffdc58ac5df812f05a">&#9670;&nbsp;</a></span>storage_folding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_folding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><div class="line">f(x) = ...</div>
<div class="line">g(x) = f(x-1) + f(x)</div>
<div class="line">f.store_root().compute_at(g, x);</div>
</div><!-- fragment --><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a id="ad8a5dab8c12346254d9348060878045c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a5dab8c12346254d9348060878045c">&#9670;&nbsp;</a></span>strictify_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::strictify_float </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions. </p>
<p>This makes the IR nodes context independent. If the <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6e99d2e5d2365e4b2cf9fb7dbe1671c4">Target::StrictFloat</a> flag is specified in target, starts in strict_float mode so all floating-point type Exprs in the compilation will be marked with strict_float. Returns whether any strict floating-point is used in any function in the passed in env. </p>

</div>
</div>
<a id="ab77fafc3670bd07362c388820dd10c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77fafc3670bd07362c388820dd10c11">&#9670;&nbsp;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a id="a953484f8812539e108a6c4e137ebfc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953484f8812539e108a6c4e137ebfc62">&#9670;&nbsp;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a id="a92d044309ede4782cabce475570934a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d044309ede4782cabce475570934a8">&#9670;&nbsp;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a id="a14ebb6536c3233e6466073757f0e59e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ebb6536c3233e6466073757f0e59e7">&#9670;&nbsp;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07967ab74e22a0103d6af67ec62cc3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07967ab74e22a0103d6af67ec62cc3b7">&#9670;&nbsp;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a id="ae1b12ab6ef3f59e897315145d1e996e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b12ab6ef3f59e897315145d1e996e2">&#9670;&nbsp;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a457e67268c787fe55a7bc5e3559f43cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457e67268c787fe55a7bc5e3559f43cc">&#9670;&nbsp;</a></span>graph_substitute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a id="a95627cc6470e3f8975ab3b1fa2048e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95627cc6470e3f8975ab3b1fa2048e3e">&#9670;&nbsp;</a></span>graph_substitute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8219abd8f63bb237e29a7b878a445836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8219abd8f63bb237e29a7b878a445836">&#9670;&nbsp;</a></span>graph_substitute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8e9db71fa11a9eb45590a8fd5ff774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e9db71fa11a9eb45590a8fd5ff774">&#9670;&nbsp;</a></span>graph_substitute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaafce6d574b476cf9c9acd5f622450ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafce6d574b476cf9c9acd5f622450ab">&#9670;&nbsp;</a></span>substitute_in_all_lets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a id="a6a57aa0cf600e63ac832ea799f354acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a57aa0cf600e63ac832ea799f354acc">&#9670;&nbsp;</a></span>substitute_in_all_lets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0ca85eaf8baf3957bda33b83b20c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ca85eaf8baf3957bda33b83b20c694">&#9670;&nbsp;</a></span>target_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::target_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a402f1bcce3709f5f726b4a791d555a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402f1bcce3709f5f726b4a791d555a99">&#9670;&nbsp;</a></span>inject_tracing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_tracing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trace_pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>Target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a id="aae7fd6fdb5eb7b96d5dcf4a9d52985f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">&#9670;&nbsp;</a></span>trim_no_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::trim_no_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate loop bounds to the region over which they actually do something. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> examples see test/correctness/trim_no_ops.cpp </p>

</div>
</div>
<a id="a8803d2593422e45d64b2d15429cfde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8803d2593422e45d64b2d15429cfde0d">&#9670;&nbsp;</a></span>unify_duplicate_lets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unify_duplicate_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a id="a400b238529ddcab092d8bfa88ad33880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400b238529ddcab092d8bfa88ad33880">&#9670;&nbsp;</a></span>uniquify_variable_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::uniquify_variable_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a id="a60ff22da036ee4307f0963aadc7fa9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ff22da036ee4307f0963aadc7fa9fe">&#9670;&nbsp;</a></span>uniquify_variable_names_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::uniquify_variable_names_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49ffc3710f4a568f3e626e253bc758c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffc3710f4a568f3e626e253bc758c2">&#9670;&nbsp;</a></span>unpack_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unpack_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates let stmts for the various buffer components (e.g. </p>
<p>foo.extent.0) in any referenced concrete buffers or buffer parameters. After this pass, the only undefined symbols should scalar parameters and the buffers themselves (e.g. foo.buffer). </p>

</div>
</div>
<a id="ada0f57de73c898a70875fff4fad5cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f57de73c898a70875fff4fad5cbf3">&#9670;&nbsp;</a></span>unroll_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unroll_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a id="a0b7ac6d7399bf2ba00640fe7aa794f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7ac6d7399bf2ba00640fe7aa794f7f">&#9670;&nbsp;</a></span>lower_unsafe_promises()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_unsafe_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all unsafe promises into either assertions or unchecked code, depending on the target. </p>

</div>
</div>
<a id="aa0d28d6c47ed91864a2f92e8b2868128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d28d6c47ed91864a2f92e8b2868128">&#9670;&nbsp;</a></span>lower_safe_promises()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_safe_promises </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all safe promises by just stripping them. </p>
<p>This is a good idea once no more lowering stages are going to use boxes_touched. </p>

</div>
</div>
<a id="ab7501900efa7660edf445ed1b14c020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7501900efa7660edf445ed1b14c020c">&#9670;&nbsp;</a></span>safe_numeric_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DST Halide::Internal::safe_numeric_cast </td>
          <td>(</td>
          <td class="paramtype">SRC&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00075">75</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00581">Halide::max()</a>, and <a class="el" href="_func_8h_source.html#l00578">Halide::min()</a>.</p>

</div>
</div>
<a id="a94816d6979fdadb6e206a5d0a668e008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94816d6979fdadb6e206a5d0a668e008">&#9670;&nbsp;</a></span>reinterpret_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType Halide::Internal::reinterpret_bits </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00111">111</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00032">dst</a>, and <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>.</p>

</div>
</div>
<a id="a18d7dfc983d7a320ea1510c24bc55625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d7dfc983d7a320ea1510c24bc55625">&#9670;&nbsp;</a></span>make_entity_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::make_entity_name </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a unique name for an object based on the name of the stack variable passed in. </p>
<p>If introspection isn't working or there are no debug symbols, just uses unique_name with the given prefix. </p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00182">Halide::Buffer&lt; T &gt;::Buffer()</a>.</p>

</div>
</div>
<a id="a8c7c63ee87658cd904e2f4a0ba78b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c63ee87658cd904e2f4a0ba78b78b">&#9670;&nbsp;</a></span>get_env_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_env_variable </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>env_var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of an environment variable. </p>
<p>Returns its value is defined in the environment. If the var is not defined, an empty string is returned. </p>

</div>
</div>
<a id="ab4b793745b048fa1fd344907ec4ec9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b793745b048fa1fd344907ec4ec9aa">&#9670;&nbsp;</a></span>running_program_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::running_program_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the currently running executable. </p>
<p>Platform-specific. If program name cannot be retrieved, function returns an empty string. </p>

</div>
</div>
<a id="aabd490221160a7206bb151d6eae65624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd490221160a7206bb151d6eae65624">&#9670;&nbsp;</a></span>unique_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

</div>
</div>
<a id="a7ec0bd73d997ddc50f3523a21448471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec0bd73d997ddc50f3523a21448471f">&#9670;&nbsp;</a></span>unique_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26ca52c958b993ebd766f4b83de2cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26ca52c958b993ebd766f4b83de2cf9">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string starts with the second string. </p>

</div>
</div>
<a id="a290fb244405de2c014ebdc3cd1fc8f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290fb244405de2c014ebdc3cd1fc8f08">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> if the first string ends with the second string. </p>

</div>
</div>
<a id="a9c06bf852ad18eb3e9014495f5816c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c06bf852ad18eb3e9014495f5816c1f">&#9670;&nbsp;</a></span>replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches of the second string in the first string with the last string. </p>

</div>
</div>
<a id="a403191721c99e2a88864db3bafbf7b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403191721c99e2a88864db3bafbf7b0e">&#9670;&nbsp;</a></span>split_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider. </p>

</div>
</div>
<a id="aaaee1bb2b0dc659851899df7c12437ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee1bb2b0dc659851899df7c12437ba">&#9670;&nbsp;</a></span>fold_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_left </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. Similar to std::accumulate but with a less clunky syntax. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00170">170</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="afedfcf82469516f0f05eb5a4699f480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedfcf82469516f0f05eb5a4699f480a">&#9670;&nbsp;</a></span>fold_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_right </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a right fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00185">185</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a93192a2ea0afe58664e69232595ae08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93192a2ea0afe58664e69232595ae08e">&#9670;&nbsp;</a></span>extract_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::extract_namespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns base name and fills in namespaces, outermost one first in vector. </p>

<p class="reference">Referenced by <a class="el" href="_type_8h_source.html#l00197">halide_handle_cplusplus_type::make()</a>.</p>

</div>
</div>
<a id="a4f8aad349dd3bfc69483b792fcab0f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8aad349dd3bfc69483b792fcab0f96">&#9670;&nbsp;</a></span>file_make_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::file_make_temp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed. </p>
<p>(Note that the exact form of the file name may vary; in particular, the suffix may be ignored on Windows.) The file is created (but not opened), thus this can be called from different threads (or processes, e.g. when building with parallel make) without risking collision. Note that if this file is used as a temporary file, the caller is responsibly for deleting it. Neither the prefix nor suffix may contain a directory separator. </p>

</div>
</div>
<a id="abaf8a5ee39d2b222d8a0be57894a2f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf8a5ee39d2b222d8a0be57894a2f75">&#9670;&nbsp;</a></span>dir_make_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::dir_make_temp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed. </p>
<p>The directory will be empty (i.e., this will never return /tmp itself, but rather a new directory inside /tmp). The caller is responsible for removing the directory after use. </p>

</div>
</div>
<a id="aff2a323363444e3d16237848f6f8715b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2a323363444e3d16237848f6f8715b">&#9670;&nbsp;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for access(). </p>
<p>Quietly ignores errors. </p>

</div>
</div>
<a id="a034796c3683c3301a09c0102c6adb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034796c3683c3301a09c0102c6adb8b0">&#9670;&nbsp;</a></span>assert_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file doesn't exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a id="ab8356033bf440e2f990bdc9f27cdcdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8356033bf440e2f990bdc9f27cdcdcf">&#9670;&nbsp;</a></span>assert_no_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file DOES exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a id="a05dd8ec86534a0e22d1ab4f2037bc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd8ec86534a0e22d1ab4f2037bc562">&#9670;&nbsp;</a></span>file_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::file_unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for unlink(). </p>
<p>Asserts upon error.</p>
<p>Quietly ignores errors. </p>

<p class="reference">Referenced by <a class="el" href="_util_8h_source.html#l00295">Halide::Internal::TemporaryFile::~TemporaryFile()</a>.</p>

</div>
</div>
<a id="a947c611b7403f5613f08fb701ea6eed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c611b7403f5613f08fb701ea6eed6">&#9670;&nbsp;</a></span>ensure_no_file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ensure_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that no file with this path exists. </p>
<p>If such a file exists and cannot be removed, assert-fail. </p>

</div>
</div>
<a id="a710588d377ce398aa366fc00f6d436aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710588d377ce398aa366fc00f6d436aa">&#9670;&nbsp;</a></span>dir_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::dir_rmdir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for rmdir(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a id="aa0f41b4199ab2236fb4056661f20cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f41b4199ab2236fb4056661f20cc11">&#9670;&nbsp;</a></span>file_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a> Halide::Internal::file_stat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for stat(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a id="ad702fdea527abbf0f987c72aaacf9b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad702fdea527abbf0f987c72aaacf9b69">&#9670;&nbsp;</a></span>read_entire_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; Halide::Internal::read_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire contents of a file into a vector&lt;char&gt;. </p>
<p>The file is read in binary mode. Errors trigger an assertion failure. </p>

</div>
</div>
<a id="a4a0a74e2116e6583961430bb9f96dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a74e2116e6583961430bb9f96dc64">&#9670;&nbsp;</a></span>write_entire_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::write_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>source_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create or replace the contents of a file with a given pointer-and-length of memory. </p>
<p>If the file doesn't exist, it is created; if it does exist, it is completely overwritten. Any error triggers an assertion failure. </p>

<p class="reference">Referenced by <a class="el" href="_util_8h_source.html#l00277">write_entire_file()</a>.</p>

</div>
</div>
<a id="a687a41c09f705e2859eea67df0e04501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687a41c09f705e2859eea67df0e04501">&#9670;&nbsp;</a></span>write_entire_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::write_entire_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00277">277</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_internal.html#a4a0a74e2116e6583961430bb9f96dc64">write_entire_file()</a>.</p>

</div>
</div>
<a id="a8cc678d669d07fdd15685b87e3b8b620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc678d669d07fdd15685b87e3b8b620">&#9670;&nbsp;</a></span>add_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::add_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00966">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;()</a>.</p>

</div>
</div>
<a id="a82c64641e261b5596a2ab6d7da7f8ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c64641e261b5596a2ab6d7da7f8ef8">&#9670;&nbsp;</a></span>sub_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::sub_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l00999">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;()</a>.</p>

</div>
</div>
<a id="a9aaa735c9ff93372dce25222fb551b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaa735c9ff93372dce25222fb551b67">&#9670;&nbsp;</a></span>mul_would_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::mul_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_i_r_match_8h_source.html#l01032">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;()</a>.</p>

</div>
</div>
<a id="ae342a753f8441a0b29418b0d22cbda86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342a753f8441a0b29418b0d22cbda86">&#9670;&nbsp;</a></span>halide_tic_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_tic_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c23694d45bd4c42ec1dc97a17bb78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c23694d45bd4c42ec1dc97a17bb78f6">&#9670;&nbsp;</a></span>halide_toc_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_toc_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2a455f3f5fbe779f6de0acbec1bfa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a455f3f5fbe779f6de0acbec1bfa44">&#9670;&nbsp;</a></span>c_print_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::c_print_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a version of a string that is a valid identifier in C (. </p>
<p>is replaced with _) </p>

</div>
</div>
<a id="a591746c6ae0cd3e8d24c2c2420772d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591746c6ae0cd3e8d24c2c2420772d8a">&#9670;&nbsp;</a></span>get_llvm_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::get_llvm_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVM_VERSION against which this libHalide is compiled. </p>
<p>This is provided only for internal tests which need to verify behavior; please don't use this outside of <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> tests. </p>

</div>
</div>
<a id="a7006f0b4b15257feedd9e57d1288dc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7006f0b4b15257feedd9e57d1288dc97">&#9670;&nbsp;</a></span>make_argument_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_halide_1_1_var.html">Var</a>&gt; Halide::Internal::make_argument_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of unique arguments for definitions with unnamed arguments. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l01225">Halide::Func::define_extern()</a>.</p>

</div>
</div>
<a id="af67bb97b08ab82cba4e520c1f48a0821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67bb97b08ab82cba4e520c1f48a0821">&#9670;&nbsp;</a></span>vectorize_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vectorize_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
<a id="a47ba0a978ebdc5f1866290752bd76e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ba0a978ebdc5f1866290752bd76e6d">&#9670;&nbsp;</a></span>wrap_func_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::wrap_func_calls </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions. </p>

</div>
</div>
<a id="abb9d57ef08d50b32cd0f947c699a7508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d57ef08d50b32cd0f947c699a7508">&#9670;&nbsp;</a></span>get_test_tmp_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_test_tmp_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the path to a directory that can be safely written to when running tests; the contents directory may or may not outlast the lifetime of test itself (ie, the files may be cleaned up after test execution). </p>
<p>The path is guaranteed to be an absolute path and end in a directory separator, so a leaf filename can simply be appended. It is not guaranteed that this directory will be empty. If the path cannot be created, the function will assert-fail and return an invalid path. </p>

<p class="definition">Definition at line <a class="el" href="halide__test__dirs_8h_source.html#l00075">75</a> of file <a class="el" href="halide__test__dirs_8h_source.html">halide_test_dirs.h</a>.</p>

<p class="reference">References <a class="el" href="halide__test__dirs_8h_source.html#l00045">Halide::Internal::Test::get_current_directory()</a>, and <a class="el" href="halide__test__dirs_8h_source.html#l00026">Halide::Internal::Test::get_env_variable()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac4e8d52841afa71f1f7bac7ce9611159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8d52841afa71f1f7bac7ce9611159">&#9670;&nbsp;</a></span>unknown</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::unknown = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;::<a class="el" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00022">22</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
<a id="a4bf1a96be9fadff5521559de5f72935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf1a96be9fadff5521559de5f72935c">&#9670;&nbsp;</a></span>StrongestExprNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> Halide::Internal::StrongestExprNodeType = <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a17335c02c86e7a0a2b46540df1e45eb5">IRNodeType::VectorReduce</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_expr_8h_source.html#l00079">79</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
