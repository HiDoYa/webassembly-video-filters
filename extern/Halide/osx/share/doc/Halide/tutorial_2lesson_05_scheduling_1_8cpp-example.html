<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: tutorial/lesson_05_scheduling_1.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial_2lesson_05_scheduling_1_8cpp-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_05_scheduling_1.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Halide tutorial lesson 5: Vectorize, parallelize, unroll and tile your code</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This lesson demonstrates how to manipulate the order in which you</span></div>
<div class="line"><span class="comment">// evaluate pixels in a Func, including vectorization,</span></div>
<div class="line"><span class="comment">// parallelization, unrolling, and tiling.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On linux, you can compile and run it like so:</span></div>
<div class="line"><span class="comment">// g++ lesson_05*.cpp -g -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -lpthread -ldl -o lesson_05 -std=c++11</span></div>
<div class="line"><span class="comment">// LD_LIBRARY_PATH=&lt;path/to/libHalide.so&gt; ./lesson_05</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On os x:</span></div>
<div class="line"><span class="comment">// g++ lesson_05*.cpp -g -I &lt;path/to/Halide.h&gt; -L &lt;path/to/libHalide.so&gt; -lHalide -o lesson_05 -std=c++11</span></div>
<div class="line"><span class="comment">// DYLD_LIBRARY_PATH=&lt;path/to/libHalide.dylib&gt; ./lesson_05</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you have the entire Halide source tree, you can also build it by</span></div>
<div class="line"><span class="comment">// running:</span></div>
<div class="line"><span class="comment">//    make tutorial_lesson_05_scheduling_1</span></div>
<div class="line"><span class="comment">// in a shell with the current directory at the top of the halide</span></div>
<div class="line"><span class="comment">// source tree.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Halide.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_halide.html">Halide</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We&#39;re going to define and schedule our gradient function in</span></div>
<div class="line">    <span class="comment">// several different ways, and see what order pixels are computed</span></div>
<div class="line">    <span class="comment">// in.</span></div>
<div class="line"> </div>
<div class="line">    Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// First we observe the default ordering.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// By default we walk along the rows and then down the</span></div>
<div class="line">        <span class="comment">// columns. This means x varies quickly, and y varies</span></div>
<div class="line">        <span class="comment">// slowly. x is the column and y is the row, so this is a</span></div>
<div class="line">        <span class="comment">// row-major traversal.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient row-major\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_row_major.gif for a visualization of</span></div>
<div class="line">        <span class="comment">// what this did.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The equivalent C is:</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tracing is one useful way to understand what a schedule is</span></div>
<div class="line">        <span class="comment">// doing. You can also ask Halide to print out pseudocode</span></div>
<div class="line">        <span class="comment">// showing what loops Halide is generating:</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Because we&#39;re using the default ordering, it should print:</span></div>
<div class="line">        <span class="comment">// compute gradient:</span></div>
<div class="line">        <span class="comment">//   for y:</span></div>
<div class="line">        <span class="comment">//     for x:</span></div>
<div class="line">        <span class="comment">//       gradient(...) = ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Reorder variables.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_col_major&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we reorder x and y, we can walk down the columns</span></div>
<div class="line">        <span class="comment">// instead. The reorder call takes the arguments of the func,</span></div>
<div class="line">        <span class="comment">// and sets a new nesting order for the for loops that are</span></div>
<div class="line">        <span class="comment">// generated. The arguments are specified from the innermost</span></div>
<div class="line">        <span class="comment">// loop out, so the following call puts y in the inner loop:</span></div>
<div class="line">        gradient.reorder(y, x);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This means y (the row) will vary quickly, and x (the</span></div>
<div class="line">        <span class="comment">// column) will vary slowly, so this is a column-major</span></div>
<div class="line">        <span class="comment">// traversal.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient column-major\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_col_major.gif for a visualization of</span></div>
<div class="line">        <span class="comment">// what this did.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we print pseudo-code for this schedule, we&#39;ll see that</span></div>
<div class="line">        <span class="comment">// the loop over y is now inside the loop over x.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Split a variable into two.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_split&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The most powerful primitive scheduling operation you can do</span></div>
<div class="line">        <span class="comment">// to a var is to split it into inner and outer sub-variables:</span></div>
<div class="line">        Var x_outer, x_inner;</div>
<div class="line">        gradient.split(x, x_outer, x_inner, 2);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This breaks the loop over x into two nested loops: an outer</span></div>
<div class="line">        <span class="comment">// one over x_outer, and an inner one over x_inner. The last</span></div>
<div class="line">        <span class="comment">// argument to split was the &quot;split factor&quot;. The inner loop</span></div>
<div class="line">        <span class="comment">// runs from zero to the split factor. The outer loop runs</span></div>
<div class="line">        <span class="comment">// from zero to the extent required of x (4 in this case)</span></div>
<div class="line">        <span class="comment">// divided by the split factor. Within the loops, the old</span></div>
<div class="line">        <span class="comment">// variable is defined to be outer * factor + inner. If the</span></div>
<div class="line">        <span class="comment">// old loop started at a value other than zero, then that is</span></div>
<div class="line">        <span class="comment">// also added within the loops.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient with x split into x_outer and x_inner \n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {</div>
<div class="line">                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that the order of evaluation of pixels didn&#39;t actually</span></div>
<div class="line">        <span class="comment">// change! Splitting by itself does nothing, but it does open</span></div>
<div class="line">        <span class="comment">// up all of the scheduling possibilities that we will explore</span></div>
<div class="line">        <span class="comment">// below.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fuse two variables into one.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_fused&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The opposite of splitting is &#39;fusing&#39;. Fusing two variables</span></div>
<div class="line">        <span class="comment">// merges the two loops into a single for loop over the</span></div>
<div class="line">        <span class="comment">// product of the extents. Fusing is less important than</span></div>
<div class="line">        <span class="comment">// splitting, but it also sees use (as we&#39;ll see later in this</span></div>
<div class="line">        <span class="comment">// lesson). Like splitting, fusing by itself doesn&#39;t change</span></div>
<div class="line">        <span class="comment">// the order of evaluation.</span></div>
<div class="line">        Var fused;</div>
<div class="line">        gradient.fuse(x, y, fused);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient with x and y fused\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fused = 0; fused &lt; 4 * 4; fused++) {</div>
<div class="line">            <span class="keywordtype">int</span> y = fused / 4;</div>
<div class="line">            <span class="keywordtype">int</span> x = fused % 4;</div>
<div class="line">            printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Evaluating in tiles.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_tiled&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now that we can both split and reorder, we can do tiled</span></div>
<div class="line">        <span class="comment">// evaluation. Let&#39;s split both x and y by a factor of four,</span></div>
<div class="line">        <span class="comment">// and then reorder the vars to express a tiled traversal.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// A tiled traversal splits the domain into small rectangular</span></div>
<div class="line">        <span class="comment">// tiles, and outermost iterates over the tiles, and within</span></div>
<div class="line">        <span class="comment">// that iterates over the points within each tile. It can be</span></div>
<div class="line">        <span class="comment">// good for performance if neighboring pixels use overlapping</span></div>
<div class="line">        <span class="comment">// input data, for example in a blur. We can express a tiled</span></div>
<div class="line">        <span class="comment">// traversal like so:</span></div>
<div class="line">        Var x_outer, x_inner, y_outer, y_inner;</div>
<div class="line">        gradient.split(x, x_outer, x_inner, 4);</div>
<div class="line">        gradient.split(y, y_outer, y_inner, 4);</div>
<div class="line">        gradient.reorder(x_inner, y_inner, x_outer, y_outer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This pattern is common enough that there&#39;s a shorthand for it:</span></div>
<div class="line">        <span class="comment">// gradient.tile(x, y, x_outer, y_outer, x_inner, y_inner, 4, 4);</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient in 4x4 tiles\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({8, 8});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_tiled.gif for a visualization of this</span></div>
<div class="line">        <span class="comment">// schedule.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_outer = 0; y_outer &lt; 2; y_outer++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 4; y_inner++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 4; x_inner++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x = x_outer * 4 + x_inner;</div>
<div class="line">                        <span class="keywordtype">int</span> y = y_outer * 4 + y_inner;</div>
<div class="line">                        printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Evaluating in vectors.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_in_vectors&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The nice thing about splitting is that it guarantees the</span></div>
<div class="line">        <span class="comment">// inner variable runs from zero to the split factor. Most of</span></div>
<div class="line">        <span class="comment">// the time the split-factor will be a compile-time constant,</span></div>
<div class="line">        <span class="comment">// so we can replace the loop over the inner variable with a</span></div>
<div class="line">        <span class="comment">// single vectorized computation. This time we&#39;ll split by a</span></div>
<div class="line">        <span class="comment">// factor of four, because on X86 we can use SSE to compute in</span></div>
<div class="line">        <span class="comment">// 4-wide vectors.</span></div>
<div class="line">        Var x_outer, x_inner;</div>
<div class="line">        gradient.split(x, x_outer, x_inner, 4);</div>
<div class="line">        gradient.vectorize(x_inner);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Splitting and then vectorizing the inner variable is common</span></div>
<div class="line">        <span class="comment">// enough that there&#39;s a short-hand for it. We could have also</span></div>
<div class="line">        <span class="comment">// said:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// gradient.vectorize(x, 4);</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// which is equivalent to:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// gradient.split(x, x, x_inner, 4);</span></div>
<div class="line">        <span class="comment">// gradient.vectorize(x_inner);</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that in this case we reused the name &#39;x&#39; as the new</span></div>
<div class="line">        <span class="comment">// outer variable. Later scheduling calls that refer to x</span></div>
<div class="line">        <span class="comment">// will refer to this new outer variable named x.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This time we&#39;ll evaluate over an 8x4 box, so that we have</span></div>
<div class="line">        <span class="comment">// more than one vector of work per scanline.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient with x_inner vectorized \n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({8, 4});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_vectors.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="comment">// The loop over x_inner has gone away, and has been</span></div>
<div class="line">                <span class="comment">// replaced by a vectorized version of the</span></div>
<div class="line">                <span class="comment">// expression. On x86 processors, Halide generates SSE</span></div>
<div class="line">                <span class="comment">// for all of this.</span></div>
<div class="line">                <span class="keywordtype">int</span> x_vec[] = {x_outer * 4 + 0,</div>
<div class="line">                               x_outer * 4 + 1,</div>
<div class="line">                               x_outer * 4 + 2,</div>
<div class="line">                               x_outer * 4 + 3};</div>
<div class="line">                <span class="keywordtype">int</span> val[] = {x_vec[0] + y,</div>
<div class="line">                             x_vec[1] + y,</div>
<div class="line">                             x_vec[2] + y,</div>
<div class="line">                             x_vec[3] + y};</div>
<div class="line">                printf(<span class="stringliteral">&quot;Evaluating at &lt;%d, %d, %d, %d&gt;, &lt;%d, %d, %d, %d&gt;:&quot;</span></div>
<div class="line">                       <span class="stringliteral">&quot; &lt;%d, %d, %d, %d&gt;\n&quot;</span>,</div>
<div class="line">                       x_vec[0], x_vec[1], x_vec[2], x_vec[3],</div>
<div class="line">                       y, y, y, y,</div>
<div class="line">                       val[0], val[1], val[2], val[3]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Unrolling a loop.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_unroll&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If multiple pixels share overlapping data, it can make</span></div>
<div class="line">        <span class="comment">// sense to unroll a computation so that shared values are</span></div>
<div class="line">        <span class="comment">// only computed or loaded once. We do this similarly to how</span></div>
<div class="line">        <span class="comment">// we expressed vectorizing. We split a dimension and then</span></div>
<div class="line">        <span class="comment">// fully unroll the loop of the inner variable. Unrolling</span></div>
<div class="line">        <span class="comment">// doesn&#39;t change the order in which things are evaluated.</span></div>
<div class="line">        Var x_outer, x_inner;</div>
<div class="line">        gradient.split(x, x_outer, x_inner, 2);</div>
<div class="line">        gradient.unroll(x_inner);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The shorthand for this is:</span></div>
<div class="line">        <span class="comment">// gradient.unroll(x, 2);</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient unrolled by a factor of two\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; result = gradient.realize({4, 4});</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="comment">// Instead of a for loop over x_inner, we get two</span></div>
<div class="line">                <span class="comment">// copies of the innermost statement.</span></div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordtype">int</span> x_inner = 0;</div>
<div class="line">                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                }</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordtype">int</span> x_inner = 1;</div>
<div class="line">                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Splitting by factors that don&#39;t divide the extent.</span></div>
<div class="line">    {</div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_split_7x2&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Splitting guarantees that the inner loop runs from zero to</span></div>
<div class="line">        <span class="comment">// the split factor, which is important for the uses we saw</span></div>
<div class="line">        <span class="comment">// above. So what happens when the total extent we wish to</span></div>
<div class="line">        <span class="comment">// evaluate x over isn&#39;t a multiple of the split factor? We&#39;ll</span></div>
<div class="line">        <span class="comment">// split by a factor three, and we&#39;ll evaluate gradient over a</span></div>
<div class="line">        <span class="comment">// 7x2 box instead of the 4x4 box we&#39;ve been using.</span></div>
<div class="line">        Var x_outer, x_inner;</div>
<div class="line">        gradient.split(x, x_outer, x_inner, 3);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient over a 7x2 box with x split by three \n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({7, 2});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_split_7_by_3.gif for a visualization</span></div>
<div class="line">        <span class="comment">// of what happened. Note that some points get evaluated more</span></div>
<div class="line">        <span class="comment">// than once!</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 2; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 3; x_outer++) {  <span class="comment">// Now runs from 0 to 2</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 3; x_inner++) {</div>
<div class="line">                    <span class="keywordtype">int</span> x = x_outer * 3;</div>
<div class="line">                    <span class="comment">// Before we add x_inner, make sure we don&#39;t</span></div>
<div class="line">                    <span class="comment">// evaluate points outside of the 7x2 box. We&#39;ll</span></div>
<div class="line">                    <span class="comment">// clamp x to be at most 4 (7 minus the split</span></div>
<div class="line">                    <span class="comment">// factor).</span></div>
<div class="line">                    <span class="keywordflow">if</span> (x &gt; 4) x = 4;</div>
<div class="line">                    x += x_inner;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If you read the output, you&#39;ll see that some coordinates</span></div>
<div class="line">        <span class="comment">// were evaluated more than once. That&#39;s generally OK, because</span></div>
<div class="line">        <span class="comment">// pure Halide functions have no side-effects, so it&#39;s safe to</span></div>
<div class="line">        <span class="comment">// evaluate the same point multiple times. If you&#39;re calling</span></div>
<div class="line">        <span class="comment">// out to C functions like we are, it&#39;s your responsibility to</span></div>
<div class="line">        <span class="comment">// make sure you can handle the same point being evaluated</span></div>
<div class="line">        <span class="comment">// multiple times.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The general rule is: If we require x from x_min to x_min + x_extent, and</span></div>
<div class="line">        <span class="comment">// we split by a factor &#39;factor&#39;, then:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// x_outer runs from 0 to (x_extent + factor - 1)/factor</span></div>
<div class="line">        <span class="comment">// x_inner runs from 0 to factor</span></div>
<div class="line">        <span class="comment">// x = min(x_outer * factor, x_extent - factor) + x_inner + x_min</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// In our example, x_min was 0, x_extent was 7, and factor was 3.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// However, if you write a Halide function with an update</span></div>
<div class="line">        <span class="comment">// definition (see lesson 9), then it is not safe to evaluate</span></div>
<div class="line">        <span class="comment">// the same point multiple times, so we won&#39;t apply this</span></div>
<div class="line">        <span class="comment">// trick. Instead the range of values computed will be rounded</span></div>
<div class="line">        <span class="comment">// up to the next multiple of the split factor.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fusing, tiling, and parallelizing.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We saw in the previous lesson that we can parallelize</span></div>
<div class="line">        <span class="comment">// across a variable. Here we combine it with fusing and</span></div>
<div class="line">        <span class="comment">// tiling to express a useful pattern - processing tiles in</span></div>
<div class="line">        <span class="comment">// parallel.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is where fusing shines. Fusing helps when you want to</span></div>
<div class="line">        <span class="comment">// parallelize across multiple dimensions without introducing</span></div>
<div class="line">        <span class="comment">// nested parallelism. Nested parallelism (parallel for loops</span></div>
<div class="line">        <span class="comment">// within parallel for loops) is supported by Halide, but</span></div>
<div class="line">        <span class="comment">// often gives poor performance compared to fusing the</span></div>
<div class="line">        <span class="comment">// parallel variables into a single parallel for loop.</span></div>
<div class="line"> </div>
<div class="line">        Func gradient(<span class="stringliteral">&quot;gradient_fused_tiles&quot;</span>);</div>
<div class="line">        gradient(x, y) = x + y;</div>
<div class="line">        gradient.trace_stores();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First we&#39;ll tile, then we&#39;ll fuse the tile indices and</span></div>
<div class="line">        <span class="comment">// parallelize across the combination.</span></div>
<div class="line">        Var x_outer, y_outer, x_inner, y_inner, tile_index;</div>
<div class="line">        gradient.tile(x, y, x_outer, y_outer, x_inner, y_inner, 4, 4);</div>
<div class="line">        gradient.fuse(x_outer, y_outer, tile_index);</div>
<div class="line">        gradient.parallel(tile_index);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The scheduling calls all return a reference to the Func, so</span></div>
<div class="line">        <span class="comment">// you can also chain them together into a single statement to</span></div>
<div class="line">        <span class="comment">// make things slightly clearer:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// gradient</span></div>
<div class="line">        <span class="comment">//     .tile(x, y, x_outer, y_outer, x_inner, y_inner, 4, 4)</span></div>
<div class="line">        <span class="comment">//     .fuse(x_outer, y_outer, tile_index)</span></div>
<div class="line">        <span class="comment">//     .parallel(tile_index);</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Evaluating gradient tiles in parallel\n&quot;</span>);</div>
<div class="line">        Buffer&lt;int&gt; output = gradient.realize({8, 8});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The tiles should occur in arbitrary order, but within each</span></div>
<div class="line">        <span class="comment">// tile the pixels will be traversed in row-major order. See</span></div>
<div class="line">        <span class="comment">// figures/lesson_05_parallel_tiles.gif for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Equivalent (serial) C:\n&quot;</span>);</div>
<div class="line">        <span class="comment">// This outermost loop should be a parallel for loop, but that&#39;s hard in C.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tile_index = 0; tile_index &lt; 4; tile_index++) {</div>
<div class="line">            <span class="keywordtype">int</span> y_outer = tile_index / 2;</div>
<div class="line">            <span class="keywordtype">int</span> x_outer = tile_index % 2;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 4; y_inner++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 4; x_inner++) {</div>
<div class="line">                    <span class="keywordtype">int</span> y = y_outer * 4 + y_inner;</div>
<div class="line">                    <span class="keywordtype">int</span> x = x_outer * 4 + x_inner;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Evaluating at x = %d, y = %d: %d\n&quot;</span>, x, y, x + y);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Putting it all together.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Are you ready? We&#39;re going to use all of the features above now.</span></div>
<div class="line">        Func gradient_fast(<span class="stringliteral">&quot;gradient_fast&quot;</span>);</div>
<div class="line">        gradient_fast(x, y) = x + y;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll process 64x64 tiles in parallel.</span></div>
<div class="line">        Var x_outer, y_outer, x_inner, y_inner, tile_index;</div>
<div class="line">        gradient_fast</div>
<div class="line">            .tile(x, y, x_outer, y_outer, x_inner, y_inner, 64, 64)</div>
<div class="line">            .fuse(x_outer, y_outer, tile_index)</div>
<div class="line">            .parallel(tile_index);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We&#39;ll compute two scanlines at once while we walk across</span></div>
<div class="line">        <span class="comment">// each tile. We&#39;ll also vectorize in x. The easiest way to</span></div>
<div class="line">        <span class="comment">// express this is to recursively tile again within each tile</span></div>
<div class="line">        <span class="comment">// into 4x2 subtiles, then vectorize the subtiles across x and</span></div>
<div class="line">        <span class="comment">// unroll them across y:</span></div>
<div class="line">        Var x_inner_outer, y_inner_outer, x_vectors, y_pairs;</div>
<div class="line">        gradient_fast</div>
<div class="line">            .tile(x_inner, y_inner, x_inner_outer, y_inner_outer, x_vectors, y_pairs, 4, 2)</div>
<div class="line">            .vectorize(x_vectors)</div>
<div class="line">            .unroll(y_pairs);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that we didn&#39;t do any explicit splitting or</span></div>
<div class="line">        <span class="comment">// reordering. Those are the most important primitive</span></div>
<div class="line">        <span class="comment">// operations, but mostly they are buried underneath tiling,</span></div>
<div class="line">        <span class="comment">// vectorizing, or unrolling calls.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now let&#39;s evaluate this over a range which is not a</span></div>
<div class="line">        <span class="comment">// multiple of the tile size.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If you like you can turn on tracing, but it&#39;s going to</span></div>
<div class="line">        <span class="comment">// produce a lot of printfs. Instead we&#39;ll compute the answer</span></div>
<div class="line">        <span class="comment">// both in C and Halide and see if the answers match.</span></div>
<div class="line">        Buffer&lt;int&gt; result = gradient_fast.realize({350, 250});</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// See figures/lesson_05_fast.mp4 for a visualization.</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Checking Halide result against equivalent C...\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tile_index = 0; tile_index &lt; 6 * 4; tile_index++) {</div>
<div class="line">            <span class="keywordtype">int</span> y_outer = tile_index / 4;</div>
<div class="line">            <span class="keywordtype">int</span> x_outer = tile_index % 4;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner_outer = 0; y_inner_outer &lt; 64 / 2; y_inner_outer++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner_outer = 0; x_inner_outer &lt; 64 / 4; x_inner_outer++) {</div>
<div class="line">                    <span class="comment">// We&#39;re vectorized across x</span></div>
<div class="line">                    <span class="keywordtype">int</span> x = <a name="a0"></a><a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(x_outer * 64, 350 - 64) + x_inner_outer * 4;</div>
<div class="line">                    <span class="keywordtype">int</span> x_vec[4] = {x + 0,</div>
<div class="line">                                    x + 1,</div>
<div class="line">                                    x + 2,</div>
<div class="line">                                    x + 3};</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// And we unrolled across y</span></div>
<div class="line">                    <span class="keywordtype">int</span> y_base = <a class="code" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">std::min</a>(y_outer * 64, 250 - 64) + y_inner_outer * 2;</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// y_pairs = 0</span></div>
<div class="line">                        <span class="keywordtype">int</span> y = y_base + 0;</div>
<div class="line">                        <span class="keywordtype">int</span> y_vec[4] = {y, y, y, y};</div>
<div class="line">                        <span class="keywordtype">int</span> val[4] = {x_vec[0] + y_vec[0],</div>
<div class="line">                                      x_vec[1] + y_vec[1],</div>
<div class="line">                                      x_vec[2] + y_vec[2],</div>
<div class="line">                                      x_vec[3] + y_vec[3]};</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Check the result.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {</div>
<div class="line">                            <span class="keywordflow">if</span> (result(x_vec[i], y_vec[i]) != val[i]) {</div>
<div class="line">                                printf(<span class="stringliteral">&quot;There was an error at %d %d!\n&quot;</span>,</div>
<div class="line">                                       x_vec[i], y_vec[i]);</div>
<div class="line">                                <span class="keywordflow">return</span> -1;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// y_pairs = 1</span></div>
<div class="line">                        <span class="keywordtype">int</span> y = y_base + 1;</div>
<div class="line">                        <span class="keywordtype">int</span> y_vec[4] = {y, y, y, y};</div>
<div class="line">                        <span class="keywordtype">int</span> val[4] = {x_vec[0] + y_vec[0],</div>
<div class="line">                                      x_vec[1] + y_vec[1],</div>
<div class="line">                                      x_vec[2] + y_vec[2],</div>
<div class="line">                                      x_vec[3] + y_vec[3]};</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// Check the result.</span></div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {</div>
<div class="line">                            <span class="keywordflow">if</span> (result(x_vec[i], y_vec[i]) != val[i]) {</div>
<div class="line">                                printf(<span class="stringliteral">&quot;There was an error at %d %d!\n&quot;</span>,</div>
<div class="line">                                       x_vec[i], y_vec[i]);</div>
<div class="line">                                <span class="keywordflow">return</span> -1;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Pseudo-code for the schedule:\n&quot;</span>);</div>
<div class="line">        gradient_fast.print_loop_nest();</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that in the Halide version, the algorithm is specified</span></div>
<div class="line">        <span class="comment">// once at the top, separately from the optimizations, and there</span></div>
<div class="line">        <span class="comment">// aren&#39;t that many lines of code total. Compare this to the C</span></div>
<div class="line">        <span class="comment">// version. There&#39;s more code (and it isn&#39;t even parallelized or</span></div>
<div class="line">        <span class="comment">// vectorized properly). More annoyingly, the statement of the</span></div>
<div class="line">        <span class="comment">// algorithm (the result is x plus y) is buried in multiple places</span></div>
<div class="line">        <span class="comment">// within the mess. This C code is hard to write, hard to read,</span></div>
<div class="line">        <span class="comment">// hard to debug, and hard to optimize further. This is why Halide</span></div>
<div class="line">        <span class="comment">// exists.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_halide_html"><div class="ttname"><a href="namespace_halide.html">Halide</a></div><div class="ttdoc">This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...</div><div class="ttdef"><b>Definition:</b> <a href="_add_atomic_mutex_8h_source.html#l00021">AddAtomicMutex.h:21</a></div></div>
<div class="ttc" id="anamespace_halide_html_a842daf6fbd0f87ec9ea8336cb0cdd23e"><div class="ttname"><a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">Halide::min</a></div><div class="ttdeci">Expr min(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdoc">Explicit overloads of min and max for FuncRef.</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00578">Func.h:578</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
