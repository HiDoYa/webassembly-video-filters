<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: /Users/halidenightly/build_bot_new/worker/halide-main-llvm13-x86-64-osx-cmake/halide-source/src/IROperator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_i_r_operator_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IROperator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expressions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cmath&gt;</code><br />
<code>#include &quot;<a class="el" href="_expr_8h_source.html">Expr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_tuple_8h_source.html">Tuple.h</a>&quot;</code><br />
</div>
<p><a href="_i_r_operator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">Halide::Internal::BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code.">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af11d0eaaf5222de9d1151bf81479beb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af11d0eaaf5222de9d1151bf81479beb9">Halide::Internal::is_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:af11d0eaaf5222de9d1151bf81479beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants.">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#af11d0eaaf5222de9d1151bf81479beb9">More...</a><br /></td></tr>
<tr class="separator:af11d0eaaf5222de9d1151bf81479beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0438766d0040aa39c5f420f1a92b01b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad0438766d0040aa39c5f420f1a92b01b">Halide::Internal::is_const</a> (const Expr &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:ad0438766d0040aa39c5f420f1a92b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#ad0438766d0040aa39c5f420f1a92b01b">More...</a><br /></td></tr>
<tr class="separator:ad0438766d0040aa39c5f420f1a92b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f803a9899cc2d96a93179dba4bf21f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a98f803a9899cc2d96a93179dba4bf21f">Halide::Internal::as_const_int</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a98f803a9899cc2d96a93179dba4bf21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a98f803a9899cc2d96a93179dba4bf21f">More...</a><br /></td></tr>
<tr class="separator:a98f803a9899cc2d96a93179dba4bf21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c472a5cc4013b179510625b02bf6d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae2c472a5cc4013b179510625b02bf6d6">Halide::Internal::as_const_uint</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae2c472a5cc4013b179510625b02bf6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants.">UIntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#ae2c472a5cc4013b179510625b02bf6d6">More...</a><br /></td></tr>
<tr class="separator:ae2c472a5cc4013b179510625b02bf6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6252d95fc57aad0465caf882eded56bb"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6252d95fc57aad0465caf882eded56bb">Halide::Internal::as_const_float</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a6252d95fc57aad0465caf882eded56bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a6252d95fc57aad0465caf882eded56bb">More...</a><br /></td></tr>
<tr class="separator:a6252d95fc57aad0465caf882eded56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f2b30c213250c3ba20c4d211f5b00f">Halide::Internal::is_const_power_of_two_integer</a> (const Expr &amp;e, int *bits)</td></tr>
<tr class="memdesc:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="namespace_halide_1_1_internal.html#aa5f2b30c213250c3ba20c4d211f5b00f">More...</a><br /></td></tr>
<tr class="separator:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26b6233cff17bdbf097bfe981e096c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f26b6233cff17bdbf097bfe981e096c">Halide::Internal::is_positive_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a5f26b6233cff17bdbf097bfe981e096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a5f26b6233cff17bdbf097bfe981e096c">More...</a><br /></td></tr>
<tr class="separator:a5f26b6233cff17bdbf097bfe981e096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e57c1aaa1719ed42fac6dc6661ebe90">Halide::Internal::is_negative_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a0e57c1aaa1719ed42fac6dc6661ebe90">More...</a><br /></td></tr>
<tr class="separator:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb4bb1c7164222794e270f58c428eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0eb4bb1c7164222794e270f58c428eb7">Halide::Internal::is_undef</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a0eb4bb1c7164222794e270f58c428eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="namespace_halide_1_1_internal.html#a0eb4bb1c7164222794e270f58c428eb7">More...</a><br /></td></tr>
<tr class="separator:a0eb4bb1c7164222794e270f58c428eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0490ee622445eeba11163a7a936177d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0490ee622445eeba11163a7a936177d7">Halide::Internal::is_const_zero</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a0490ee622445eeba11163a7a936177d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a0490ee622445eeba11163a7a936177d7">More...</a><br /></td></tr>
<tr class="separator:a0490ee622445eeba11163a7a936177d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534f733e8b7b7c617fd03714ccca697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3534f733e8b7b7c617fd03714ccca697">Halide::Internal::is_const_one</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a3534f733e8b7b7c617fd03714ccca697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a3534f733e8b7b7c617fd03714ccca697">More...</a><br /></td></tr>
<tr class="separator:a3534f733e8b7b7c617fd03714ccca697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a916dccb9f4ad5763ce86721ab3187cfc">Halide::Internal::is_no_op</a> (const Stmt &amp;s)</td></tr>
<tr class="memdesc:a916dccb9f4ad5763ce86721ab3187cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> node of a constant)  <a href="namespace_halide_1_1_internal.html#a916dccb9f4ad5763ce86721ab3187cfc">More...</a><br /></td></tr>
<tr class="separator:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325254f314a3811cc5ebebf4497466d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">Halide::Internal::is_pure</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a8325254f314a3811cc5ebebf4497466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, and 2) Evaluating it has no side-effects.  <a href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">More...</a><br /></td></tr>
<tr class="separator:a8325254f314a3811cc5ebebf4497466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a5a057ef6ceb8462dbca18eb9020bc297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">More...</a><br /></td></tr>
<tr class="separator:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69927d11c0fe7c6cf4092a811f6676d7">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="separator:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3a72bc2d5b95e6a43e803a9f7c4acea">Halide::Internal::make_const</a> (Type t, double val)</td></tr>
<tr class="separator:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">Halide::Internal::make_const</a> (Type t, bool val)</td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">Halide::Internal::make_const</a> (Type t, float val)</td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">Halide::Internal::make_const</a> (Type t, float16_t val)</td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee83b2e74ffd9ee144d046aebbf87cca"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aee83b2e74ffd9ee144d046aebbf87cca">Halide::Internal::make_signed_integer_overflow</a> (Type type)</td></tr>
<tr class="memdesc:aee83b2e74ffd9ee144d046aebbf87cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unique signed_integer_overflow <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>.  <a href="namespace_halide_1_1_internal.html#aee83b2e74ffd9ee144d046aebbf87cca">More...</a><br /></td></tr>
<tr class="separator:aee83b2e74ffd9ee144d046aebbf87cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de10096d923cdc0f02582981b718854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">Halide::Internal::check_representable</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a2de10096d923cdc0f02582981b718854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">More...</a><br /></td></tr>
<tr class="separator:a2de10096d923cdc0f02582981b718854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2aa7992959c35ebe5895999b762b34"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">Halide::Internal::make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:ace2aa7992959c35ebe5895999b762b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">More...</a><br /></td></tr>
<tr class="separator:ace2aa7992959c35ebe5895999b762b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">Halide::Internal::make_zero</a> (Type t)</td></tr>
<tr class="memdesc:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">More...</a><br /></td></tr>
<tr class="separator:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e5ab6b1524fd81132823c77c35d717"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">Halide::Internal::make_one</a> (Type t)</td></tr>
<tr class="memdesc:a01e5ab6b1524fd81132823c77c35d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">More...</a><br /></td></tr>
<tr class="separator:a01e5ab6b1524fd81132823c77c35d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">Halide::Internal::make_two</a> (Type t)</td></tr>
<tr class="memdesc:a14bdd8230cefd6bf9f84ac909311d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">More...</a><br /></td></tr>
<tr class="separator:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb413640f7f46493733fa33d95ea9fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">Halide::Internal::const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a5fb413640f7f46493733fa33d95ea9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">More...</a><br /></td></tr>
<tr class="separator:a5fb413640f7f46493733fa33d95ea9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">Halide::Internal::const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ab94c84e726218144cf4c5d3a08b38f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">More...</a><br /></td></tr>
<tr class="separator:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">Halide::Internal::lossless_cast</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:ae1e5b44f4f584318f9065bcf39c75c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">More...</a><br /></td></tr>
<tr class="separator:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626e40f7f540859a774c59d38a673bd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa626e40f7f540859a774c59d38a673bd">Halide::Internal::lossless_negate</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:aa626e40f7f540859a774c59d38a673bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to negate x without introducing new IR and without overflow.  <a href="namespace_halide_1_1_internal.html#aa626e40f7f540859a774c59d38a673bd">More...</a><br /></td></tr>
<tr class="separator:aa626e40f7f540859a774c59d38a673bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365bfad96972abe9e008bb1b601223f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Halide::Internal::match_types</a> (Expr &amp;a, Expr &amp;b)</td></tr>
<tr class="memdesc:a365bfad96972abe9e008bb1b601223f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">More...</a><br /></td></tr>
<tr class="separator:a365bfad96972abe9e008bb1b601223f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdcef00b83af48e34920fd58d1da84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addfdcef00b83af48e34920fd58d1da84">Halide::Internal::match_types_bitwise</a> (Expr &amp;a, Expr &amp;b, const char *op_name)</td></tr>
<tr class="memdesc:addfdcef00b83af48e34920fd58d1da84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that both expressions are integer types and are either both signed or both unsigned.  <a href="namespace_halide_1_1_internal.html#addfdcef00b83af48e34920fd58d1da84">More...</a><br /></td></tr>
<tr class="separator:addfdcef00b83af48e34920fd58d1da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81818fbb02804a8e8f9056a0a24e0f56"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a81818fbb02804a8e8f9056a0a24e0f56">Halide::Internal::halide_log</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:a81818fbb02804a8e8f9056a0a24e0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s vectorizable transcendentals.  <a href="namespace_halide_1_1_internal.html#a81818fbb02804a8e8f9056a0a24e0f56">More...</a><br /></td></tr>
<tr class="separator:a81818fbb02804a8e8f9056a0a24e0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f176922ae87268701a0234b48ead883"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f176922ae87268701a0234b48ead883">Halide::Internal::halide_exp</a> (const Expr &amp;a)</td></tr>
<tr class="separator:a4f176922ae87268701a0234b48ead883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30907ab1fd2dfde808351ed05d262548"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a30907ab1fd2dfde808351ed05d262548">Halide::Internal::halide_erf</a> (const Expr &amp;a)</td></tr>
<tr class="separator:a30907ab1fd2dfde808351ed05d262548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec662f503947166115071493eaa00780"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">Halide::Internal::raise_to_integer_power</a> (Expr a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aec662f503947166115071493eaa00780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">More...</a><br /></td></tr>
<tr class="separator:aec662f503947166115071493eaa00780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839473cf858ba53326b678db072411d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">Halide::Internal::split_into_ands</a> (const Expr &amp;cond, std::vector&lt; Expr &gt; &amp;result)</td></tr>
<tr class="memdesc:a839473cf858ba53326b678db072411d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">More...</a><br /></td></tr>
<tr class="separator:a839473cf858ba53326b678db072411d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa6f512f02bfc12c8a4d1d87ab77bc0b6">Halide::Internal::strided_ramp_base</a> (const Expr &amp;e, int stride=1)</td></tr>
<tr class="memdesc:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If e is a ramp expression with stride, default 1, return the base, otherwise undefined.  <a href="namespace_halide_1_1_internal.html#aa6f512f02bfc12c8a4d1d87ab77bc0b6">More...</a><br /></td></tr>
<tr class="separator:aa6f512f02bfc12c8a4d1d87ab77bc0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>.  <a href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">More...</a><br /></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a> (T a, T b)</td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">Halide::Internal::mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">Halide::Internal::mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa13a82f37fe6336c154122f66d294523">Halide::Internal::div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3965c871f086a60fda2cc31e678d050a">Halide::Internal::div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df709582bdb9d7844efa9cd6b69625"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7df709582bdb9d7844efa9cd6b69625">Halide::Internal::remove_likelies</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:af7df709582bdb9d7844efa9cd6b69625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that is identical to the input <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <a href="namespace_halide_1_1_internal.html#af7df709582bdb9d7844efa9cd6b69625">More...</a><br /></td></tr>
<tr class="separator:af7df709582bdb9d7844efa9cd6b69625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">Halide::Internal::remove_likelies</a> (const Stmt &amp;s)</td></tr>
<tr class="memdesc:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a> that is identical to the input <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>, but with all calls to <a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764" title="Expressions tagged with this intrinsic are considered to be part of the steady state of some loop wit...">likely()</a> and <a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab" title="Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.">likely_if_innermost()</a> removed.  <a href="namespace_halide_1_1_internal.html#a1bcf82ffcc64c0c61b7cb7fc6ac7c916">More...</a><br /></td></tr>
<tr class="separator:a1bcf82ffcc64c0c61b7cb7fc6ac7c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acf7ed2ca593eca53111eaf753a7fc9bf">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d7c2f51029190ae224290688b7c4c3b">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:a4d7c2f51029190ae224290688b7c4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adda140fdf727dfa11f6f3151fc4f7661">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, Expr arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:adda140fdf727dfa11f6f3151fc4f7661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da582526c949b1bd11ede8f20bce2e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12da582526c949b1bd11ede8f20bce2e">Halide::Internal::requirement_failed_error</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:a12da582526c949b1bd11ede8f20bce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082d3bda0d60128ae127d0879e7e38c9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a082d3bda0d60128ae127d0879e7e38c9">Halide::Internal::memoize_tag_helper</a> (Expr result, const std::vector&lt; Expr &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:a082d3bda0d60128ae127d0879e7e38c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75f4cdf56ac6f31a5f0870b66e3743e9">Halide::Internal::widening_add</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) + widen(b).  <a href="namespace_halide_1_1_internal.html#a75f4cdf56ac6f31a5f0870b66e3743e9">More...</a><br /></td></tr>
<tr class="separator:a75f4cdf56ac6f31a5f0870b66e3743e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa64fcd8d11f7e4bdf153ff760c73c46b">Halide::Internal::widening_mul</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) * widen(b).  <a href="namespace_halide_1_1_internal.html#aa64fcd8d11f7e4bdf153ff760c73c46b">More...</a><br /></td></tr>
<tr class="separator:aa64fcd8d11f7e4bdf153ff760c73c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f14f11164b1390669a9ce151b57a3af"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f14f11164b1390669a9ce151b57a3af">Halide::Internal::widening_sub</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a6f14f11164b1390669a9ce151b57a3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) - widen(b).  <a href="namespace_halide_1_1_internal.html#a6f14f11164b1390669a9ce151b57a3af">More...</a><br /></td></tr>
<tr class="separator:a6f14f11164b1390669a9ce151b57a3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4eb6ea1b5e17d86b611b69e97f9bbd18">Halide::Internal::widening_shift_left</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) &lt;&lt; b.  <a href="namespace_halide_1_1_internal.html#a4eb6ea1b5e17d86b611b69e97f9bbd18">More...</a><br /></td></tr>
<tr class="separator:a4eb6ea1b5e17d86b611b69e97f9bbd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d54b8b13cf47de21ea8005decd03a14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d54b8b13cf47de21ea8005decd03a14">Halide::Internal::widening_shift_right</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3d54b8b13cf47de21ea8005decd03a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute widen(a) &gt;&gt; b.  <a href="namespace_halide_1_1_internal.html#a3d54b8b13cf47de21ea8005decd03a14">More...</a><br /></td></tr>
<tr class="separator:a3d54b8b13cf47de21ea8005decd03a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd47ddc60a5b16ebf7e68ae1ba2ba483">Halide::Internal::rounding_shift_left</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_add(a, (1 &gt;&gt; min(b, 0)) / 2) &lt;&lt; b.  <a href="namespace_halide_1_1_internal.html#abd47ddc60a5b16ebf7e68ae1ba2ba483">More...</a><br /></td></tr>
<tr class="separator:abd47ddc60a5b16ebf7e68ae1ba2ba483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d761851379580a9605f799491f933f7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d761851379580a9605f799491f933f7">Halide::Internal::rounding_shift_right</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3d761851379580a9605f799491f933f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_add(a, (1 &lt;&lt; max(b, 0)) / 2) &gt;&gt; b.  <a href="namespace_halide_1_1_internal.html#a3d761851379580a9605f799491f933f7">More...</a><br /></td></tr>
<tr class="separator:a3d761851379580a9605f799491f933f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b125d7fefcbcf2962d41efd87248be"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad6b125d7fefcbcf2962d41efd87248be">Halide::Internal::saturating_add</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ad6b125d7fefcbcf2962d41efd87248be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_narrow(widen(a) + widen(b))  <a href="namespace_halide_1_1_internal.html#ad6b125d7fefcbcf2962d41efd87248be">More...</a><br /></td></tr>
<tr class="separator:ad6b125d7fefcbcf2962d41efd87248be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ad280ea975ec61eeb27cb27c4f4024"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55ad280ea975ec61eeb27cb27c4f4024">Halide::Internal::saturating_sub</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a55ad280ea975ec61eeb27cb27c4f4024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute saturating_narrow(widen(a) - widen(b))  <a href="namespace_halide_1_1_internal.html#a55ad280ea975ec61eeb27cb27c4f4024">More...</a><br /></td></tr>
<tr class="separator:a55ad280ea975ec61eeb27cb27c4f4024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31db44d292fd0875a78d40831feb81c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae31db44d292fd0875a78d40831feb81c">Halide::Internal::halving_add</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ae31db44d292fd0875a78d40831feb81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) + widen(b)) / 2)  <a href="namespace_halide_1_1_internal.html#ae31db44d292fd0875a78d40831feb81c">More...</a><br /></td></tr>
<tr class="separator:ae31db44d292fd0875a78d40831feb81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a17b5151e7b54f3743f35b0d1fe2a1112">Halide::Internal::rounding_halving_add</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) + widen(b) + 1) / 2)  <a href="namespace_halide_1_1_internal.html#a17b5151e7b54f3743f35b0d1fe2a1112">More...</a><br /></td></tr>
<tr class="separator:a17b5151e7b54f3743f35b0d1fe2a1112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3e3170f0ecff7b28a97b8f959879ddf5">Halide::Internal::halving_sub</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) - widen(b)) / 2)  <a href="namespace_halide_1_1_internal.html#a3e3170f0ecff7b28a97b8f959879ddf5">More...</a><br /></td></tr>
<tr class="separator:a3e3170f0ecff7b28a97b8f959879ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992108a27232a3ccdf771112a4a296a0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a992108a27232a3ccdf771112a4a296a0">Halide::Internal::rounding_halving_sub</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a992108a27232a3ccdf771112a4a296a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute narrow((widen(a) - widen(b) + 1) / 2)  <a href="namespace_halide_1_1_internal.html#a992108a27232a3ccdf771112a4a296a0">More...</a><br /></td></tr>
<tr class="separator:a992108a27232a3ccdf771112a4a296a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">Halide::cast</a> (Expr a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">More...</a><br /></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">Halide::cast</a> (Type t, Expr a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br /></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">Halide::operator+</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br /></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d7f25e89e1f74d7d76e370161f7358"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">Halide::operator+</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a28d7f25e89e1f74d7d76e370161f7358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">More...</a><br /></td></tr>
<tr class="separator:a28d7f25e89e1f74d7d76e370161f7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95625f031290fffefab2365275c4981f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a95625f031290fffefab2365275c4981f">Halide::operator+</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a95625f031290fffefab2365275c4981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant integer and an expression.  <a href="namespace_halide.html#a95625f031290fffefab2365275c4981f">More...</a><br /></td></tr>
<tr class="separator:a95625f031290fffefab2365275c4981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">Halide::operator+=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">More...</a><br /></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">Halide::operator-</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">More...</a><br /></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">Halide::operator-</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant integer from an expression.  <a href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">More...</a><br /></td></tr>
<tr class="separator:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">Halide::operator-</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a929a86c18d4952daa3d1bad7b2b448fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts an expression from a constant integer.  <a href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">More...</a><br /></td></tr>
<tr class="separator:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">Halide::operator-</a> (Expr a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">More...</a><br /></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">Halide::operator-=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br /></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">Halide::operator*</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">More...</a><br /></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add192217868f9861b756a85d212c0ecd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#add192217868f9861b756a85d212c0ecd">Halide::operator*</a> (Expr a, int b)</td></tr>
<tr class="memdesc:add192217868f9861b756a85d212c0ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an expression and a constant integer.  <a href="namespace_halide.html#add192217868f9861b756a85d212c0ecd">More...</a><br /></td></tr>
<tr class="separator:add192217868f9861b756a85d212c0ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93ddfca97d22f96789eea9b8c5d355"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">Halide::operator*</a> (int a, Expr b)</td></tr>
<tr class="memdesc:abe93ddfca97d22f96789eea9b8c5d355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a constant integer and an expression.  <a href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">More...</a><br /></td></tr>
<tr class="separator:abe93ddfca97d22f96789eea9b8c5d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">Halide::operator*=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br /></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">Halide::operator/</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br /></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">Halide::operator/=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">More...</a><br /></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">Halide::operator/</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an expression by a constant integer.  <a href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">More...</a><br /></td></tr>
<tr class="separator:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351f5d64c664ba9d65178161e1937db"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">Halide::operator/</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a8351f5d64c664ba9d65178161e1937db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a constant integer by an expression.  <a href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">More...</a><br /></td></tr>
<tr class="separator:a8351f5d64c664ba9d65178161e1937db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">Halide::operator%</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br /></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">Halide::operator%</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods an expression by a constant integer.  <a href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">More...</a><br /></td></tr>
<tr class="separator:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2825498112ddec5da6caa3deaf435e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb2825498112ddec5da6caa3deaf435e">Halide::operator%</a> (int a, Expr b)</td></tr>
<tr class="memdesc:acb2825498112ddec5da6caa3deaf435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods a constant integer by an expression.  <a href="namespace_halide.html#acb2825498112ddec5da6caa3deaf435e">More...</a><br /></td></tr>
<tr class="separator:acb2825498112ddec5da6caa3deaf435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">Halide::operator&gt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">More...</a><br /></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014703a60d365b71dee6def5cb7a6f2c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">Halide::operator&gt;</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a014703a60d365b71dee6def5cb7a6f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than a constant integer.  <a href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">More...</a><br /></td></tr>
<tr class="separator:a014703a60d365b71dee6def5cb7a6f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af05e2a8405c578614399da8ffba005"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">Halide::operator&gt;</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a4af05e2a8405c578614399da8ffba005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than an expression.  <a href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">More...</a><br /></td></tr>
<tr class="separator:a4af05e2a8405c578614399da8ffba005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">Halide::operator&lt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">More...</a><br /></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b253d012615166e933d5b39d0bc83fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">Halide::operator&lt;</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a8b253d012615166e933d5b39d0bc83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than a constant integer.  <a href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">More...</a><br /></td></tr>
<tr class="separator:a8b253d012615166e933d5b39d0bc83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee20253bf83a4cdd89537cc6e8161524"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">Halide::operator&lt;</a> (int a, Expr b)</td></tr>
<tr class="memdesc:aee20253bf83a4cdd89537cc6e8161524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than an expression.  <a href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">More...</a><br /></td></tr>
<tr class="separator:aee20253bf83a4cdd89537cc6e8161524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">Halide::operator&lt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br /></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">Halide::operator&lt;=</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a0616c33325d7b8ee67a4e2e305f5f375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than or equal to a constant integer.  <a href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">More...</a><br /></td></tr>
<tr class="separator:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b263f999854f1e7e1ee8602998bb016"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">Halide::operator&lt;=</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a6b263f999854f1e7e1ee8602998bb016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than or equal to an expression.  <a href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">More...</a><br /></td></tr>
<tr class="separator:a6b263f999854f1e7e1ee8602998bb016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">Halide::operator&gt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br /></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc55d0783c46ace37a0b413d82dd100"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9fc55d0783c46ace37a0b413d82dd100">Halide::operator&gt;=</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a9fc55d0783c46ace37a0b413d82dd100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than or equal to a constant integer.  <a href="namespace_halide.html#a9fc55d0783c46ace37a0b413d82dd100">More...</a><br /></td></tr>
<tr class="separator:a9fc55d0783c46ace37a0b413d82dd100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a977de0ab82ad7e0ac7d4c6321554d6c9">Halide::operator&gt;=</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than or equal to an expression.  <a href="namespace_halide.html#a977de0ab82ad7e0ac7d4c6321554d6c9">More...</a><br /></td></tr>
<tr class="separator:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">Halide::operator==</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br /></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">Halide::operator==</a> (Expr a, int b)</td></tr>
<tr class="memdesc:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is equal to a constant integer.  <a href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">More...</a><br /></td></tr>
<tr class="separator:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115d4df85c9d3b9e9221f0c62c765858"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">Halide::operator==</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a115d4df85c9d3b9e9221f0c62c765858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is equal to an expression.  <a href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">More...</a><br /></td></tr>
<tr class="separator:a115d4df85c9d3b9e9221f0c62c765858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">Halide::operator!=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">More...</a><br /></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">Halide::operator!=</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is not equal to a constant integer.  <a href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">More...</a><br /></td></tr>
<tr class="separator:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c1c720efb61b649e495eac92c0c6eb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">Halide::operator!=</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a82c1c720efb61b649e495eac92c0c6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is not equal to an expression.  <a href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">More...</a><br /></td></tr>
<tr class="separator:a82c1c720efb61b649e495eac92c0c6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">Halide::operator&amp;&amp;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br /></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c979cf5df557f554752e177655026f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab6c979cf5df557f554752e177655026f">Halide::operator&amp;&amp;</a> (Expr a, bool b)</td></tr>
<tr class="memdesc:ab6c979cf5df557f554752e177655026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool.  <a href="namespace_halide.html#ab6c979cf5df557f554752e177655026f">More...</a><br /></td></tr>
<tr class="separator:ab6c979cf5df557f554752e177655026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eda141b66c0d5bdc3b3faebc229b44"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a01eda141b66c0d5bdc3b3faebc229b44">Halide::operator&amp;&amp;</a> (bool a, Expr b)</td></tr>
<tr class="separator:a01eda141b66c0d5bdc3b3faebc229b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">Halide::operator||</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="namespace_halide.html#a3528931d7929d533103ada2badca092c">More...</a><br /></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38218eafbf9de824d559a4ff593a5617"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38218eafbf9de824d559a4ff593a5617">Halide::operator||</a> (Expr a, bool b)</td></tr>
<tr class="memdesc:a38218eafbf9de824d559a4ff593a5617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> and a bool.  <a href="namespace_halide.html#a38218eafbf9de824d559a4ff593a5617">More...</a><br /></td></tr>
<tr class="separator:a38218eafbf9de824d559a4ff593a5617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131cefcee0f570a9bbf98121326f7d8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3131cefcee0f570a9bbf98121326f7d8">Halide::operator||</a> (bool a, Expr b)</td></tr>
<tr class="separator:a3131cefcee0f570a9bbf98121326f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">Halide::operator!</a> (Expr a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">More...</a><br /></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">Halide::max</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br /></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d007e9eff86b8854b12840303294b9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">Halide::max</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a65d007e9eff86b8854b12840303294b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expression and a constant integer.  <a href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">More...</a><br /></td></tr>
<tr class="separator:a65d007e9eff86b8854b12840303294b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950ad100fb78022bf9c49003d6ccc19"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">Halide::max</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a7950ad100fb78022bf9c49003d6ccc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of a constant integer and an expression.  <a href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">More...</a><br /></td></tr>
<tr class="separator:a7950ad100fb78022bf9c49003d6ccc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30475861d1493c3353e62ec77a3b516"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad30475861d1493c3353e62ec77a3b516">Halide::max</a> (float a, Expr b)</td></tr>
<tr class="separator:ad30475861d1493c3353e62ec77a3b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba49d8dff61c221859c462054375258"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ba49d8dff61c221859c462054375258">Halide::max</a> (Expr a, float b)</td></tr>
<tr class="separator:a7ba49d8dff61c221859c462054375258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ff27a6f9948cb752117cf7064449f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1ff27a6f9948cb752117cf7064449f"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b1ff27a6f9948cb752117cf7064449f">Halide::max</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a6b1ff27a6f9948cb752117cf7064449f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#a6b1ff27a6f9948cb752117cf7064449f">More...</a><br /></td></tr>
<tr class="separator:a6b1ff27a6f9948cb752117cf7064449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">Halide::min</a> (Expr a, Expr b)</td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade891378c7247910129a61258cf00a56"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ade891378c7247910129a61258cf00a56">Halide::min</a> (Expr a, int b)</td></tr>
<tr class="memdesc:ade891378c7247910129a61258cf00a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expression and a constant integer.  <a href="namespace_halide.html#ade891378c7247910129a61258cf00a56">More...</a><br /></td></tr>
<tr class="separator:ade891378c7247910129a61258cf00a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">Halide::min</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of a constant integer and an expression.  <a href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">More...</a><br /></td></tr>
<tr class="separator:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f42d034894ac2f27a09f73627437a0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a79f42d034894ac2f27a09f73627437a0">Halide::min</a> (float a, Expr b)</td></tr>
<tr class="separator:a79f42d034894ac2f27a09f73627437a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68e4e576c9e0ca6588c3e5bc54856589">Halide::min</a> (Expr a, float b)</td></tr>
<tr class="separator:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa8132b0bbea7c1a5146765a22d981e5c">Halide::min</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:aa8132b0bbea7c1a5146765a22d981e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">Internal::match_types</a>.  <a href="namespace_halide.html#aa8132b0bbea7c1a5146765a22d981e5c">More...</a><br /></td></tr>
<tr class="separator:aa8132b0bbea7c1a5146765a22d981e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">Halide::operator+</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">More...</a><br /></td></tr>
<tr class="separator:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b7b04f00436d90aad52a74a230181"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a704b7b04f00436d90aad52a74a230181">Halide::operator+</a> (float a, Expr b)</td></tr>
<tr class="separator:a704b7b04f00436d90aad52a74a230181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb362e84f0a152acd46b3ab42da29b9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aacb362e84f0a152acd46b3ab42da29b9">Halide::operator-</a> (Expr a, float b)</td></tr>
<tr class="separator:aacb362e84f0a152acd46b3ab42da29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d01cda7bea93467113a5d32b00467a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47d01cda7bea93467113a5d32b00467a">Halide::operator-</a> (float a, Expr b)</td></tr>
<tr class="separator:a47d01cda7bea93467113a5d32b00467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ccd78b6034d015358838478f4147b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a585ccd78b6034d015358838478f4147b">Halide::operator*</a> (Expr a, float b)</td></tr>
<tr class="separator:a585ccd78b6034d015358838478f4147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a96077a9c1ec602e9196f7fe0a6dec2bf">Halide::operator*</a> (float a, Expr b)</td></tr>
<tr class="separator:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a77dce878e2e6156e9e9ec00f240c3de3">Halide::operator/</a> (Expr a, float b)</td></tr>
<tr class="separator:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c179840fe2018ea7106e3c7305516b6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2c179840fe2018ea7106e3c7305516b6">Halide::operator/</a> (float a, Expr b)</td></tr>
<tr class="separator:a2c179840fe2018ea7106e3c7305516b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ffb094c58badc44f353a94681dbfe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a7ffb094c58badc44f353a94681dbfe">Halide::operator%</a> (Expr a, float b)</td></tr>
<tr class="separator:a9a7ffb094c58badc44f353a94681dbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced81e366b73b3c1503905f0c594c516"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aced81e366b73b3c1503905f0c594c516">Halide::operator%</a> (float a, Expr b)</td></tr>
<tr class="separator:aced81e366b73b3c1503905f0c594c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fb3edae8f6879c195ad373c0d7a7b86">Halide::operator&gt;</a> (Expr a, float b)</td></tr>
<tr class="separator:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe14360d4dab7d8119572f3aefdbbb25"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe14360d4dab7d8119572f3aefdbbb25">Halide::operator&gt;</a> (float a, Expr b)</td></tr>
<tr class="separator:abe14360d4dab7d8119572f3aefdbbb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5730454f894a93bebbaf72dbc714e1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4e5730454f894a93bebbaf72dbc714e1">Halide::operator&lt;</a> (Expr a, float b)</td></tr>
<tr class="separator:a4e5730454f894a93bebbaf72dbc714e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47dd5b9660e5510cc23bbf8fa8e5f4b7">Halide::operator&lt;</a> (float a, Expr b)</td></tr>
<tr class="separator:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070410b979a0b62fdb67d6f13fbdc1d4">Halide::operator&gt;=</a> (Expr a, float b)</td></tr>
<tr class="separator:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2e1d96814511a965a43e835947966e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4d2e1d96814511a965a43e835947966e">Halide::operator&gt;=</a> (float a, Expr b)</td></tr>
<tr class="separator:a4d2e1d96814511a965a43e835947966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944b1232804900cdde74619fbfeda68"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab944b1232804900cdde74619fbfeda68">Halide::operator&lt;=</a> (Expr a, float b)</td></tr>
<tr class="separator:ab944b1232804900cdde74619fbfeda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5fc2ce1a66bdb1877f337436295cfc90">Halide::operator&lt;=</a> (float a, Expr b)</td></tr>
<tr class="separator:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ebe338276d9e91223e9f7f57eaa46"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a506ebe338276d9e91223e9f7f57eaa46">Halide::operator==</a> (Expr a, float b)</td></tr>
<tr class="separator:a506ebe338276d9e91223e9f7f57eaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae54bb0b329c0bb93eb19a2dc3a4e2285">Halide::operator==</a> (float a, Expr b)</td></tr>
<tr class="separator:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32c2846c632946f95a2ea9f60da704"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abf32c2846c632946f95a2ea9f60da704">Halide::operator!=</a> (Expr a, float b)</td></tr>
<tr class="separator:abf32c2846c632946f95a2ea9f60da704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af60a387c587e80408e8fa8b63bfb7cdb">Halide::operator!=</a> (float a, Expr b)</td></tr>
<tr class="separator:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b1c066344e4816e822a467522bb1f1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">Halide::clamp</a> (Expr a, const Expr &amp;min_val, const Expr &amp;max_val)</td></tr>
<tr class="memdesc:a40b1c066344e4816e822a467522bb1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="namespace_halide.html#a40b1c066344e4816e822a467522bb1f1">More...</a><br /></td></tr>
<tr class="separator:a40b1c066344e4816e822a467522bb1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">Halide::abs</a> (Expr a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br /></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">Halide::absd</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br /></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a> (Expr condition, Expr true_value, Expr false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br /></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Args... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac19df75a6ad3b8a7e7a2acaa84c5c9eb">Halide::select</a> (Expr c0, Expr v0, Expr c1, Expr v1, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="namespace_halide.html#ac19df75a6ad3b8a7e7a2acaa84c5c9eb">More...</a><br /></td></tr>
<tr class="separator:ac19df75a6ad3b8a7e7a2acaa84c5c9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="memItemLeft" align="right" valign="top">Tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">Halide::tuple_select</a> (const Tuple &amp;condition, const Tuple &amp;true_value, const Tuple &amp;false_value)</td></tr>
<tr class="memdesc:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of ternary <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples.  <a href="namespace_halide.html#a8f04c3a60a6f50464ee6aca3d484ee3e">More...</a><br /></td></tr>
<tr class="separator:a8f04c3a60a6f50464ee6aca3d484ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace388be6ec6a0d3e2ad02993aba8cc41"><td class="memItemLeft" align="right" valign="top">Tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ace388be6ec6a0d3e2ad02993aba8cc41">Halide::tuple_select</a> (const Expr &amp;condition, const Tuple &amp;true_value, const Tuple &amp;false_value)</td></tr>
<tr class="separator:ace388be6ec6a0d3e2ad02993aba8cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memTemplItemLeft" align="right" valign="top">Tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae2fe5d43378f4d24f33980dbf2a8094f">Halide::tuple_select</a> (const Tuple &amp;c0, const Tuple &amp;v0, const Tuple &amp;c1, const Tuple &amp;v1, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of multiway <a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select()</a>, but taking/returning tuples.  <a href="namespace_halide.html#ae2fe5d43378f4d24f33980dbf2a8094f">More...</a><br /></td></tr>
<tr class="separator:ae2fe5d43378f4d24f33980dbf2a8094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134581388acb9d7ef198a759d733e2a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4134581388acb9d7ef198a759d733e2a"><td class="memTemplItemLeft" align="right" valign="top">Tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4134581388acb9d7ef198a759d733e2a">Halide::tuple_select</a> (const Expr &amp;c0, const Tuple &amp;v0, const Expr &amp;c1, const Tuple &amp;v1, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a4134581388acb9d7ef198a759d733e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872ea25baf89339321f85340ed48c14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">Halide::mux</a> (const Expr &amp;id, const std::initializer_list&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a6872ea25baf89339321f85340ed48c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oftentimes we want to pack a list of expressions with the same type into a channel dimension, e.g., img(x, y, c) = select(c == 0, 100, // Red c == 1, 50, // Green 25); // Blue This is tedious when the list is long.  <a href="namespace_halide.html#a6872ea25baf89339321f85340ed48c14">More...</a><br /></td></tr>
<tr class="separator:a6872ea25baf89339321f85340ed48c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448d91aca15f1e6a5610fbc8cc0b15b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1448d91aca15f1e6a5610fbc8cc0b15b">Halide::mux</a> (const Expr &amp;id, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="separator:a1448d91aca15f1e6a5610fbc8cc0b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1093d3bc68908f364e9bddf5803286"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4b1093d3bc68908f364e9bddf5803286">Halide::mux</a> (const Expr &amp;id, const Tuple &amp;values)</td></tr>
<tr class="separator:a4b1093d3bc68908f364e9bddf5803286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">Halide::sin</a> (Expr x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">More...</a><br /></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">Halide::asin</a> (Expr x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br /></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">Halide::cos</a> (Expr x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br /></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">Halide::acos</a> (Expr x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">More...</a><br /></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">Halide::tan</a> (Expr x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br /></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">Halide::atan</a> (Expr x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br /></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">Halide::atan2</a> (Expr y, Expr x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br /></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">Halide::sinh</a> (Expr x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">More...</a><br /></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">Halide::asinh</a> (Expr x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br /></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">Halide::cosh</a> (Expr x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">More...</a><br /></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">Halide::acosh</a> (Expr x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br /></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">Halide::tanh</a> (Expr x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">More...</a><br /></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">Halide::atanh</a> (Expr x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br /></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">Halide::sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">More...</a><br /></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410c523b5f2f78733ca45d946a9ededb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a410c523b5f2f78733ca45d946a9ededb">Halide::hypot</a> (const Expr &amp;x, const Expr &amp;y)</td></tr>
<tr class="memdesc:a410c523b5f2f78733ca45d946a9ededb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="namespace_halide.html#a410c523b5f2f78733ca45d946a9ededb">More...</a><br /></td></tr>
<tr class="separator:a410c523b5f2f78733ca45d946a9ededb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">Halide::exp</a> (Expr x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">More...</a><br /></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">Halide::log</a> (Expr x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">More...</a><br /></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">Halide::pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br /></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afcc3e2a1e80bd2b512b38aa87aa91f9e">Halide::erf</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="namespace_halide.html#afcc3e2a1e80bd2b512b38aa87aa91f9e">More...</a><br /></td></tr>
<tr class="separator:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f774e4779466acb57a6e571cb636ba6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f774e4779466acb57a6e571cb636ba6">Halide::fast_sin</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a8f774e4779466acb57a6e571cb636ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast vectorizable approximation to some trigonometric functions for Float(32).  <a href="namespace_halide.html#a8f774e4779466acb57a6e571cb636ba6">More...</a><br /></td></tr>
<tr class="separator:a8f774e4779466acb57a6e571cb636ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137dfeea487e7444f0b20c14b545c0dd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a137dfeea487e7444f0b20c14b545c0dd">Halide::fast_cos</a> (const Expr &amp;x)</td></tr>
<tr class="separator:a137dfeea487e7444f0b20c14b545c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0c7bd26b46c10f2c3a6fc36da6a89518">Halide::fast_log</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="namespace_halide.html#a0c7bd26b46c10f2c3a6fc36da6a89518">More...</a><br /></td></tr>
<tr class="separator:a0c7bd26b46c10f2c3a6fc36da6a89518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744536415e304e37370fa6e216300354"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a744536415e304e37370fa6e216300354">Halide::fast_exp</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a744536415e304e37370fa6e216300354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="namespace_halide.html#a744536415e304e37370fa6e216300354">More...</a><br /></td></tr>
<tr class="separator:a744536415e304e37370fa6e216300354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">Halide::fast_pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">More...</a><br /></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343eac4b4aa329e52c7cbf8167902696"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">Halide::fast_inverse</a> (Expr x)</td></tr>
<tr class="memdesc:a343eac4b4aa329e52c7cbf8167902696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">More...</a><br /></td></tr>
<tr class="separator:a343eac4b4aa329e52c7cbf8167902696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4424b070b363f53107a6c2705bbe50b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">Halide::fast_inverse_sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:ad4424b070b363f53107a6c2705bbe50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">More...</a><br /></td></tr>
<tr class="separator:ad4424b070b363f53107a6c2705bbe50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">Halide::floor</a> (Expr x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">More...</a><br /></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">Halide::ceil</a> (Expr x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">More...</a><br /></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">Halide::round</a> (Expr x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">More...</a><br /></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f93889910a28197d2a1631486a433"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a287f93889910a28197d2a1631486a433">Halide::trunc</a> (Expr x)</td></tr>
<tr class="memdesc:a287f93889910a28197d2a1631486a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="namespace_halide.html#a287f93889910a28197d2a1631486a433">More...</a><br /></td></tr>
<tr class="separator:a287f93889910a28197d2a1631486a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c5b6b09e0f679724ccfb95515b338"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">Halide::is_nan</a> (Expr x)</td></tr>
<tr class="memdesc:ab71c5b6b09e0f679724ccfb95515b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">More...</a><br /></td></tr>
<tr class="separator:ab71c5b6b09e0f679724ccfb95515b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac519f67137d32cdf11dd43101d626349"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac519f67137d32cdf11dd43101d626349">Halide::is_inf</a> (Expr x)</td></tr>
<tr class="memdesc:ac519f67137d32cdf11dd43101d626349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is Inf or -Inf.  <a href="namespace_halide.html#ac519f67137d32cdf11dd43101d626349">More...</a><br /></td></tr>
<tr class="separator:ac519f67137d32cdf11dd43101d626349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f45a449357e2b40f7008e5630fb63"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac70f45a449357e2b40f7008e5630fb63">Halide::is_finite</a> (Expr x)</td></tr>
<tr class="memdesc:ac70f45a449357e2b40f7008e5630fb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a finite value (ie, neither NaN nor Inf).  <a href="namespace_halide.html#ac70f45a449357e2b40f7008e5630fb63">More...</a><br /></td></tr>
<tr class="separator:ac70f45a449357e2b40f7008e5630fb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a18e72ac620ae5d7944f8b15244ec5e32">Halide::fract</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a18e72ac620ae5d7944f8b15244ec5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="namespace_halide.html#a18e72ac620ae5d7944f8b15244ec5e32">More...</a><br /></td></tr>
<tr class="separator:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">Halide::reinterpret</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">More...</a><br /></td></tr>
<tr class="separator:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2012c20f1666555e7a229c9db1b64091">Halide::reinterpret</a> (Expr e)</td></tr>
<tr class="separator:a2012c20f1666555e7a229c9db1b64091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8e49b0b42230077ee6bdca669d299"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">Halide::operator&amp;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4ec8e49b0b42230077ee6bdca669d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">More...</a><br /></td></tr>
<tr class="separator:a4ec8e49b0b42230077ee6bdca669d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88242b4128c62353a9be9cec97ce7517"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a88242b4128c62353a9be9cec97ce7517">Halide::operator&amp;</a> (Expr x, int y)</td></tr>
<tr class="memdesc:a88242b4128c62353a9be9cec97ce7517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of an expression and an integer.  <a href="namespace_halide.html#a88242b4128c62353a9be9cec97ce7517">More...</a><br /></td></tr>
<tr class="separator:a88242b4128c62353a9be9cec97ce7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e5d84cbffa329f76a5a43aac5d3dd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a839e5d84cbffa329f76a5a43aac5d3dd">Halide::operator&amp;</a> (int x, Expr y)</td></tr>
<tr class="separator:a839e5d84cbffa329f76a5a43aac5d3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">Halide::operator|</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br /></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b42f239b51e5665705b31eeb353e64d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7b42f239b51e5665705b31eeb353e64d">Halide::operator|</a> (Expr x, int y)</td></tr>
<tr class="memdesc:a7b42f239b51e5665705b31eeb353e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of an expression and an integer.  <a href="namespace_halide.html#a7b42f239b51e5665705b31eeb353e64d">More...</a><br /></td></tr>
<tr class="separator:a7b42f239b51e5665705b31eeb353e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585fea347a8ec3bd113b466f6a8f5c93"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a585fea347a8ec3bd113b466f6a8f5c93">Halide::operator|</a> (int x, Expr y)</td></tr>
<tr class="separator:a585fea347a8ec3bd113b466f6a8f5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">Halide::operator^</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise xor of two expressions (which need not have the same type).  <a href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">More...</a><br /></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879829a780e257db389ba9ad59689f94"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a879829a780e257db389ba9ad59689f94">Halide::operator^</a> (Expr x, int y)</td></tr>
<tr class="memdesc:a879829a780e257db389ba9ad59689f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise xor of an expression and an integer.  <a href="namespace_halide.html#a879829a780e257db389ba9ad59689f94">More...</a><br /></td></tr>
<tr class="separator:a879829a780e257db389ba9ad59689f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367813f3f387e6e43565767a92d9829a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a367813f3f387e6e43565767a92d9829a">Halide::operator^</a> (int x, Expr y)</td></tr>
<tr class="separator:a367813f3f387e6e43565767a92d9829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c07e39289b14103ccd45ee31630a3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">Halide::operator~</a> (Expr x)</td></tr>
<tr class="memdesc:afc9c07e39289b14103ccd45ee31630a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">More...</a><br /></td></tr>
<tr class="separator:afc9c07e39289b14103ccd45ee31630a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">Halide::operator&lt;&lt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">More...</a><br /></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9bce43f9178ddb2fda8f1ef8c5755384">Halide::operator&lt;&lt;</a> (Expr x, int y)</td></tr>
<tr class="separator:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">Halide::operator&gt;&gt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br /></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7223753c831bcb54d39bbdf40733d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab8e7223753c831bcb54d39bbdf40733d">Halide::operator&gt;&gt;</a> (Expr x, int y)</td></tr>
<tr class="separator:ab8e7223753c831bcb54d39bbdf40733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">Halide::lerp</a> (Expr zero_val, Expr one_val, Expr weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="namespace_halide.html#a55158f5f229510194c425dfae256d530">More...</a><br /></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd5e65a4c167c112de447c628c099a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">Halide::popcount</a> (Expr x)</td></tr>
<tr class="memdesc:a41dd5e65a4c167c112de447c628c099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">More...</a><br /></td></tr>
<tr class="separator:a41dd5e65a4c167c112de447c628c099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39642cc99af99045ec5f424cde8709"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">Halide::count_leading_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:a0e39642cc99af99045ec5f424cde8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">More...</a><br /></td></tr>
<tr class="separator:a0e39642cc99af99045ec5f424cde8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">Halide::count_trailing_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:aa0042ff9c2283a15cda1a1e72de460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">More...</a><br /></td></tr>
<tr class="separator:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e12242ab5a192bdaa953510ae95bf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">Halide::div_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:aed6e12242ab5a192bdaa953510ae95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two integers, rounding towards zero.  <a href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">More...</a><br /></td></tr>
<tr class="separator:aed6e12242ab5a192bdaa953510ae95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">Halide::mod_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:ab0456fd6414e279eb3afdecf53eb8af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the remainder of dividing two integers, when division is rounding toward zero.  <a href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">More...</a><br /></td></tr>
<tr class="separator:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd57263c72c6712b643ab6486ed026"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">Halide::random_float</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:a59bd57263c72c6712b643ab6486ed026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">More...</a><br /></td></tr>
<tr class="separator:a59bd57263c72c6712b643ab6486ed026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160cd421537be8b4cd44fc32958604c2"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">Halide::random_uint</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:a160cd421537be8b4cd44fc32958604c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed unsigned 32-bit integer.  <a href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">More...</a><br /></td></tr>
<tr class="separator:a160cd421537be8b4cd44fc32958604c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5b59d6a43446e311633912427b2b3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">Halide::random_int</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:aaed5b59d6a43446e311633912427b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">More...</a><br /></td></tr>
<tr class="separator:aaed5b59d6a43446e311633912427b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad933f903f12d02dc4a41950751feb8f9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">Halide::print</a> (const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:ad933f903f12d02dc4a41950751feb8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints out its value whenever it is evaluated.  <a href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">More...</a><br /></td></tr>
<tr class="separator:ad933f903f12d02dc4a41950751feb8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb98ec9f8091af1beca6d93e9a95f23a">Halide::print</a> (Expr a, Args &amp;&amp;...args)</td></tr>
<tr class="separator:abb98ec9f8091af1beca6d93e9a95f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452ed699c61260cc230629777fc9cafa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a452ed699c61260cc230629777fc9cafa">Halide::print_when</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a452ed699c61260cc230629777fc9cafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="namespace_halide.html#a452ed699c61260cc230629777fc9cafa">More...</a><br /></td></tr>
<tr class="separator:a452ed699c61260cc230629777fc9cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc63366304ec6c0d67fd89fc6d985f34"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abc63366304ec6c0d67fd89fc6d985f34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc63366304ec6c0d67fd89fc6d985f34">Halide::print_when</a> (Expr condition, Expr a, Args &amp;&amp;...args)</td></tr>
<tr class="separator:abc63366304ec6c0d67fd89fc6d985f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac350d72e774314bb32beeb718d53c09e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">Halide::require</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:ac350d72e774314bb32beeb718d53c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that guarantees a precondition.  <a href="namespace_halide.html#ac350d72e774314bb32beeb718d53c09e">More...</a><br /></td></tr>
<tr class="separator:ac350d72e774314bb32beeb718d53c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0298ea2955b3ed763e7bfca9f5b805ea">Halide::require</a> (Expr condition, Expr value, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a0298ea2955b3ed763e7bfca9f5b805ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">Halide::undef</a> (Type t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">More...</a><br /></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">Halide::undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0c61f9a3eb7d89644951cf835ade09fa">Halide::memoize_tag</a> (Expr result, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0c61f9a3eb7d89644951cf835ade09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="namespace_halide.html#a0c61f9a3eb7d89644951cf835ade09fa">More...</a><br /></td></tr>
<tr class="separator:a0c61f9a3eb7d89644951cf835ade09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">Halide::likely</a> (Expr e)</td></tr>
<tr class="memdesc:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">More...</a><br /></td></tr>
<tr class="separator:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">Halide::likely_if_innermost</a> (Expr e)</td></tr>
<tr class="memdesc:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.  <a href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">More...</a><br /></td></tr>
<tr class="separator:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">Halide::saturating_cast</a> (Expr e)</td></tr>
<tr class="memdesc:a57a635db3b781aded60c79533001b9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">More...</a><br /></td></tr>
<tr class="separator:a57a635db3b781aded60c79533001b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe60c27f54efe535f84d7f94ce61c053"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe60c27f54efe535f84d7f94ce61c053">Halide::saturating_cast</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:abe60c27f54efe535f84d7f94ce61c053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type, clamping to the minimum and maximum values of the result type.  <a href="namespace_halide.html#abe60c27f54efe535f84d7f94ce61c053">More...</a><br /></td></tr>
<tr class="separator:abe60c27f54efe535f84d7f94ce61c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ccca78986958e405d34f08f41a103a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab2ccca78986958e405d34f08f41a103a">Halide::strict_float</a> (Expr e)</td></tr>
<tr class="memdesc:ab2ccca78986958e405d34f08f41a103a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a best effort attempt to preserve IEEE floating-point semantics in evaluating an expression.  <a href="namespace_halide.html#ab2ccca78986958e405d34f08f41a103a">More...</a><br /></td></tr>
<tr class="separator:ab2ccca78986958e405d34f08f41a103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f11f05c5df67082747354f264d30f17"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17">Halide::unsafe_promise_clamped</a> (const Expr &amp;value, const Expr &amp;min, const Expr &amp;max)</td></tr>
<tr class="memdesc:a5f11f05c5df67082747354f264d30f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> that that promises another <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> is clamped but do not generate code to check the assertion or modify the value.  <a href="namespace_halide.html#a5f11f05c5df67082747354f264d30f17">More...</a><br /></td></tr>
<tr class="separator:a5f11f05c5df67082747354f264d30f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90683a918dfa5840b97406468fef7501"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90683a918dfa5840b97406468fef7501">Halide::Internal::promise_clamped</a> (const Expr &amp;value, const Expr &amp;min, const Expr &amp;max)</td></tr>
<tr class="memdesc:a90683a918dfa5840b97406468fef7501"><td class="mdescLeft">&#160;</td><td class="mdescRight">FOR INTERNAL USE ONLY.  <a href="namespace_halide_1_1_internal.html#a90683a918dfa5840b97406468fef7501">More...</a><br /></td></tr>
<tr class="separator:a90683a918dfa5840b97406468fef7501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0498c6cada8da13d05bf285a813d16d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">Halide::scatter</a> (const std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="memdesc:aa0498c6cada8da13d05bf285a813d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter and gather are used for update definition which must store multiple values to distinct locations at the same time.  <a href="namespace_halide.html#aa0498c6cada8da13d05bf285a813d16d">More...</a><br /></td></tr>
<tr class="separator:aa0498c6cada8da13d05bf285a813d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435458ed41a7427361761df8b62fc047"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a435458ed41a7427361761df8b62fc047">Halide::gather</a> (const std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:a435458ed41a7427361761df8b62fc047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a035edd08e7ece3238ce2fa5ede9d8eb7">Halide::scatter</a> (const Expr &amp;e, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a035edd08e7ece3238ce2fa5ede9d8eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e82c6354cdd3a95aa207291ca15522b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7e82c6354cdd3a95aa207291ca15522b"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e82c6354cdd3a95aa207291ca15522b">Halide::gather</a> (const Expr &amp;e, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a7e82c6354cdd3a95aa207291ca15522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a> expressions. </p>

<p class="definition">Definition in file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_operator_8h.html">IROperator.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
